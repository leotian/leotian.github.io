<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>事件循环机制（1）——浏览器</title>
      <link href="/posts/3a50/"/>
      <url>/posts/3a50/</url>
      
        <content type="html"><![CDATA[<p>事件循环机制决定了我们所写的 JavaScript 代码的执行顺序。JavaScript的特性是单线程异步非阻塞，而这个线程中拥有唯一的事件循环。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JavaScript代码的执行过程中，依靠函数调用栈来搞定函数的执行顺序，依靠任务队列（task queue）来搞定另外一些代码的执行。一个线程中，事件循环是唯一的，但是任务队列可以拥有多个。任务队列又分为 macro-task（宏任务）与 micro-task（微任务），在最新标准中，它们被分别称为 task 与 jobs。</p><ul><li><p>macro-task：script(整体代码)，setTimeout，setInterval，I/O，UI rendering</p></li><li><p>micro-task：Promise，Object.observe(已废弃)，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" target="_blank" rel="noopener">MutationObserver</a>(html5新特性)</p></li></ul><p>setTimeout/setInterval/Promise/MutationObserver 的执行是同步的，但是他们可以通过声明回调函数或者 then 方法，把任务推入任务队列，等待下一次循环执行。</p><h2 id="事件循环执行顺序"><a href="#事件循环执行顺序" class="headerlink" title="事件循环执行顺序"></a>事件循环执行顺序</h2><p>事件循环的顺序，决定了JavaScript代码的执行顺序。它从 script(整体代码) 开始第一次循环。之后全局上下文进入函数调用栈。直到调用栈清空(只剩全局)，然后执行所有的 micro-task 。当所有可执行的 micro-task 执行完毕之后。循环再次从 macro-task 开始，找到其中一个任务队列执行完毕，然后再执行所有的micro-task，这样一直循环下去。而其中每一个任务的执行，无论是 macro-task 还是 micro-task，都是借助函数调用栈来完成。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> eventloop </tag>
            
            <tag> 事件循环机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>换电脑记录</title>
      <link href="/posts/82bb/"/>
      <url>/posts/82bb/</url>
      
        <content type="html"><![CDATA[<p>换电脑有一阵了，记录一下关键过程，以便下次换电脑。</p><a id="more"></a><h2 id="钥匙串"><a href="#钥匙串" class="headerlink" title="钥匙串"></a>钥匙串</h2><p><a href="https://support.apple.com/zh-cn/guide/keychain-access/kyca1121/mac" target="_blank" rel="noopener">将钥匙串拷贝到另一台 Mac</a></p><h2 id="应用数据迁移"><a href="#应用数据迁移" class="headerlink" title="应用数据迁移"></a>应用数据迁移</h2><p>当然，你可以直接全磁盘备份，但是那样可能有些慢，所以我只是手动迁移了一些关键应用的数据，像chrome、印象笔记这些，能同步的同步就好</p><h3 id="QQ-微信聊天记录"><a href="#QQ-微信聊天记录" class="headerlink" title="QQ/微信聊天记录"></a>QQ/微信聊天记录</h3><p>参考：<a href="https://www.zhihu.com/question/25667176" target="_blank" rel="noopener">如何迁移 Mac QQ 的聊天记录？</a></p><h3 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h3><p>使用 <code>File -&gt; Manager IDE Settings</code> 里的导出和导入配置做迁移</p><h3 id="Iterm2（profiles）"><a href="#Iterm2（profiles）" class="headerlink" title="Iterm2（profiles）"></a>Iterm2（profiles）</h3><p>使用 <code>Preferences —&gt; profiles —&gt; Other Actions</code> 里的保存和导入配置做迁移</p><h3 id="Sequel-pro"><a href="#Sequel-pro" class="headerlink" title="Sequel pro"></a>Sequel pro</h3><p>也是应用内自带的 Export/Import</p><h2 id="项目-代码"><a href="#项目-代码" class="headerlink" title="项目/代码"></a>项目/代码</h2><p>通过隔空投送传递，速度还挺快的。</p><h3 id="日志存储"><a href="#日志存储" class="headerlink" title="日志存储"></a>日志存储</h3><p>项目设置的日志存储位置在 <code>/logs</code> 下，但是升级至 Catalina 之后，硬盘会分为两部分：只读和可写两部分（具体可见<a href="https://support.apple.com/zh-cn/HT210650" target="_blank" rel="noopener">官方说明</a>），根目录只读，会导致项目起不来</p><p>解决办法是：</p><ol><li><p>首先设定SIP</p><ol><li>命令行输入：<code>csrutil status</code>，可以看到当前状态是 <code>System Integrity Protection status: enabled.</code></li><li>重启电脑，按住 <code>cmd+R</code> 进入恢复模式，用自己的账号密码登录</li><li>在顶部的菜单栏中选择 Terminal/终端，输入 <code>csrutil disable</code>，然后重启</li><li>重新命令输入：<code>csrutil status</code>，看到 <code>System Integrity Protection status: disabled.</code></li></ol></li><li><p>创建目录</p><ol><li><p>进入根目录：输入 <code>sudo mkdir /logs</code>，可以看到 <code>mkdir: /logs: Read-only file system</code>，此时仍然无法创建目录，因为/仍然是只读方式</p></li><li><p>设置 <code>sudo mount -uw /</code> 增加 write 的权限后可以创建目录</p></li><li><p><del>但注意此种方式如果重启，mount 设定的根目录的 write 属性就会失效，所以我们不能使用直接创建目录的方法</del></p></li><li><p>我们通过创建软链接的方法解决这个问题，在用户目录下创建 <code>~/logs</code> 目录，然后创建软链接 <code>ln -s /Users/tyb/logs /</code></p></li><li><p>设置成功后可以看到：<img src="https://images.leotian.cn/blog/image-20200722115216650.png" alt="image-20200722115216650"></p><p>再在 <code>logs</code> 目录下创建项目目录就可以正常使用了</p></li></ol></li></ol><h2 id="新装"><a href="#新装" class="headerlink" title="新装"></a>新装</h2><p><a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a>、<a href="https://www.v2ray.com" target="_blank" rel="noopener">v2ray</a> 等等直接看仓库安装就好了，装<a href="https://jamesdouble.github.io/blog/2019/12/19/xcCmdLine-1" target="_blank" rel="noopener">Xcode</a>比较慢，找个网络好的地方</p><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><p>安装及使用可以参考这篇文章：<a href="https://zhuanlan.zhihu.com/p/37195261" target="_blank" rel="noopener">iTerm2 + Oh My Zsh 打造舒适终端体验</a></p><h3 id="VsCode"><a href="#VsCode" class="headerlink" title="VsCode"></a>VsCode</h3><p>配置可以参考：<a href="https://zhuanlan.zhihu.com/p/79612479" target="_blank" rel="noopener">从零开始配置 vscode</a>、<a href="https://zhuanlan.zhihu.com/p/113222681" target="_blank" rel="noopener">史上最全vscode配置使用教程</a>，当然还有<a href="https://zhuanlan.zhihu.com/p/125773296" target="_blank" rel="noopener">那些你应该考虑卸载的 VSCode 扩展</a></p><p>配置命令行打开文件：<code>alias vsc=&#39;/Applications/Visual\ Studio\ Code.app/Contents/Resources/app/bin/code&#39;</code></p><h3 id="Typora-uPic"><a href="#Typora-uPic" class="headerlink" title="Typora+uPic"></a>Typora+uPic</h3><p>配置命令行打开文件：<code>alias typora=&quot;open -a typora&quot;</code>、<a href="https://github.com/gee1k/uPic" target="_blank" rel="noopener">uPic</a> 用于图片上传图床</p><h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>不要轻易更改用户名，涉及用户目录，会导致很多应用都不能用了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日常 </tag>
            
            <tag> 换电脑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊一聊ContextApi</title>
      <link href="/posts/61a1/"/>
      <url>/posts/61a1/</url>
      
        <content type="html"><![CDATA[<p>React 中的 Context API 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。但旧版 Context API 一直是被官方强调为试验性，不推荐使用，但新版 Context API 解决了旧版的一些弊端，不再有这些警告。</p><a id="more"></a><h2 id="旧的Context-API"><a href="#旧的Context-API" class="headerlink" title="旧的Context API"></a>旧的Context API</h2><p>以 Redux 的 Provider 为例我们先看下老的 Context API 是如何使用的。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;PropTypes, Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Provider</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">// 提供一个函数getChildContext，返回context对象</span></span><br><span class="line">  getChildContext() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      store: <span class="keyword">this</span>.props.store</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Provider.propTypes = &#123;</span><br><span class="line">  store: PropTypes.object.isRequired</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定childContextTypes属性，和getChildContext对应</span></span><br><span class="line">Provider.childContextTypes = &#123;</span><br><span class="line">  store: PropTypes.object</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Provider;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line"><span class="keyword">this</span>.context.store.subscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  <span class="keyword">this</span>.context.store.unsubscribe(<span class="keyword">this</span>.onChange);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样使用 Context API 的方法非常不 React，目标组件中的 this.context 非常 magic，顶层组件中 getChildContext() 也与 React 本身所推崇的声明式写法背道而驰，除此之外还有以下缺陷。</p><h3 id="破坏分形架构"><a href="#破坏分形架构" class="headerlink" title="破坏分形架构"></a>破坏分形架构</h3><p>Context 作为一个实验性质的 API，直到 React v16.3.0 版本前都一直不被官方所提倡去使用，其主要原因就是因为在子组件中使用 Context 会破坏 React 应用的<strong>分形架构</strong>。</p><p>这里的分形架构指的是从理想的 React 应用的根组件树中抽取的任意一部分都仍是一个可以直接运行的子组件树。在这个子组件树之上再包一层，就可以将它无缝地移植到任意一个其他的根组件树中。</p><p>但如果根组件树中有任意一个组件使用了支持 props  透传的 Context API，那么如果把包含了这个组件的子组件树单独拿出来，因为缺少了提供 Context 值的根组件树，这时的这个子组件树是无法直接运行的。</p><p>另一方面，虽然 React 官方不推崇使用 Context API，我们在日常工作中却每天都在使用着这个实验性质的 API。或者说虽然开发者可能在自己的应用中并没有直接调用过，但应用本身依赖的 <a href="https://cn.redux.js.org/docs/react-redux/" target="_blank" rel="noopener">react-redux</a> 或 <a href="https://cn.mobx.js.org/" target="_blank" rel="noopener">mobx-react</a> 等状态管理库之所以能够实现在任意组件中访问全局 store 这一功能，其基础依赖的就是 Context API。</p><h3 id="可能无法触发底层组件的-rerender"><a href="#可能无法触发底层组件的-rerender" class="headerlink" title="可能无法触发底层组件的 rerender"></a>可能无法触发底层组件的 rerender</h3><p>现有的原生 Context API 存在着一个致命的问题，那就是在 Context 值更新后，顶层组件向目标组件 props 透传的过程中，如果中间某个组件的 shouldComponentUpdate 函数返回了 false，因为无法再继续触发底层组件的 rerender，新的 Context 值将无法到达目标组件。这样的不确定性对于目标组件来说是完全不可控的，也就是说目标组件无法保证自己每一次都可以接收到更新后的 Context 值。</p><h2 id="新的-Context-API"><a href="#新的-Context-API" class="headerlink" title="新的 Context API"></a>新的 Context API</h2><p>新的 Context API 采用声明式的写法，并且可以透过 shouldComponentUpdate 返回 false 的组件继续向下传播，以保证目标组件一定可以接收到顶层组件 Context 值的更新，一举解决了现有 Context API 的两大弊端，也终于成为了 React 中的 Top-Level API。</p><p>新的 Context API 分为三个组成部分：</p><ul><li>React.createContext 用于初始化一个 Context。</li><li>XXXContext.Provider 作为顶层组件接收一个名为 value 的 prop，可以接收任意需要被放入 Context 中的字符串，数字，甚至是函数。</li><li>XXXContext.Consumer 作为目标组件可以出现在组件树的任意位置（在 Provider 之后），接收 children prop，这里的 children 必须是一个函数（context =&gt; ()）用来接收从顶层传来的 Context（render props模式，用 prop/child 传递一个 render 函数）。</li></ul><p>Demo：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThemeProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    theme: <span class="string">"dark"</span>,</span><br><span class="line">    color: <span class="string">"blue"</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  changeTheme = <span class="function"><span class="params">theme</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      theme</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  changeColor = <span class="function"><span class="params">color</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      color</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          theme: <span class="keyword">this</span>.state.theme,</span><br><span class="line">          color: <span class="keyword">this</span>.state.color,</span><br><span class="line">          changeColor: <span class="keyword">this</span>.changeColor</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &lt;button onClick=&#123;() =&gt; <span class="keyword">this</span>.changeTheme(<span class="string">"light"</span>)&#125;&gt;change theme&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SubComponent = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.theme&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;() =&gt; props.changeColor("red")&#125;&gt;change color&lt;/</span>button&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.color&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeProvider&gt;</span><br><span class="line">        &lt;ThemeContext.Consumer&gt;</span><br><span class="line">          &#123;context =&gt; (</span><br><span class="line">            &lt;SubComponent</span><br><span class="line">              theme=&#123;context.theme&#125;</span><br><span class="line">              color=&#123;context.color&#125;</span><br><span class="line">              changeColor=&#123;context.changeColor&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>ThemeProvider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById("app"));</span></span><br></pre></td></tr></table></figure><h2 id="vanilla模拟Redux"><a href="#vanilla模拟Redux" class="headerlink" title="vanilla模拟Redux"></a>vanilla模拟Redux</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">"react-dom"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  theme: <span class="string">"dark"</span>,</span><br><span class="line">  color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> GlobalStoreContext = React.createContext(&#123;</span><br><span class="line">  ...initialState</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GlobalStoreContextProvider</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// initialState</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    ...initialState</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reducer</span></span><br><span class="line">  handleContextChange = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"UPDATE_THEME"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          theme: action.theme</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"UPDATE_COLOR"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">          color: action.color</span><br><span class="line">        &#125;);</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"UPDATE_THEME_THEN_COLOR"</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          resolve(action.theme);</span><br><span class="line">        &#125;)</span><br><span class="line">          .then(<span class="function"><span class="params">theme</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              theme</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> action.color;</span><br><span class="line">          &#125;)</span><br><span class="line">          .then(<span class="function"><span class="params">color</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">              color</span><br><span class="line">            &#125;);</span><br><span class="line">          &#125;);</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;GlobalStoreContext.Provider</span><br><span class="line">        value=&#123;&#123;</span><br><span class="line">          dispatch: <span class="keyword">this</span>.handleContextChange,</span><br><span class="line">          theme: <span class="keyword">this</span>.state.theme,</span><br><span class="line">          color: <span class="keyword">this</span>.state.color</span><br><span class="line">        &#125;&#125;</span><br><span class="line">      &gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/GlobalStoreContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const SubComponent = props =&gt; (</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* action *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;button</span></span><br><span class="line"><span class="regexp">      onClick=&#123;() =&gt;</span></span><br><span class="line"><span class="regexp">        props.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">          type: "UPDATE_THEME",</span></span><br><span class="line"><span class="regexp">          theme: "light"</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">      change theme</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.theme&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* action *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;button</span></span><br><span class="line"><span class="regexp">      onClick=&#123;() =&gt;</span></span><br><span class="line"><span class="regexp">        props.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">          type: "UPDATE_COLOR",</span></span><br><span class="line"><span class="regexp">          color: "red"</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">      change color</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.color&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &#123;/</span>* action *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">    &lt;button</span></span><br><span class="line"><span class="regexp">      onClick=&#123;() =&gt;</span></span><br><span class="line"><span class="regexp">        props.dispatch(&#123;</span></span><br><span class="line"><span class="regexp">          type: "UPDATE_THEME_THEN_COLOR",</span></span><br><span class="line"><span class="regexp">          theme: "monokai",</span></span><br><span class="line"><span class="regexp">          color: "purple"</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">      &#125;</span></span><br><span class="line"><span class="regexp">    &gt;</span></span><br><span class="line"><span class="regexp">      change theme then color</span></span><br><span class="line"><span class="regexp">    &lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;GlobalStoreContextProvider&gt;</span></span><br><span class="line"><span class="regexp">        &lt;GlobalStoreContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">          &#123;context =&gt; (</span></span><br><span class="line"><span class="regexp">            &lt;SubComponent</span></span><br><span class="line"><span class="regexp">              theme=&#123;context.theme&#125;</span></span><br><span class="line"><span class="regexp">              color=&#123;context.color&#125;</span></span><br><span class="line"><span class="regexp">              dispatch=&#123;context.dispatch&#125;</span></span><br><span class="line"><span class="regexp">            /</span>&gt;</span><br><span class="line">          )&#125;</span><br><span class="line">        &lt;<span class="regexp">/GlobalStoreContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>GlobalStoreContextProvider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById("root"));</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用 Context API 实现了一个简单的 redux + react-redux，这证明了在新版 Context API 的支持下，原先 react-redux 帮我们做的一些工作现在我们可以自己来做了。另一方面，对于已经厌倦了整天都在写 action 和 reducer 的朋友们来说，在上面的例子中忽略掉 dispatch，action 等这些 Redux 中的概念，直接调用 React 中常见的 handleXXX 方法来 setState 也是完全没有问题的，可以有效地缓解 Redux 模板代码过多的问题。而对于 React 的初学者来说，更是省去了学习 Redux 及函数式编程相关概念与用法的过程。</p><p>如果说在现有 Context API 的基础上我们还需要 react-redux 的帮助去克服无法穿透 shouldComponentUpdate 返回 false 组件这个障碍的话，在新的 Context API 的语境中就真得不需要再将 redux 与 react-redux 作为项目开始时就必须安装的依赖了，如果我们只需要 props 透传这一个特性的话。</p><p>甚至在数据管理方面，新的 Context 还可以做得更好。新的 Context API 不受单一 store 的限制，每一个 Context 都相当于 store 中的一个分支，我们可以创建多个 Context 来管理不同类型的数据，相应的在使用时也可以只为目标组件上包上需要的 Context Provider。</p><p>最后，受益于新的 Context API 的声明式写法，我们终于可以抛开 Connect 轻松地写符合分形要求的业务组件了，如上面代码中的 SubComponent：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SubComponent = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.theme&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;button onClick=&#123;() =&gt; props.changeColor("red")&#125;&gt;change color&lt;/</span>button&gt;</span><br><span class="line">    &lt;div&gt;&#123;props.color&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SubComponentWithContext = <span class="function"><span class="params">props</span> =&gt;</span> (</span><br><span class="line">  &lt;ThemeContext.Consumer&gt;</span><br><span class="line">    &#123;context =&gt; (</span><br><span class="line">      &lt;SubComponent</span><br><span class="line">        theme=&#123;context.theme&#125;</span><br><span class="line">        color=&#123;context.color&#125;</span><br><span class="line">        changeColor=&#123;context.changeColor&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;<span class="regexp">/ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p>相较于 Redux 的写法，整体代码直观了许多，在后期组件层级调整时，代码的整体可复用性也提升了许多。</p><h2 id="对比新旧Context-API"><a href="#对比新旧Context-API" class="headerlink" title="对比新旧Context API"></a>对比新旧Context API</h2><h3 id="新的-Context-API-主要好处："><a href="#新的-Context-API-主要好处：" class="headerlink" title="新的 Context API 主要好处："></a>新的 Context API 主要好处：</h3><ol><li>应用了render props模式（不再需要子组件引入context，不破坏分形架构）</li><li>不再只是试验性，荣升 Top-Level API</li><li>新的 Context 有一个明显实用好处，就是可以很清晰地让多个Context交叉使用，比如组件树上可以有两个 Context Provider，就可以通过 Context1.Consumer、Context2.Consumer 直接区分开。</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context1.Consumer&gt;</span><br><span class="line">  &#123;</span><br><span class="line">     context1 =&gt; (</span><br><span class="line">       &lt;Context2.Consumer&gt;</span><br><span class="line">         &#123;</span><br><span class="line">           context2 =&gt; &#123;</span><br><span class="line">              <span class="comment">// 在这里可以通过代码选择从context1或者context2中获取数据</span></span><br><span class="line">              <span class="keyword">return</span> ...;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">       &lt;<span class="regexp">/Context2.Consumer&gt; </span></span><br><span class="line"><span class="regexp">     )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Context1.Consumer&gt;</span><br></pre></td></tr></table></figure><h3 id="不足的地方："><a href="#不足的地方：" class="headerlink" title="不足的地方："></a>不足的地方：</h3><p>新的 Context API 通过创建一个 Context 对象来完成，在实际项目中，Provider 和 Consumer 往往都存在于不同的源代码文件中，如何让他们访问同一个Context对象呢？一个最直接的方式，是在一个文件中定义 Context 对象，然后，这个文件被被其他文件来 import 。</p><p>可是，使用老的Context API并不需要这样，新的 Context API 貌似用 render props 这种模式优雅地解决了 context 的问题，但是却引入新的问题——如何管理 context 对象。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/267168180/answer/319754359" target="_blank" rel="noopener">如何解读 react 16.3 引入的新 context api？</a></p><p><a href="https://zhuanlan.zhihu.com/p/33925435" target="_blank" rel="noopener">从新的 Context API 看 React 应用设计模式</a></p><p><a href="https://zhuanlan.zhihu.com/p/34382261" target="_blank" rel="noopener">React 16.3新的Context API真的那么好吗？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> Context </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端数据管理与框架选择</title>
      <link href="/posts/f5d4/"/>
      <url>/posts/f5d4/</url>
      
        <content type="html"><![CDATA[<p>这篇文章源于一场知乎live，通过这场live整理了前端数据管理的发展历程，总结了一些常用的框架。</p><a id="more"></a><h2 id="从无到有"><a href="#从无到有" class="headerlink" title="从无到有"></a>从无到有</h2><p>前端诞生之初，只是作为一个文档出现，可以进行一些基础的排版，而交互仅限于表单提交。终端的计算能力差导致逻辑主要由后端处理，并且很长时间都耗费在兼容之中，网速也成为限制，更倾向于在终端直接获取结果，而不是拿到数据再在前端渲染，前端发展很慢，且对后端依赖很强（后端数据格式不对，只能等待）。页面之间也互相没有什么联系，路由控制在后端。</p><p><img src="https://images.leotian.cn/blog/20190813113524.png" alt></p><p>Ajax 普及之后，前端可以灵活的拉取数据，不需要一次全部加载，从此开始有了管理数据的需求，但是刚开始也是拿到数据后直接用（修改 DOM）。但是实际情况复杂的多，发起请求的地方有很多，请求回来对 DOM 的操作又有很多。</p><p><img src="https://images.leotian.cn/blog/20190813115159.png" alt></p><p>随着 ajax 请求越来越多，各路数据各自为战，变得不能接受，开始考虑把所有数据放在一起管理，再去用数据更新 DOM/组件，同时可以考虑用一个全局对象来管理数据。目前为止还没有框架，只有思想。</p><p><img src="https://images.leotian.cn/blog/20190813114911.png" alt></p><h2 id="前端的MVC方案"><a href="#前端的MVC方案" class="headerlink" title="前端的MVC方案"></a>前端的MVC方案</h2><p>16年入行的我，已经很少听说/使用这种框架了，但作为历史发展的一个阶段还是要了解一下。</p><p><a href="http://backbonejs.org/" target="_blank" rel="noopener">Backbone.js</a> 是一个早期的著名框架，在前端完整的实现了 MVC，提供了一个 <em>model</em> 类，以对象（也就是map）的形式存储数据，同时还有一个 <em><a href="https://wizardforcel.gitbooks.io/backbone-js-doc-112/5.html" target="_blank" rel="noopener">Collection</a></em>（集合）方法，存储模型的有序组合。相当于把数据库复制了一份到本地，本地提供 CRUD 各种方法去对接，Backbone 突破点在于把路由放在了前端，这样就可以整个数据层（或者不能叫数据层，而只是接口层）也放在前端（从而实现了业务数据的集中管理）。MVC 搬到前端解决了一些问题，前端可以像操作数据库一样在页面获取和存储数据，但是很快发现这种结构除了从后端转移了更多工作量以外，实际上没有解决很多核心问题。</p><p>前端数据的核心问题在于，前端的很多数据只是用来记录状态的，对于后端来说，这种状态变量大部分都是临时的，从库里取出来后只是临时辅助使用，而对于前端来说就很重要，因为它决定了视图层，这些变量往往和业务关联，状态之间也会互相关联。在 jquery 时代，用命令式处理这些变量，比如在 click 事件里让弹窗显示/隐藏，当这些逻辑变多起来后，我们开始疲于应对各种响应事件，业务逻辑和结构逻辑混在了一起。于是又有新的思想开始出现。</p><h2 id="UI-render-data"><a href="#UI-render-data" class="headerlink" title="UI=render(data)"></a>UI=render(data)</h2><p>Backbone MVC的结构中，直接照搬后端数据的问题在于，要把业务数据在C层组装，这样是不利于复用的（这里其实我有点不明白），而且方案中的DOM操作还是类似 jQuery 的处理，命令式的操作 DOM，修改状态（比如修改一个模态框的显示/隐藏等等）。</p><p>但其实我们发现，这些不适合放在数据库中读写，也不具备表结构的状态，同样是一种数据，并且没有被很好的管理，而且既然数据决定了 DOM，那么我们是不是没有必要非用命令式的方式去操作 DOM 呢？所以新的数据驱动式方案应运而生，状态作为数据被集中管理（state），并且可以驱动视图变化，这种新思想也可以叫做——数据驱动 UI（或者也可以叫一种数据的可视化，实际上前端就是在做 json 的可视化）：</p><ul><li>jquery：命令式操作DOM</li><li>Vue/React：不关心DOM，只关心数据，只要数据改变，DOM就变化</li></ul><p>比如一个弹窗的显示，jQuery 的操作是增加一个 DOM，删除一个 DOM，而数据驱动式框架中，只是一个 state 的 true/false 变化，至于 DOM 和变量之间的关联由框架完成（Vue 中自动完成，React 中使用 setState），总之关注点由 DOM 移到了数据。使得复用也可以通过组件化解决，把业务所需的视图做成标准件，对外依赖各种 state/props ，使得前端开发更加工程化。可以看到方案之间是相辅相成的，数据层面的集中也导致了视图层面的集中，也就是组件化。</p><p><img src="https://images.leotian.cn/blog/18351565668853_.pic_hd.jpg" alt></p><h2 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h2><p>前面说过数据分为业务数据和状态数据，状态数据大部分是和UI相关的，比如说单选框是否被勾选、按钮是否可以点击，但是这些都是组件内状态数据，他们不需要理解业务逻辑，只是业务逻辑的映射，React 中有一种组件叫木偶组件（或者叫傻瓜组件，对应的另一种叫容器组件），组件库提供的都是木偶组件，木偶组件是有简单状态或者无状态的，数据几乎全部依赖于输入。</p><p>还有另一种状态数据是跨组件的状态数据，并不是数据库中业务数据的映射，但是在前端交互中十分重要，比方说三级联动的地区选择器，一旦需要跨组件的交互，我们就需要一个通信机制解决父子/兄弟组件之间的通信，父对子就是 props，子对父可以做双向绑定（但是不推荐，vue2.0 已去掉），React 的处理方式（Vue 也可以）是父组件传递给子组件一个处理函数，但是这种处理方式并不优雅（层次过多则需要通过 props 层层传递）。我们需要比之前组件内状态（即 state）更大范围的数据集中管理。</p><p>至此，我们的数据管理又上了一个台阶，来到了一个新的世界：SPA应用的全局的数据管理（包括跨组件、跨页面等情况）。这里我们会遇到 Flux、EventBus、Redux、Mobx 等等一系列框架，live 后半部分都是在讲这些，内容太多我这里暂时不展开讲了，下面说一些我的思考。</p><h2 id="下一个问题"><a href="#下一个问题" class="headerlink" title="下一个问题"></a>下一个问题</h2><p>React 是一个 MVC 框架吗？那肯定不是的，我们先定义一下 MVC 再做讨论：</p><ul><li>Model （模型）负责管理数据 ，大部分业务逻辑也应该放在 Model 中；</li><li>View （视图）负责渲染用户界面，应该避免在 View 中涉及业务逻辑；</li><li>Controller （控制器）负责接受用户输入，根据用户输入调用对应的 Model 部分逻辑，把产生的数据结果交给 View 部分，让 View 渲染出必要的输出。</li></ul><p>在 MVC ( Model-View-Controller ）的世界里， React 相当于V（也就是 View ）的部分， 只涉及页面的渲染一旦涉及应用的数据管理部分，还是交给 Model 和 Controller 。但如果你只有一个页面，并且页面全部写在一个文件里，全部靠 state 维护的话，你勉强可以把 state 算成 Model（这个 Model 也太弱了），render 部分算作 View，但是实在找不出 Controller 了，而且我觉得这样强行类比也是有问题的，大部分情况作为一个应用我们不可能只有一个页面，只有一个页面也没必要非要上 React 了，也难以称得上是一个应用了，更没有MVC了。</p><blockquote><p>React — A JavaScript library for building user interfaces（React 官网定义）。</p></blockquote><p>所以我认为，React 应该只负责 View 层，并且是用来替换 jQuery 的，而 Flux 等框架才是以替换 Backbone.js 等MVC框架为目的，所以 React + Flux/Redux 才能勉强称得上MVC。对于 MVC 框架，为了让数据流可控，Controller 应该是中心，当View 要传递消息给 Model 时，应该调用 Controller 的方法，同样，当 Model 要更新 View 时，也应该通过 Controller 引发新的渲染，然而实际操作时经常不按流程来，所以 React + Flux/Redux 利用严格的单向数据流实现了 MVC（这么说也有很多问题，比如如果我们把 Dispatcher/Reducer 看做 C，那相比传统 MVC 框架没有负责路由，相比前端 MVC 又没有直接控制视图，而是通过控制数据控制视图，所以一般也不这么说，直接说单向数据流就好了）。</p><p>那么 Vue 是一个 MVVM 框架吗？这个就有很多疑惑了，因为很多人都这么认为，我们同样先定义一下MVVM：</p><ul><li>Model（模型）是数据和逻辑；</li><li>View（视图）是用户在屏幕上看到的结构、布局和外观，也称UI；</li><li>ViewModel（视图模型）是一个绑定器，能和 View 层和 Model 层进行通信。</li></ul><p><a href>MVVM</a> 的核心实现是由 ViewModel 层数据绑定，它的核心思想是分离，也就是通过 ViewModel 让 View 层和 Model 层解耦，这样有什么好处呢？ View 层不直接和 Model 层通信，他们只能通过 ViewModel 层通信。我们在  Vue 里套用一下 MVVM 的概念：</p><ul><li>View：单文件里 <code>&lt;template&gt;</code> 标签的内容，展现给用户的内容，与 ViewModel 双向绑定，可以在其中插入 ViewModel 提供的数据；</li><li>ViewModel：Vue 实例整个都是 ViewModel，与 View 双向绑定，用户在 View 修改数据或发出 ajax 等指令时， ViewModel 会及时相应，接着向下修改 Model——至此可以看出 Model 和 View 是没有直接关系的；</li><li>Model：这一层或者有歧义。为了更好理解 Model 需要引入 Vuex，在有 Vuex 的情况下，Vuex 提供的数据就是 Model，这符合后端架构中 Model 包含业务逻辑的情况。但是在无 Vuex 的情况下，Model 应该就是 Vue 实例的 data 属性，也就是 JavaScript 数据对象本身。</li></ul><p>认真看过 Vue 文档大概都能注意到，Vue 实例的变量名是 vm，文档中还很严谨地补充了一句 <a href="https://cn.vuejs.org/v2/guide/instance.html#创建一个-Vue-的实例" target="_blank" rel="noopener">“虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发”</a>。所以官方定调是不是，有些对于 Vue 违背MVVM的说法是：</p><blockquote><p>严格的 MVVM 要求 View 不能和 Model 直接通信，而 Vue 在组件提供了 $refs 这个属性，让 Model 可以直接操作 View，违反了这一规定，所以说 Vue 没有完全遵循 MVVM。</p></blockquote><p>至于对不对，我也不置可否，毕竟：</p><blockquote><p>If you put ten software architects into a room and have them discuss what the Model-View-Controller pattern is, you will end up with twelve different opinions.    — <em>Josh Smith</em></p></blockquote><p>所以这是个开放性的问题，没有标准答案，言之有理即可。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从最简单的页面的数据处理，到复杂系统如何管理数据、状态与样式，随着前端的发展，我们开始使用越来越复杂的框架，状态管理和组件化也一同迅速发展，随之而来的还有各种数据存储和管理的方案与框架。如何选择使用合适的方式管理前端数据，以及对框架进行选择，成为了现代前端都需要去考虑的问题。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/lives/896780923079639040" target="_blank" rel="noopener">前端数据管理与前端框架选择</a></p><p><a href="https://www.zhihu.com/question/327050991" target="_blank" rel="noopener">为什么尤雨溪尤大说VUE没有完全遵循MVVM？</a></p><p><a href="https://ssshooter.com/2019-01-08-understand-mvvm/" target="_blank" rel="noopener">浅析 web 前端 MVVM</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端数据管理 </tag>
            
            <tag> 框架选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker中部署node服务的构建优化</title>
      <link href="/posts/52b0/"/>
      <url>/posts/52b0/</url>
      
        <content type="html"><![CDATA[<p>node 服务全部切换 docker 部署后，构建阶段总有人反应很慢，原因是每次构建都要在 docker 中重新装包，就想怎么能优化一下，想了很多优化的路子，记录一下优化的思路，CI 使用 Jenkins。</p><a id="more"></a><h2 id="利用npm缓存-不可行，已放弃"><a href="#利用npm缓存-不可行，已放弃" class="headerlink" title="利用npm缓存(不可行，已放弃)"></a>利用npm缓存(不可行，已放弃)</h2><p>最近构建过程中还有个 bug，<code>node-sass</code> 这个包一直装不上，原因是有个二进制文件要从GitHub下载，但是一直下载不下来：</p><p><img src="https://images.leotian.cn/blog/2019-04-30-032823.png" alt="image-20190430112823001"></p><p>而我本地就安装的很快，本质上因为这个包我装过一次，所以直接从缓存取是很快的：</p><p><img src="https://images.leotian.cn/blog/2019-04-30-032851.png" alt="CA0A0064-2E7A-4D26-ADD3-C48055BF0647"></p><p>从安装过程我们也可以看到，安装好后会保存一份缓存在本地的 <code>.npm</code> 文件夹中：</p><p><img src="https://images.leotian.cn/blog/2019-04-30-033024.png" alt="image-20190430113023678"></p><p>所以我在想怎么在 docker 中装包时能使用到 npm 的缓存机制，我想到了两种方法：一种是在镜像外装好包后把 node_modules 拷贝进镜像中，这样就可以利用上构建服务器上<code>.npm</code>中的缓存，另一种是直接把<code>.npm</code>拷贝到镜像中，这样就可以用上缓存了。接下来看下实践。</p><h3 id="拷贝node-modules"><a href="#拷贝node-modules" class="headerlink" title="拷贝node_modules"></a>拷贝node_modules</h3><p>在镜像外的构建服务器上，我们会先安装一次<code>node_modules</code>（一般是用来编译我们的代码），在服务器上安装是可以利用服务器上的缓存的，而且我们一般不会删除之间安装的<code>node_modules</code>。这样的话如果我们能直接把外部安装好的<code>node_modules</code>拷贝进来，是不是可以大大缩短安装时间呢🤔？思考这个问题前，我们先要想一个问题：一台机器上装的<code>node_modules</code>是否可以用在别的机器上？我觉得应该是可以的，来试一下。</p><p>尝试在构建服务器提前装好包，同时把<code>.dockerignore</code>中的<code>node_modules</code>删除，这样 Dockerfile 中的<code>COPY . /app/</code>就可以把装好的包也复制进来，但是构建成功后，缺启动失败了，报错如下：</p><p><img src="https://images.leotian.cn/blog/2019-05-08-083425.png" alt="57FF6441-531A-4677-A0CE-152A893166EC"></p><p>可以看到启动失败了，原因是有个 C++库（libstdc++.so.6）获取不到，所以我猜想，在有些包使用 C++ 编写的动态链接共享对象，即 NodeJs 插件的时候，包是不能在不同系统间共享的。</p><p>实际上我觉得这样简单共享 node_modules 时，肯定还有其他因系统不同导致的兼容问题存在，除非内外系统完全一致，而且这样简单共享还有一个问题就是，在外部编译还是需要安装<code>devDependencies</code>的，但其实运行时完全不需要，会造成一定的冗余。</p><p>所以拷贝<code>node_modules</code>的方法是行不通的，我们接着往下看。</p><h3 id="拷贝-npm"><a href="#拷贝-npm" class="headerlink" title="拷贝.npm"></a>拷贝.npm</h3><p>直接拷贝 node_modules 不行，那么我们还有什么方法利用 npm 缓存呢，我想到了 .npm（可以使用<code>npm config get cache</code>查看位置），因为在本地安装的时候之所以快就是因为用到了 .npm 的缓存，那么我把构建服务器的 .npm 拷进容器不就可以用缓存了吗🤔？这样如果拷贝速度比下载速度快的话，也是可以加快构建速度的，再试一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Shell</span><br><span class="line">cp ~/.npm ./</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Dockerfile</span><br><span class="line">RUN cp -r ./.npm /root/</span><br></pre></td></tr></table></figure><p>首先要在构建服务器把缓存文件拷贝到当前目录（因为要在构建上下文才能复制到镜像中），然后更新 Dockerfile，构建 docker 时拷贝进镜像。结果一直卡在第一步的复制：</p><p><img src="https://images.leotian.cn/blog/2019-05-08-095048.png" alt="55587BA2-D844-4BEE-895D-2E3F6074FA97"></p><p>过了很长时间，我停了看了一眼 .npm 的大小：</p><p><img src="https://images.leotian.cn/blog/2019-05-08-095222.png" alt="CBF7FED6-6CA6-4437-A843-BBD8FA3CC667"></p><p>已经拷了 9.4G 了，还没拷完，我看了一下系统目录下的<code>.npm</code>大小：</p><p><img src="https://images.leotian.cn/blog/2019-05-08-095310.png" alt="57F0B362-129D-4940-8BCB-1535FDE5B7B4"></p><p>足足有12G，拷贝到每个项目下根本不现实，所以这种方案也放弃了。</p><h2 id="利用docker缓存机制"><a href="#利用docker缓存机制" class="headerlink" title="利用docker缓存机制"></a>利用docker缓存机制</h2><p>在利用 npm 缓存的方案都失败后，我想到了还有 docker 本身的缓存机制是不是可以用。</p><p>我们知道 Docker 构建是分层的，一条指令一层，在没有带<code>--no-cache=true</code>指令的情况下，如果某一层没有改动，Docker 就不会重新构建这一层而是使用缓存，先看 Docker 官方文档的<a href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/" target="_blank" rel="noopener">描述</a>：</p><blockquote><ul><li>Starting with a parent image that is already in the cache, the next instruction is compared against all child images derived from that base image to see if one of them was built using the exact same instruction. If not, the cache is invalidated.</li><li>In most cases, simply comparing the instruction in the Dockerfile with one of the child images is sufficient. However, certain instructions require more examination and explanation.</li><li>For the ADD and COPY instructions, the contents of the file(s) in the image are examined and a checksum is calculated for each file. The last-modified and last-accessed times of the file(s) are not considered in these checksums. During the cache lookup, the checksum is compared against the checksum in the existing images. If anything has changed in the file(s), such as the contents and metadata, then the cache is invalidated.</li><li>Aside from the <code>ADD</code> and <code>COPY</code> commands, cache checking does not look at the files in the container to determine a cache match. For example, when processing a <code>RUN apt-get -y update</code> command the files updated in the container are not examined to determine if a cache hit exists. In that case just the command string itself is used to find a match.</li></ul><p>Once the cache is invalidated, all subsequent <code>Dockerfile</code> commands generate new images and the cache is not used.</p></blockquote><p>简单来说就是如果第n层有改动，则n层以后的缓存都会失效，大多数情况下判断有无改动的方法是判断这层的指令和缓存中的构建指令是否一致（如果不想在某一句指令上使用缓存，有个小技巧就是在这个指令上加个空格），但是对于 COPY 和 ADD 命令（ADD 只是多了个解压的功能，尽量用 COPY，语义清晰一点），则是比较要拷贝的文件是否有改动，然后判断本层是否有改动。我们可以利用这个特性，选择先复制<code>package.json</code>并装包，再把其他文件拷贝进来，这样就能实现只在<code>package.json</code>变动的时候重新安装，在没有变动的情况下使用缓存缩短构建时间。我们对 Dockerfile 进行修改：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> xingshulin/node-with-pm2:<span class="number">10.13</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝所有文件 每次都更新无法使用缓存</span></span><br><span class="line"><span class="keyword">COPY</span> . /app/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装包</span></span><br><span class="line"><span class="keyword">RUN</span> npm install --registry=http://npm.xingshulin.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># --no-daemon不是不守护 而是在前台守护 否则前台没有进程docker容器会自动退出</span></span><br><span class="line"><span class="keyword">CMD</span> pm2 start ./index.js --no-daemon &gt;&gt; /dev/null</span><br></pre></td></tr></table></figure><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> xingshulin/node-with-pm2:<span class="number">10.13</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span> /app</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改为先拷贝package.json文件</span></span><br><span class="line"><span class="keyword">COPY</span> package.json /app/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装包</span></span><br><span class="line"><span class="keyword">RUN</span> npm install --registry=http://npm.xingshulin.com/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再拷贝剩余的文件</span></span><br><span class="line"><span class="keyword">COPY</span> . /app/</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> pm2 start ./index.js --no-daemon &gt;&gt; /dev/null</span><br></pre></td></tr></table></figure><p>我们修改除 package.json/Dockerfile 外其他文件，然后对比构建的日志：</p><table><thead><tr><th>全部复制</th><th>先复制package.json</th></tr></thead><tbody><tr><td><img src="https://images.leotian.cn/blog/2019-05-10-040142.png" alt="image-20190510120142345"></td><td><img src="https://images.leotian.cn/blog/2019-05-10-040856.png" alt="image-20190510120855766"></td></tr></tbody></table><p>可以看到全部复制从复制开始就无法使用缓存了，而先复制 package.json 则可以在装包阶段也使用缓存。 </p><p>为了验证优化的有效性，同一个项目我使用两种形式分别进行了5次构建，从时间上来看，除了优化后第一次构建慢了一点外，之后有了缓存构建起来还是挺快的，优化效果还是肉眼可见的：    </p><p><img src="https://images.leotian.cn/blog/2019-05-10-065549.png" alt="image-20190510145549393"></p><p><img src="https://images.leotian.cn/blog/2019-05-10-065558.png" alt="image-20190510145557696"></p><h2 id="构建基础镜像"><a href="#构建基础镜像" class="headerlink" title="构建基础镜像"></a>构建基础镜像</h2><p>我们发现构建中还有很多东西是不需要经常变动的，比如 apt-get 安装的一些工具包，还有做进程守护的 pm2，这些最好把他们提前打包好构建一个基础镜像，以后从基础镜像开始构建，是最节省时间的（缓存有失效风险并且对比时间也省去了，虽然不知道对比时间有多少），我构建了一些基础镜像够日常开发使用，并推送到了<a href="https://hub.docker.com" target="_blank" rel="noopener">Docker Hub</a>：</p><p><img src="https://images.leotian.cn/blog/2019-05-10-063552.png" alt="image-20190510143551785"></p><p>我还写了一些shell脚本帮助更新基础镜像，这次先不具体介绍。</p><h2 id="更多的想法"><a href="#更多的想法" class="headerlink" title="更多的想法"></a>更多的想法</h2><p>我还看到了一些其他的优化想法，一起贴在这里。</p><h3 id="挂载-npm-目录"><a href="#挂载-npm-目录" class="headerlink" title="挂载 .npm 目录"></a>挂载 .npm 目录</h3><p>容器中可以挂载主机目录，但是构建阶段是不可以的，所以还是行不通。</p><h3 id="使用-CMD-启动后安装"><a href="#使用-CMD-启动后安装" class="headerlink" title="使用 CMD 启动后安装"></a>使用 CMD 启动后安装</h3><p>CMD 命令用来描述容器启动后运行的程序（如果 Dockerfile 中有多个 CMD 指令，只有最后一个 CMD  有效），除了直接运行，我们也可以运行一个 shell：<code>CMD [&quot;sh&quot;, &quot;./dockerShell.sh&quot;]</code>。</p><p>我们可以把安装放在启动之后，这样就可以通过把 .npm 挂载到容器来使用缓存，装包之后再启动服务，但是这样的话服务的重启时间就比较长，我们还是希望服务能快速启动，对回滚也有好处，并且如果启动后直接找不到包，会一直报错，担心跑满服务器 CPU 影响其他服务。</p><h3 id="使用上一次的镜像"><a href="#使用上一次的镜像" class="headerlink" title="使用上一次的镜像"></a>使用上一次的镜像</h3><p>每次以上一次构建的镜像为基础镜像进行构建也是不错的想法，按道理说之前的node_modules都在，也有缓存，装起来应该很快。</p><p>但是我试了下没有成功，package.json 改变后重新装包时没有走缓存，但是 .npm 是确实存在的，可能是对 docker 镜像构建或者 npm 缓存机制理解还不深，有谁知道可以帮忙解释下。</p><p>如果成功的话，仔细想一下这样优化的好处在于更新 package.json 后，只需要安装最新更新的包，并且有本地缓存，也有一些不完美的地方，比如第一次时没有上一次，要单独构建，并且要保留第一次构建的脚本，以防忘记一些第一次构建的细节，不知道对基础镜像做过什么了。</p><h3 id="构建服务器"><a href="#构建服务器" class="headerlink" title="构建服务器"></a>构建服务器</h3><h4 id="启动一个容器作为构建服务器"><a href="#启动一个容器作为构建服务器" class="headerlink" title="启动一个容器作为构建服务器"></a>启动一个容器作为构建服务器</h4><p>之前都是直接在 Jenkins 所在服务器上构建的前端代码，有些缺库少权限的问题还得找运维解决。设想一下如果我们自己起一个 docker 容器，专门用来构建，是不是自主权就多了很多，而且如果跟部署环境是一样的话，node_modules 应该是可以直接复制的？复制的话，就要在构建容器/服务器/服务容器之间来回复制，或者直接使用 docker 嵌套？但是我感觉嵌套的话太臃肿了，三者或者去掉最终服务容器的两者（构建容器和服务器，服务容器不使用挂载，保证最终服务容器的完整性）挂载一个目录我觉得也是可行的方法。</p><h4 id="借助-docker-compose"><a href="#借助-docker-compose" class="headerlink" title="借助 docker-compose"></a>借助 docker-compose</h4><p>再设想一下，把构建服务器和运行的服务器一起编排，是不是方便一些？</p><p>以上两种方法都还没试，不知道效果怎么样。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.cnblogs.com/qixidi/p/10414078.html" target="_blank" rel="noopener">利用构建缓存机制缩短Docker镜像构建时</a></p><p><a href="https://stackoverflow.com/questions/35774714/how-to-cache-the-run-npm-install-instruction-when-docker-build-a-dockerfile" target="_blank" rel="noopener">How to cache the RUN npm install instruction when docker build a Dockerfile</a></p><p><a href="https://itnext.io/npm-install-with-cache-in-docker-4bb85283fa12" target="_blank" rel="noopener">npm install with cache in docker</a></p><p>缓存策略的更多知识可以看这里：</p><p><a href="http://www.ruanyifeng.com/blog/2016/01/npm-install.html" target="_blank" rel="noopener">npm 模块安装机制简介</a></p><p><a href="https://www.zhihu.com/question/305539244" target="_blank" rel="noopener">npm缓存现在是怎么做的？</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo更换图床和全站CDN</title>
      <link href="/posts/f37e/"/>
      <url>/posts/f37e/</url>
      
        <content type="html"><![CDATA[<p>最近更新博客，突然发现所有图片都挂掉了，网上搜了一下，发现不是个例，哀嚎一片，所以更换了一家对象存储，迁移了博客中引用的全部图片，顺便做了全站CDN的优化，访问速度也快了许多，记录一下。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-090639.gif" alt="1556528268464004"></p><a id="more"></a><h2 id="微博图床"><a href="#微博图床" class="headerlink" title="微博图床"></a>微博图床</h2><p>之前一直用着微博图床，免费而且具备全网 CDN 加速，支持 HTTPS，但是最近突然不能用了：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-092834.png" alt="image-20190429172834350"></p><p><img src="https://images.leotian.cn/blog/2019-04-29-092303.png" alt="image-20190429172302902"></p><p>你会发现，在文章页插入的图片均无法正常显示（返回403错误，403 Forbidden 是HTTP协议中的一个HTTP状态码（Status Code）。可以简单的理解为没有权限访问此站，服务器收到请求但拒绝提供服务），而单独访问图片链接却是可以看到图片的。显然，新浪微博图床已经开启了防盗链。</p><p>现在的防盗链基本都是通过请求头中的 Referer 判断的，所以有一个简单的方法绕过防盗链，那就是阻止浏览器发送 Referer。我用的是 Next 主题，编辑主题目录下的 <code>/next/layout/_partials/head.swig</code> 文件，在头部加入下面的 meta 标签即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"referrer"</span> content=<span class="string">"no-referrer"</span> /&gt;</span><br></pre></td></tr></table></figure><p>亲测这样可以保证在博客页面中正常浏览，但是我在本地用 Typora 编辑文章时还是访问不到图片，所以为了使用方便和网站内容稳定考虑，还是建议大家把图片迁移到云存储空间自己维护，毕竟别的免费图床和微博相比稳定性和可持续性可能更差。</p><h2 id="迁移又拍云"><a href="#迁移又拍云" class="headerlink" title="迁移又拍云"></a>迁移又拍云</h2><p>在选择了一圈 OSS 服务后，我选择了又拍云：</p><blockquote><p>官网地址：<a href="https://link.zhihu.com/?target=https%3A//console.upyun.com/register/%3Finvite%3DBkjBFT1uX" target="_blank" rel="noopener">https://www.upyun.com</a></p><p>简介：注册认证后有10G永久免费空间，每月15G的HTTP和HTTPS流量，提供两款可以免费续期的SSL证书，不过用户需要加入<a href="https://link.zhihu.com/?target=https%3A//www.upyun.com/league" target="_blank" rel="noopener">又拍云联盟</a>（即在网站底部添加又拍云logo及官网链接）</p><p>图片上传限制：无</p></blockquote><p>注册账号后，我新建了仓库，然后开始迁移工作，我在本地使用的是 Typora 作为 Markdown 编辑器并搭配 iPic 做图片插入（iPic 如果要上传图片到微博图床以外的空间需要收费，不过可以免费体验7天），修改图传为又拍云后，使用迁移工具 iPic Mover（只要选择 Markdown 文件所在文件夹就可以迁移整站，很方便）做整站迁移。</p><p>迁移完毕后又绑定了我自己的域名作为加速域名，并做了 https 证书的配置，整个很顺畅，根据说明操作就行，不再详细阐述。</p><h2 id="全站CDN"><a href="#全站CDN" class="headerlink" title="全站CDN"></a>全站CDN</h2><p>迁移过程中发现了又拍云的 CDN 服务，之前使用 <a href="https://coding.net/pages" target="_blank" rel="noopener">Coding Pages</a> 做网站的静态页面托管，真的是太慢了，所以想乘机加速一下网站的打开速度。</p><p>但是如果单纯配置域名解析到又拍云，再配置CDN指向服务地址（tybleo.coding.me）好像并没有加速多少，而且还有一些 bug（js/css请求异常）。所以索性又开了一个存储空间，把网站整个上传到又拍云，直接使用又拍云的作为托管服务（使用插件 <a href="https://github.com/Menci/hexo-deployer-upyun" target="_blank" rel="noopener">hexo-deployer-upyun</a> 可以方便的把服务部署到又拍云 ），又拍云的云存储服务是与 CDN 无缝衔接的，用户无需特殊配置，很方便。</p><p>同样配置了加速域名为自己的域名和 https 证书后，又开启了页面压缩等优化配置，再次打开页面，发现速度肉眼可见的快了一大截，又拍云不愧是专业的 CDN 服务，不过关于CDN的知识还有好多没有搞懂（比如页面缓存问题），之后再深入研究下。</p><p>迁移和优化至此告一段落了，刚写了一个修改短链后恢复浏览量的脚本，现在准备再写个图片维护的脚本（未使用图片的删除/备份），到时候再更新。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 图床 </tag>
            
            <tag> CDN </tag>
            
            <tag> 又拍云 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo修改短链及浏览量恢复</title>
      <link href="/posts/5389/"/>
      <url>/posts/5389/</url>
      
        <content type="html"><![CDATA[<p>最近使用博客的时候发现，复制出来的文章URL都太长了，所以想启用短链，记录一下修改过程。</p><a id="more"></a><h2 id="修改短链"><a href="#修改短链" class="headerlink" title="修改短链"></a>修改短链</h2><h3 id="URL优化"><a href="#URL优化" class="headerlink" title="URL优化"></a>URL优化</h3><p>Hexo默认的链接是<code>permalink: :year/:month/:day/:title/</code>，文章名称是新建的md文件的文件名，很多时候我都是建中文名字，但是中文路径复制下来会特别长，对于搜索引擎优化不友好，而且一旦文章名字改变，链接也跟着改变，一个好的URL设计，不仅有利于网络爬虫的爬取，更有利于用户的体验。<strong>正确的URL设计应该满足：长度尽量短，目录层次尽量少，全小写，连字符使用中划线<code>-</code>，具有描述性，包含关键词等。</strong></p><h3 id="使用abbrlink"><a href="#使用abbrlink" class="headerlink" title="使用abbrlink"></a>使用abbrlink</h3><p>我选择了 <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">rozbo/hexo-abbrlink</a> 插件解决上面所说的问题，abbrlink生成的链接短小精悍，并且可以同时保证唯一和持久。</p><ol><li>安装abbrlink插件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><ol start="2"><li>在站点配置文件里修改：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># permalink: posts/:year/:month/:day/:title.html  // 默认永久链接冗长，title中存在中文字符</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">post/:abbrlink/</span></span><br><span class="line"><span class="comment"># 结尾的"/"如果去掉，在我本地点开文章时会有问题，所以加了"/"</span></span><br><span class="line"><span class="comment"># 还可以使用类似 post/:abbrlink.html 这种链接</span></span><br><span class="line"></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"><span class="attr">  alg:</span> <span class="string">crc16</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line"><span class="attr">  rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br><span class="line"><span class="comment"># 使用crc16已经能生成65535篇文章了，对于个人博客感觉已经够用了</span></span><br><span class="line"><span class="comment"># 使用hex是因为我觉得带字母好看一点</span></span><br></pre></td></tr></table></figure><ul><li>优化前：</li></ul><p><img src="https://images.leotian.cn/blog/2019-05-09-061957.png" alt="image-20190509141956909"></p><p><a href="http://localhost:4000/posts/2019/04/19/hexo修改短链及浏览量恢复/" target="_blank" rel="noopener">http://localhost:4000/posts/2019/04/19/hexo%E4%BF%AE%E6%94%B9%E7%9F%AD%E9%93%BE%E5%8F%8A%E6%B5%8F%E8%A7%88%E9%87%8F%E6%81%A2%E5%A4%8D/</a></p><ul><li>优化后：</li></ul><p><img src="https://images.leotian.cn/blog/2019-05-09-062150.png" alt="image-20190509142150265"></p><p><a href="http://localhost:4000/posts/5389/" target="_blank" rel="noopener">http://localhost:4000/posts/5389/</a></p><p>成功修改短链后我发现一个问题，那就是文章的浏览量没了，访问量我们使用的是leancloud来记录的（使用next只需要简单的<a href="https://notes.doublemine.me/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html" target="_blank" rel="noopener">配置</a>就可以使用leancloud记录访问量），而访问量的消失主要是因为文章的链接都改了，接下来我们尝试恢复一下每篇文章的访问量。</p><h2 id="浏览量恢复"><a href="#浏览量恢复" class="headerlink" title="浏览量恢复"></a>浏览量恢复</h2><p>我们先看一下leancloud是如何存储我们的浏览记录的：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101851.jpg" alt="img"></p><p>可以看到主要有title（标题）、url和time（次数），我们的主要问题是记录的url变了，所以对应关系丢失了，只要恢复正确的url，对应关系就可以重建了，而time对我们恢复关系没有用，只有根据title恢复了。</p><p>所以我们要先查到每篇文章的标题，然后从库里找出对应的记录，修改url为正确的地址，这样对应关系就能回来了，获取每篇文章的内容我想到了两种方法：一种是遍历本地生成的html文件获取title，另一种是写个爬虫爬自己的网站。</p><h3 id="遍历本地文件实现"><a href="#遍历本地文件实现" class="headerlink" title="遍历本地文件实现"></a>遍历本地文件实现</h3><p>本地hexo目录的<code>public/posts</code>文件夹下存放了生成的静态文件，我们遍历这个文件夹拿到每篇文章：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPostsByDir</span>(<span class="params">postDir</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> htmlList = fs.readdirSync(postDir)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> postList = htmlList.map(<span class="function">(<span class="params">abbrLink</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 从本地文件获取html</span></span><br><span class="line">    <span class="keyword">const</span> html = fs.readFileSync(<span class="string">`<span class="subst">$&#123;postDir&#125;</span>/<span class="subst">$&#123;abbrLink&#125;</span>/index.html`</span>).toString()</span><br><span class="line">    <span class="comment">// 加载html 获取title</span></span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(html)</span><br><span class="line">    <span class="keyword">const</span> postTitle = $(<span class="string">".post-title"</span>).text()</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      abbrLink,</span><br><span class="line">      postTitle,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> postList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="爬虫实现"><a href="#爬虫实现" class="headerlink" title="爬虫实现"></a>爬虫实现</h3><p>hexo生成的是静态页面，我们可以用简单的GET请求爬取页面内容，然后使用<a href="https://cnodejs.org/topic/5203a71844e76d216a727d2e" target="_blank" rel="noopener">cheerio</a>分析处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">'axios'</span>)</span><br><span class="line"><span class="keyword">const</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getPostList = <span class="function">(<span class="params">$</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> postList = []</span><br><span class="line">  <span class="comment">// 获取首页标题</span></span><br><span class="line">  $(<span class="string">".post-title-link"</span>).each(<span class="function">(<span class="params">i, elem</span>) =&gt;</span> &#123;</span><br><span class="line">    postList.push(&#123;</span><br><span class="line">      abbrLink: $(elem).attr(<span class="string">'href'</span>).replace(<span class="string">'posts'</span>, <span class="string">''</span>).replace(<span class="regexp">/\//g</span>, <span class="string">''</span>),</span><br><span class="line">      postTitle: $(elem).text(),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> postList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getPostsByReptile</span>(<span class="params">domain</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> postList = []</span><br><span class="line">  <span class="comment">// 获取总页数</span></span><br><span class="line">  <span class="keyword">const</span> homePage = <span class="keyword">await</span> axios.get(domain)</span><br><span class="line">  <span class="keyword">const</span> postPages = cheerio.load(homePage.data)(<span class="string">".page-number"</span>).last().text()</span><br><span class="line">  <span class="comment">// 获取每页的文章标题和链接</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= postPages; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> url = i &gt; <span class="number">2</span> ? <span class="string">`<span class="subst">$&#123;domain&#125;</span>/page/<span class="subst">$&#123;i&#125;</span>/`</span> : domain</span><br><span class="line">    <span class="keyword">const</span> html = <span class="keyword">await</span> axios.get(url)</span><br><span class="line">    <span class="keyword">const</span> $ = cheerio.load(html.data)</span><br><span class="line">    postList = postList.concat(getPostList($))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> postList</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tip：针对静态页面的爬虫还是比较简单的，如果是动态页面就需要搭配<em>Puppeteer</em>（一种Chrome的无界面/Headless工具）进行了。</p><h3 id="恢复浏览量"><a href="#恢复浏览量" class="headerlink" title="恢复浏览量"></a>恢复浏览量</h3><p>通过title搜到文章，然后修改对应的文章链接：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AV = <span class="built_in">require</span>(<span class="string">'leancloud-storage'</span>)</span><br><span class="line"></span><br><span class="line">AV.init(&#123;</span><br><span class="line">  appId: <span class="string">'GxfYzf5roQxLdedcwOheEnWE-gzGzoHsz'</span>,</span><br><span class="line">  appKey: <span class="string">'MomkTz6Tq1aBGWvzNDSv8o31'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve(postList).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  result.forEach(<span class="function">(<span class="params">post</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 查询同一标题下的所有记录</span></span><br><span class="line">    <span class="keyword">const</span> query = <span class="keyword">new</span> AV.Query(<span class="string">'Counter'</span>)</span><br><span class="line">    query.equalTo(<span class="string">'title'</span>, post.postTitle)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留下times最多的一个 修改url 并修改其他脏数据url</span></span><br><span class="line">    query.find().then(<span class="function">(<span class="params">results</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> maxResult = results[<span class="number">0</span>]</span><br><span class="line">      results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(result.attributes.time &gt; maxResult.attributes.time) maxResult = result</span><br><span class="line">      &#125;)</span><br><span class="line">      maxResult.set(<span class="string">'url'</span>, <span class="string">`/posts/<span class="subst">$&#123;post.abbrLink&#125;</span>/`</span>)</span><br><span class="line">      maxResult.save()</span><br><span class="line"></span><br><span class="line">      <span class="built_in">console</span>.log(maxResult)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 更改短链后有一些新的访问 属于脏数据 把他们的链接修改错误来解除关联关系</span></span><br><span class="line">      results.forEach(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(result.attributes.url === maxResult.attributes.url &amp;&amp; result.id !== maxResult.id) &#123;</span><br><span class="line">          result.set(<span class="string">'url'</span>, <span class="string">`/posts/<span class="subst">$&#123;post.abbrLink&#125;</span>`</span>)</span><br><span class="line">          result.save()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>首先使用了 <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">rozbo/hexo-abbrlink</a> 设置了文章的短链，然后因为浏览量丢失，写脚本恢复了访问量，恢复的代码放在<a href="https://github.com/leotian/recover-view-count" target="_blank" rel="noopener">这里</a>，欢迎使用和提bug。</p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> abbrlink </tag>
            
            <tag> 爬虫 </tag>
            
            <tag> leancloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次网站代理配置</title>
      <link href="/posts/aaba/"/>
      <url>/posts/aaba/</url>
      
        <content type="html"><![CDATA[<p>最近遇到一个需要合并两个域名到一个域名下的需求，记录一下解决过程。</p><a id="more"></a><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>一个项目需要和其他公司协作完成，遇到这么一个问题：页面要在对方微信中使用，并且要使用微信JS-SDK做一些操作。但微信公众平台可以配置的JS接口安全域名只有三个，而对方公司留给我们的名额只有一个，这就要求我们必须把两个域名合并成一个来提供服务。</p><p>需要合并的两个域名：</p><p>wxpage.xingshulin.com、utm.xingshulin.com</p><p>需要合并到的域名：</p><p>open.xingshulin.com</p><p>合并之后由一个域名下的两个一级目录分别提供服务：</p><p>open.xingshulin.com/wxpage、open.xingshulin.com/utm</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>做之前就想起之前遇到过一次类似的需求，是把 <code>blog.xingshulin.com</code> 合并到了 <code>www.xingshulin.com/blog</code> 下，是运维帮忙配置的Nginx，参考当时的配置自己配了一下：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> com_qa-weather &#123;</span><br><span class="line">    <span class="attribute">server</span> localhost:<span class="number">8080</span> weight=<span class="number">1</span> max_fails=<span class="number">2</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         nginx.leotian.cn;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">proxy_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">server_name_in_redirect</span> <span class="literal">off</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> REMOTE-HOST <span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> /wxpage/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://com_qa-weather/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上次只简单配置了 location 的 proxy_pass（location 和proxy_pass的绝对路径相对路径也是要注意的一个点，具体请看<a href="https://www.jianshu.com/p/b113bd14f584" target="_blank" rel="noopener">这里</a>），也就是访问 nginx.leotian.cn 时对 localhost:8080 做反向代理，透明传输，这样配置的话，我们看下访问 nginx.leotian.cn/weather/ 请求到的是什么：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102101.jpg" alt="image-20190408112243555"></p><p>可以看到，服务的根页面正常返回，但是根页面上请求的资源文件都是 404，因为资源文件并没有被反向代理，而我们域名的根目录下也没有 <code>static/xx</code> 这些资源文件，自然就404了，如果要解决这个问题，我们需要把 weather 服务的所有资源文件都放在 /weather/ 下，上次把 <code>www.xingshulin.com/blog</code> 代理到 <code>blog.xingshulin.com</code> 服务时就是这么做的，把 blog 服务的所有的资源文件都放在了一级目录 /blog 下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102103.jpg" alt="image-20190408113037629"></p><p><img src="https://images.leotian.cn/blog/2019-04-29-102104.jpg" alt="image-20190408113028325"></p><p>那么如何不挪动资源文件的进行修改呢？我们增加一个 location 配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$r_location</span>  <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$http_referer</span> <span class="regexp">~* ^http?:\/\/nginx.leotian.cn\/(weather)\/)</span> &#123;</span><br><span class="line">      <span class="attribute">set</span> <span class="variable">$r_location</span> <span class="variable">$1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">if</span> (<span class="variable">$r_location</span>) &#123;</span><br><span class="line">      <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /<span class="variable">$r_location</span>/<span class="variable">$1</span> <span class="literal">last</span>;</span><br><span class="line">      <span class="comment">#rewrite ^/(.*) /$r_location/$request_uri last;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">rewrite_log</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span> /logs/error.log ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一下上面这段配置的逻辑（上面用到了 rewrite 模块的一些功能，具体使用请参考<a href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html" target="_blank" rel="noopener">文档</a>和<a href="https://segmentfault.com/a/1190000008102599" target="_blank" rel="noopener">文章</a>）：</p><p>如果请求的 referer 包含 weather，我们就能知道这个请求应该是指向 weather 服务的，那么 rewrite URL 为 <code>/weather/原请求地址</code>，然后再经过第一个 location 进行反向代理，页面请求的资源文件就也可以拿到了，就不用再要求服务去把页面请求的资源文件挪动到 /weather 目录下了。配置好后我们实验一下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102106.jpg" alt="image-20190408145225734"></p><p>恩，页面终于正常打开了。但对 wxpage 做相同的配置：即 open.xingshulin.com/wxpage 代理到 wxpage.xingshulin.com 之后。我们再次请求，发现所有资源文件都返回200，内容也正常返回，但是页面并没有渲染出来：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102107.jpg" alt="image-20190402142414525"></p><p>这又是什么原因呢？思考之后，我们想到应该是前端路由的问题，因为服务已经返回了全部的资源，除了ajax请求，和后端的交互应该到此为止了。接下来我们看一下前端路由出了什么问题。</p><h3 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h3><p>如果是后端路由，那么以上的配置应该是没有问题的，以上两个 location 已经保证我们所有请求都可以正确导向：</p><ul><li><p>访问 open.xingshulin.com/wxpage/xxx 页面，请求打到 wxpage.xingshulin.com/xxx</p></li><li><p>页面上的资源请求，根据 referer 判断应该去哪个服务请求，从而代理到正确的资源地址</p></li></ul><p>但这次要配置的两个服务都是SPA，前端路由，也就是说到了前端才判断路由或者说路由交给了前端，服务返回页面和资源文件后就不再处理路由的问题了，而增加一级目录后，访问的路径变成了：/wxpage/az，旧的前端路由列表只有 <code>/az</code>，并没有 <code>/wxpage/az</code>，所以出现了无法匹配的问题（如果前端路由写了404，就跳到404了）。</p><p>所以即使不挪动资源文件，但是写了前端路由的话，也是要对路由进行一定的修改，我们的项目目前的路由使用 <a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue-route</a> 的 <a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">History</a> 模式，配置如下（部分）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">  path: <span class="string">'/az'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: <span class="string">'/az/form-list'</span>,</span><br><span class="line">  name: <span class="string">'FormList'</span>,</span><br><span class="line">  component: FormList,</span><br><span class="line">&#125;]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>现在我们在前端进行<a href="https://learn-vue.gitbook.io/vue-router/redirect-and-alias" target="_blank" rel="noopener">重定向</a>，做如下修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wxpageRoutes = routes.map(<span class="function"><span class="params">route</span> =&gt;</span> (&#123;</span><br><span class="line">  ...route,</span><br><span class="line">  path: <span class="string">`/wxpage<span class="subst">$&#123;route.path&#125;</span>`</span>,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redirectRoutes = routes.map(<span class="function"><span class="params">route</span> =&gt;</span> (&#123;</span><br><span class="line">  path: route.path,</span><br><span class="line">  redirect: &#123;</span><br><span class="line">    name: route.name,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  routes: [</span><br><span class="line">    ...wxpageRoutes,</span><br><span class="line">    ...redirectRoutes,</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面配置的效果就是改成了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = [&#123;</span><br><span class="line">  path: <span class="string">'/wxpage/az'</span>,</span><br><span class="line">  name: <span class="string">'Home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: <span class="string">'/wxpage/az/form-list'</span>,</span><br><span class="line">  name: <span class="string">'FormList'</span>,</span><br><span class="line">  component: FormList,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: <span class="string">'/az'</span>,</span><br><span class="line">  redirect: &#123;<span class="attr">name</span>: <span class="string">"Home"</span>&#125;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">path: <span class="string">"/az/form-list"</span>,</span><br><span class="line">  redirect: &#123;<span class="attr">name</span>: <span class="string">"FormList"</span>&#125;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>也就是说访问：<code>/az/xxx</code> 重定向到 <code>/wxpage/az/xxx</code>，这样配置之后，可以兼容之前发出去的链接，结合前面的Nginx配置，我们就实现了使用一级目录对一个域名的代理。</p><p>但是配好后刷新时候还是有点问题，其实刷新问题是 history 模式固有的问题（可以看<a href="https://segmentfault.com/a/1190000007890379" target="_blank" rel="noopener">这里</a>了解更多）。这次我们修改路由后，也要对</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这次配置涉及到了对Nginx和前端路由的配置，两个配合最终实现了我们一开始的需求：合并两个域名到一个域名的一级目录下。配置过程中在调试Nginx时发现了<a href="https://github.com/openresty/echo-nginx-module" target="_blank" rel="noopener">echo模块</a>，是在nginx程序上扩展了echo输出字符的功能，对于调试很方便。如果觉得安装模块很麻烦，再分享一个调试Nginx配置的<a href="https://serverfault.com/questions/404626/how-to-output-variable-in-nginx-log-for-debugging" target="_blank" rel="noopener">小技巧</a>。</p><p>如果只是前端同学可能看起来有点困难，但还是建议掌握一下反向代理这个技能，毕竟现在都讲全栈开发，即便是纯前端，不懂http也只能做切图仔了。</p>]]></content>
      
      
      <categories>
          
          <category> Nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 代理 </tag>
            
            <tag> 路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rx学习—理解Observable（2）</title>
      <link href="/posts/25f4/"/>
      <url>/posts/25f4/</url>
      
        <content type="html"><![CDATA[<p>上次我们把 Observable 和函数进行类比，从函数的角度分析了 Observable 的一些特性，这次我们换一个角度，从流的角度理解 Observable。</p><a id="more"></a><h2 id="从事件机制说起"><a href="#从事件机制说起" class="headerlink" title="从事件机制说起"></a>从事件机制说起</h2><h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>在浏览器中，事件机制是用户交互的基础，本质是程序各个组成部分之间的一种通信方式（或者叫观察者模式）。当事件源被触发，会调用相应的事件处理函数执行，并把事件对象（Event 对象，持有事件源的一些信息）传递给事件处理函数。没有Rx之前，事件一般是互相独立，各自调用的。</p><h3 id="增加时间的维度"><a href="#增加时间的维度" class="headerlink" title="增加时间的维度"></a>增加时间的维度</h3><p>现在我们增加一个时间维度，在时间坐标上把同一个按钮上的单个事件点连成一条线：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101958.jpg" alt="image-20190329105443416"></p><p>有了时间维度，这条线看起来会是流动的，所以把他叫做一个流，接下来我们具体了解一下关于流的概念。</p><h2 id="流stream"><a href="#流stream" class="headerlink" title="流stream"></a>流stream</h2><h3 id="创建数据流"><a href="#创建数据流" class="headerlink" title="创建数据流"></a>创建数据流</h3><p>RxJS提供了各种API来创建数据流，我们先使用 create 进行自定义创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br></pre></td></tr></table></figure><p>可以看到我们创建了一个定时器定时触发，并在定时器中定时回调 observer，吐出一个返回值，相当于我们通过迭代器模拟了一个定时发生的点击事件（事件源），返回值相当于 Event（事件对象），而 observer 则相当于 EventListener（事件处理的监听器），单个事件串联起来就形成了流。</p><p>还记得我们上次提到的生产者和消费者的概念吗？上例中，迭代器作为生产者不断生成数据形成流，observer 作为消费者等待回调，虽然 Observable 本质上还是一个函数，但是从形式上来看，Observable 就像一个管道对接了生产者和消费者。</p><h3 id="数据的管道"><a href="#数据的管道" class="headerlink" title="数据的管道"></a>数据的管道</h3><blockquote><p>数据流这个词，很多时候，是从data-flow翻译过来的，但flow跟stream是不一样的，我的理解是：flow只关注一个大致方向，而stream是受到更严格约束的，它更像是在无形的管道里面流动。</p></blockquote><p>而 Observable 就是限制 stream 流动的无形管道中的一种。，从整个过程来看， <strong>Observable 对接了生产者和消费者，也就是作为管道对接了流</strong>，从生产者角度来说，Observable 是使得数据流可以被观测的一种特殊函数，于是有了一个新的名字：可观测对象，而从消费者的角度来说，它就是流的代表，可以直接被叫做流。</p><h2 id="Everything-is-a-stream"><a href="#Everything-is-a-stream" class="headerlink" title="Everything is a stream"></a>Everything is a stream</h2><p>不只是 Events，我们可以把一切输入都当做数据流来处理，比如说：</p><ul><li>用户操作</li><li>网络响应</li><li>定时器</li><li>Worker</li></ul><h3 id="产生新流"><a href="#产生新流" class="headerlink" title="产生新流"></a>产生新流</h3><p>当产生了一个流后，我们可以通过操作符（Operator）对这个流进行一系列加工操作，然后产生一个新的流：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Rx.Observable.fromEvent(<span class="built_in">window</span>, <span class="string">'click'</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">e</span> =&gt;</span> <span class="number">1</span>)</span><br><span class="line">  .scan(<span class="function">(<span class="params">total, now</span>) =&gt;</span> total + now)</span><br><span class="line">  .subscribe(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p><code>map</code> 把流转换成了一个每次产生1的新流，然后 <code>scan</code> 类似 <code>reduce</code>，也会产生一个新流，最后这个流被订阅。最终实现了每次点击累加1的效果。</p><p>可以用一个效果图来表示该过程：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102000.gif" alt="img"></p><h3 id="lodash-for-stream"><a href="#lodash-for-stream" class="headerlink" title="lodash for stream"></a>lodash for stream</h3><blockquote><p>这时候回头看，其实RxJS在事件处理的路上已经走得太远了，从事件到流，它被称为lodash for events，倒不如说是lodash for stream更贴切，它提供的这些操作符也确实可以跟lodash媲美。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在两篇文章中，我们分别从函数和流的角度了解了 Observable。本质上讲，Observable 是一种特殊的函数， 同时也是 RxJS 的一个核心类型，可以收集单个事件形成流来统一处理。</p><p>我觉得复杂的东西都有多种特性，就像光的波粒二象性一样，我们学习时不要拘泥于某种特性去归类，因为其可能具有不同事物的多种特性，需要我们从不同角度来描述和理解。</p><p>最后再分享一篇文章，希望能帮助更好的理解Observable：<a href="https://zhuanlan.zhihu.com/p/27776484" target="_blank" rel="noopener">如何从头开始创建 Observable</a>。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/25383159" target="_blank" rel="noopener">RxJS 入门指引和初步应用</a></p><p><a href="https://zhuanlan.zhihu.com/p/34357403" target="_blank" rel="noopener">RxJS基础教程</a></p>]]></content>
      
      
      <categories>
          
          <category> RxJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJs </tag>
            
            <tag> observable </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rx学习—理解Observable（1）</title>
      <link href="/posts/61f4/"/>
      <url>/posts/61f4/</url>
      
        <content type="html"><![CDATA[<p>RxJS（以下简称Rx）是使用 Observables 进行反应式编程的库，让组织异步和基于回调的代码更为方便。我们先从最核心的 Observable 来了解Rx，并且尝试以我们已有的知识—<strong>函数</strong>为基础来类比，帮助理解 Observable。</p><a id="more"></a><h2 id="Observable-一种特殊的函数"><a href="#Observable-一种特殊的函数" class="headerlink" title="Observable 一种特殊的函数"></a>Observable 一种特殊的函数</h2><p>我们首先选择了函数作为类比对象，尝试从不同角度分析Observable的特性。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>我们先看一个最普通的函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// foo...</span></span><br></pre></td></tr></table></figure><p>我们声明了函数 <code>foo()</code>，在里面封装了一段很简单的逻辑，然后调用函数，执行函数内部封装的逻辑。</p><p>然后我们来看使用 Observable 是怎样实现的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe()</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// foo...</span></span><br></pre></td></tr></table></figure><p>上面的例子中，通过 <code>Rx.Observable.create()</code> 来创建 Observable 对象，将同样将一段代码逻辑封装到 Observable 对象 <code>foo</code> 中，然后通过 <code>foo.subscribe()</code> 来执行封装的代码逻辑。</p><p>对于普通函数和 Observable 对象，封装的代码逻辑在每次调用时都会重新执行一次。从这一点看，<strong>Observable 能够和普通函数一样实现封装代码进行复用</strong>。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>普通函数调用后可以有返回值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="number">42</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo())</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// foo...</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Observable 执行后也会产生值，不过和函数直接返回的方式不同，要<strong>通过回调函数方式获取</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">  observer.next(<span class="number">42</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// foo...</span></span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>Observable 对象是通过在内部调用 <code>observer.next(42)</code> 这种方式返回值，而调用方则通过回调函数来接收返回的数据。形式上比普通函数直接返回值麻烦一些。</p><p>从调用方的角度来看，两个过程分别是：</p><ul><li>普通函数：<strong>调用</strong> &gt; 执行逻辑 &gt; 返回数据</li><li>Observable：<strong>订阅（subscribe）</strong> &gt; 执行逻辑 &gt; 返回数据</li></ul><p>从获取返回值方式来看，调用函数是一种直接获取数据的模式，从<strong>函数那里“拿”（pull）数据</strong>；而 Observable 订阅后，是要由 Observable 通过间接调用回调函数的方式，将数据<strong>“推”（push）给调用方</strong>。</p><p>这里 pull 和 push 的重要区别在于，push 模式下，Observable 可以决定什么时候返回值，以及返回几个值（即调用回调函数的次数）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">  observer.next(<span class="number">1</span>)</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(<span class="number">2</span>), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">foo.subscribe(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(value))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line"><span class="comment">// foo...</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>上面例子中，Observable 返回了两个值，第1个值同步返回，第2个值则是过了1秒后异步返回。</p><p>也就是说，从返回值来说，Observable 相比普通函数区别在于：</p><ul><li>可以返回多个值</li><li>可以异步返回值</li></ul><p>tip：如果你对ES6有所了解，应该知道 Promise 对象也可以实现异步返回值，那么 Promise 和 Observable 的区别有哪些？可以思考一下。</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>函数执行可能出现异常情况，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'BUG!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以在函数调用的地方捕获到异常状态进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   foo()</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'error: '</span> + e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 Observable，也有错误处理的机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo...'</span>)</span><br><span class="line">  observer.error(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'BUG!'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe(</span><br><span class="line">  value =&gt; <span class="built_in">console</span>.log(value),</span><br><span class="line">  e =&gt; <span class="built_in">console</span>.log(<span class="string">'error: '</span> + e)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>Observable 的 <a href="https://cn.rx.js.org/class/es6/Observable.js~Observable.html#instance-method-subscribe" target="_blank" rel="noopener"><code>subscribe()</code></a> 方法支持传入额外的回调函数，用于处理异常情况。<strong>和函数执行类似，出现错误之后，Observable 就不再继续返回数据了。</strong></p><p><code>subscribe()</code> 方法还支持另一种形式传入回调函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.subscribe(&#123;</span><br><span class="line">  next(value) &#123; <span class="built_in">console</span>.log(value) &#125;,</span><br><span class="line">  error(e) &#123; <span class="built_in">console</span>.log(<span class="string">'error: '</span> + e) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种形式下，传入的对象和 Observable 内部执行函数中的 observer 参数在形式上就比较一致了。</p><h3 id="中止执行"><a href="#中止执行" class="headerlink" title="中止执行"></a>中止执行</h3><p>Observable 内部的逻辑可以异步多个返回值，甚至返回无数个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.subscribe(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>上面例子中，Observable 对象每隔 1 秒会返回一个值给调用方，这时如果不退出程序，就会一直返回下去。</p><p>Rx 提供了中止 Observable 执行的机制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'start'</span>)</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    clearInterval(timer)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subscription = foo.subscribe(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> subscription.unsubscribe(), <span class="number">2500</span>)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// start</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure><p><code>subscribe()</code> 方法返回一个订阅对象 subscription，该对象上的 <code>unsubscribe()</code> 方法用于取消订阅，也就是中止 Observable 内部逻辑的执行，停止返回新的数据。</p><p>对于具体的 Observable 对象是如何中止执行，则要由 Observable 在执行后返回一个用于中止执行的函数，像上面例子中的这种方式。</p><p>Observable 执行结束后，会触发观察者的 complete 回调：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.subscribe(&#123;</span><br><span class="line">  next(value) &#123; <span class="built_in">console</span>.log(value) &#125;,</span><br><span class="line">  complete() &#123; <span class="built_in">console</span>.log(<span class="string">'completed'</span>) &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Observable 的观察者共有上面三种回调：</p><ul><li>next：获得数据</li><li>error：处理异常</li><li>complete：执行结束</li></ul><p>其中 next 可以被多次调用，error 和 complete 最多只有一个被调用一次（任意一个被调用后不再触发其他回调）。</p><h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><p>对于函数返回值，有时候我们要转换后再使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f00() * <span class="number">2</span>)</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>对于 Observable 返回的值，也会有类似的情况，通常采用以下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = Rx.Observable.create(<span class="function">(<span class="params">observer</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> observer.next(i++), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">foo.map(<span class="function"><span class="params">i</span> =&gt;</span> i * <span class="number">2</span>).subscribe(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>其实<code>foo.map()</code>返回了新的 Observable 对象，上面代码等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo2 = foo.map(<span class="function"><span class="params">i</span> =&gt;</span> i * <span class="number">2</span>)</span><br><span class="line">foo2.subscribe(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br></pre></td></tr></table></figure><p>Observable 对象 foo2 被订阅时执行的内部逻辑可以简单视为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">observer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> mapFn = <span class="function"><span class="params">v</span> =&gt;</span> v * <span class="number">2</span></span><br><span class="line">  foo.subscribe(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    observer.next(mapFn(v))</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这种对数据的处理和数组进行比较看看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">array.map(<span class="function"><span class="params">i</span> =&gt;</span> i * <span class="number">2</span>).forEach(<span class="function"><span class="params">i</span> =&gt;</span> <span class="built_in">console</span>.log(i))</span><br></pre></td></tr></table></figure><p>除了 map() 方法，Observable 还提供了多种转换方法，如 filter() 用于过滤数据，find() 值返回第一个满足条件的数据，reduce() 对数据进行累积处理，在执行结束后返回最终的数据。这些方法和数组方法功能是类似的，只不过是对 Observable 对象返回值的处理。还有一些转换方法更加强大，例如可以 debounceTime() 可以在时间维度上对数据进行拦截等等。</p><p>Observable 的转换方法，本质是创建了一个新的 Observable，新的 Observable 基于一定的逻辑对原 Observable 的返回值进行转换处理，然后再推送给观察者。</p><h2 id="数据通信机制"><a href="#数据通信机制" class="headerlink" title="数据通信机制"></a>数据通信机制</h2><p>接下来我们深入讨论一下<strong>返回值</strong>的问题，我们把 Observable 类比函数主要都有<strong>处理数据并返回值</strong>的特性，而处理数据的返回值方式可以分为<strong>拉取</strong>和<strong>推送</strong>两种，与其对应的数据处理对象即为<strong>消费者</strong>和<strong>生产者</strong>。</p><p>拉取很简单，就是一种消费者主动索取所需数据的方式，生产者只有当消费者发出需求信号时才会提供数据。函数调用就是一种简单的拉取实例，<strong>消费者主动调用</strong>。</p><p>推送则是由生产者决定何时向消费者传送数据，<strong>消费者无法自己单独决定获取数据的时机，被动接受</strong>。Js中的<a href="http://blog.xieliqun.com/2016/08/12/event-delegate/" target="_blank" rel="noopener">事件监听</a>和 Promise（还包括回调函数）就是很典型的数据推送系统（或者叫观察者模式/Observer Pattern，回调可以看做只有一个观察者的观察者模式），而 Observable 就是一种更为强大的数据推送系统（ Promise ++）。</p><p>以下为几类常见的拉取和推送模型：</p><ul><li>Function: 单次拉取模型，调用时会同步的返回单一值</li><li>Generator/Iterator: 多次拉取模型，调用时会同步的返回0到无限多个值</li><li>Promise: 单次推送模型，由生产者决定时机返回单一值</li><li>Observable: 多次推送模型，由生产者决定时机返回0到无限多个值 </li></ul><p>如果把函数理解为处理数据并返回值，那么以上这些可以都理解为函数的变种，现在我们可以回答一下<a href="#返回值">返回值</a>最后关于 Promise 和 Observable 区别的问题：</p><blockquote><p>Promise 可以算作一个 Observable，那么 Observable 其实就是 Promise++ 。在 Rx 中，你可以很简单地把一个 Promise 转换成一个 Observable，只需要：var stream = Rx.Observable.fromPromise(promise) ，接下来我们会使用他。Observable 和 Promise++ 的唯一区别是前者不兼容 Promise/A+ ，但是理论上来讲是没有冲突的。Promise 其实就是只有单独一个值 的 Observable ，但后者更胜一筹的是允许多个返回值（多次 emit）。</p><p><strong>这其实是一件很棒的事情，Promise 能做的事情，Observable 也能做。Promise 不能做的事情，Observable 还是能做</strong>。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们从函数的角度总结了 Observable 的一些特性，我们把 Observable 看做一个特殊的函数，它有和函数类似的东西，例如封装了一段逻辑，每次调用时都会重新执行逻辑，执行有返回数据等；也有更特殊的，例如数据是推送（push）的方式返回给调用方法，返回值可以是异步，并且可以返回多个值等。</p><p>下次我们会尝试从流的角度分析 Observable。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.jianshu.com/p/b05aa5d152c8" target="_blank" rel="noopener">RxJS Observable - 一个奇特的函数</a></p><p><a href="https://zhuanlan.zhihu.com/p/38133091" target="_blank" rel="noopener">RxJS核心解析——Observable</a></p><p><a href="https://zhuanlan.zhihu.com/p/25552305" target="_blank" rel="noopener">可能是最好的 Rx 初学者教程</a></p>]]></content>
      
      
      <categories>
          
          <category> RxJs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RxJs </tag>
            
            <tag> observable </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何学习和实践ES201X</title>
      <link href="/posts/b2fd/"/>
      <url>/posts/b2fd/</url>
      
        <content type="html"><![CDATA[<p>自从ES2015（ES6）开始，JavaScript标准每年都会出一个新版本，最近发布的即为ES2019。那么，为什么每年</p><p>都有新标准？如何学习每年的新标准？如何在实践中采用新特性？</p><h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><h3 id="什么是ECMAScript"><a href="#什么是ECMAScript" class="headerlink" title="什么是ECMAScript"></a>什么是ECMAScript</h3><p><a href="https://zhuanlan.zhihu.com/p/22557749" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22557749</a></p><h3 id="数字版本号和年份版本号"><a href="#数字版本号和年份版本号" class="headerlink" title="数字版本号和年份版本号"></a>数字版本号和年份版本号</h3><p><a href="https://www.zhihu.com/question/61698736/answer/593286532" target="_blank" rel="noopener">https://www.zhihu.com/question/61698736/answer/593286532</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> — ES2019 — ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用logrotate进行日志管理</title>
      <link href="/posts/8e89/"/>
      <url>/posts/8e89/</url>
      
        <content type="html"><![CDATA[<p>广告服务一直有log文件增长过快的问题，之前写了一个crontab都是线上手动清空一下旧日志，</p>]]></content>
      
      
      
        <tags>
            
            <tag> logrotate </tag>
            
            <tag> 服务 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈session管理</title>
      <link href="/posts/3be7/"/>
      <url>/posts/3be7/</url>
      
        <content type="html"><![CDATA[<p>商业后台和dr后台都用到了session机制，简单总结一下session的管理。</p><a id="more"></a><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>互联网公司提供的服务基本都是基于HTTP协议的，由于<a href="https://www.zhihu.com/question/23202402/answer/527748675" target="_blank" rel="noopener">HTTP协议是无状态的协议</a>，但我们提供的服务很多时候是需要有状态的，并且需要维护每个用户的状态，即创建和维护多组独立的状态，这就需要用某种机制来识具体的用户，这个机制就是Session，而实现Session机制很多时候会用到Cookie，接下来我们说一下Cookie。</p><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>网络早期最大的问题之一是如何管理状态。简而言之，服务器无法知道两个请求是否来自同一个浏览器。当时最简单的方法是在请求时，在页面中插入一些参数，并在下一个请求中传回参数。这需要使用包含参数的隐藏的表单，或者作为URL参数的一部分传递。这两个解决方案都手动操作，容易出错。网景公司当时一名员工Lou Montulli，在1994年将“cookies”的概念应用于网络通信，用来存储用户网上购物的购物车历史记录，目前所有浏览器都支持cookies。</p><p>Cookie本质上是一种客户端存储，多用来标记用户和记录客户端状态，翻译过来是“饼干，甜品”的意思，Cookie在网络应用中到处存在，当我们浏览之前访问过的网站，网页中可能会显示：你好，xxx，这就会让我们感觉很亲切，像吃了一块很甜的饼干一样。利用Cookie我们可以实现一些新功能，比如用户登录过的账号可以存在Cookie里，用户下次登录时候可以直接帮助用户填写到表单中，方便用户使用，再比如上面提到的存储网上购物车的历史记录。</p><p>就Cookie本身而言，只是一个往返服务器和客户端之间的信息载体，不一定和Session有必然联系，但是我们实现Session机制经常使用到Cookie。接下来我们看一下Session机制的实现。</p><p>tips：</p><p><a href="https://juejin.im/entry/5a29fffa51882531ba10da1c" target="_blank" rel="noopener">这一次带你彻底了解Cookie</a></p><p><a href="https://zhuanlan.zhihu.com/p/29884606" target="_blank" rel="noopener">清除Cookie？告诉你什么叫Cookie</a></p><h2 id="Cookie-Session机制"><a href="#Cookie-Session机制" class="headerlink" title="Cookie-Session机制"></a>Cookie-Session机制</h2>]]></content>
      
      
      
        <tags>
            
            <tag> session </tag>
            
            <tag> session-cookie </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近遇到的两个bug总结</title>
      <link href="/posts/289d/"/>
      <url>/posts/289d/</url>
      
        <content type="html"><![CDATA[<p>qa打包结果和线上不同</p><p>vue和vue-template-compiler更新或者不同</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs包与模块机制</title>
      <link href="/posts/7a8a/"/>
      <url>/posts/7a8a/</url>
      
        <content type="html"><![CDATA[<h2 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h2><p>NodeJs 以 JavaScript（ECMAScript） 为基础，但在 ES6 之前，JavaScript自身是不带有模块机制的，所以社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。</p><p>2009 ~ 2010 年间，CommonJS 社区大牛云集，稍微了解点历史的同学都清楚，在同时间出现了 NodeJs，一下子让 javaScript 摇身一变，有了新的用武之地，同时在 NodeJs 推动下的 CommonJS 模块系统也是逐渐深入人心。</p><p>使用 CommonJs 规范必须遵守的三个主要约定：</p><ol><li><p>require</p><p>一个函数，参数</p></li><li><p>模块上下文</p><p>require函数</p><p>exports对象</p><p>module对象</p></li></ol><p>exports 和 module.exports 的区别</p><p><a href="https://cnodejs.org/topic/5231a630101e574521e45ef8" target="_blank" rel="noopener">https://cnodejs.org/topic/5231a630101e574521e45ef8</a></p><ol start="3"><li><p>模块标志</p><p>通俗来说就是模块名，官方定义：<a href="http://wiki.commonjs.org/wiki/Modules/1.1.1#Module_Identifiers" target="_blank" rel="noopener">Module_Identifiers</a>。</p></li></ol><p>不必要遵循的约定（实现与否都可以）：</p><ol><li><p>存储方案：一个模块的内容可以存在数据库里，也可以存在文件系统里，还有动态/静态链接库，甚至于函数里（对于 NodeJs 来说就是文件系统，所有模块都放在 node_modules 目录下，当然还有一些 C++ 的模块存在动态链接库中）；</p></li><li><p>加载器：可以支持环境变量（path）寻径（也可以不实现）</p></li></ol><p>总之，NodeJs 应用通过入口文件之后，里面其实是由一个一个模块组成，通常一个模块就是一个遵循 CommonJs 规范书写的 JavaScript 源文件，当然也可能是后缀为 .node 的 C++ 的模块，二进制文件。这些文件通过 require 函数引入后，就可以在程序里使用了，使用 CommonJs 规范作为 NodeJs 的模块导入导出机制，就相当于把每个JavaScript文件或者说模块当做一个不会污染全局的闭包（只要不使用 global）。</p><ul><li><p>CommonJs 模块规范</p></li><li><p>CommonJs 包规范</p><p>包描述文件：package.json，但和 NodeJs 的有些不同。</p><p>​    必填、选填、保留字段</p><p>包的格式：一个包含整个包目录（尤其是包含 package.json 文件）的zip格式的归档，首先要有一个 package.json 在根目录，二进制文件存在于名为 bin 的子目录下，JavaScript源码在lib目录下，文档在 doc 文目录下，单元测试文件在 test 目录下，这是一个遵循 CommonJs 规范的包（即使没有遵循规范，只要 package.json 是合法的也是可以用的）</p><p>而 NodeJs 的包以目录的形式存在于node_modules，在安装之前（未解压前）通常是一个 tar.gz 格式的包。</p></li><li><p>Node.js 模块规范</p></li><li><p>Node.js 包规范</p><p>Npm 全称 Node Package Manager，刚开始是node的包管理器，后来发展成整个JavaScript的包管理器</p><p>Npm2.x 嵌套式依赖，可以非常优雅的实现某个依赖在项目中多版本共存的情况。对于后端开发及工具类开发的 NodeJs 应用来说，嵌套式依赖其实更适合。</p><p>Npm3.x、4.x扁平化依赖方案，适合前端，需要考虑代码体积。</p></li></ul><ul><li>Node.js 四种模块本质和加载原理</li><li>Node.js 入口模块</li></ul><h3 id="模块寻径"><a href="#模块寻径" class="headerlink" title="模块寻径"></a>模块寻径</h3><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/lives/842742839304667136" target="_blank" rel="noopener">深入了解 Node.js 包与模块机制</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 包管理 </tag>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正确使用Babel（1）后端</title>
      <link href="/posts/3b3f/"/>
      <url>/posts/3b3f/</url>
      
        <content type="html"><![CDATA[<p>前面说了那么多，现在让我们来实践一下怎样是正确的babel使用方式，当然也不一定绝对正确，肯定还有些不足的地方，如果你看到了欢迎补充。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102016.jpg" alt="âbabel 7âçå¾çæç´¢ç&quot;æ"></p><a id="more"></a><p>我按照项目使用的目标环境分为了后端/library，前端/library，前后端都有的项目，这次我们先说后端/library。</p><h2 id="后端项目"><a href="#后端项目" class="headerlink" title="后端项目"></a>后端项目</h2><p>刚写了一个纯后端服务，先从后端说起，该服务依赖如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "start": "nodemon ./src/index.js",</span><br><span class="line">  "build": "babel src -d dist -D -s true"</span><br><span class="line">&#125;,</span><br><span class="line">"dependencies": &#123;</span><br><span class="line">  "knex": "^0.15.2",</span><br><span class="line">  "koa": "^2.6.2",</span><br><span class="line">  "koa-bodyparser": "^4.2.1",</span><br><span class="line">  "koa-router": "^7.4.0",</span><br><span class="line">  "mysql2": "^1.6.4",</span><br><span class="line">  "superagent": "^4.0.0",</span><br><span class="line">  "uuid": "^3.3.2"</span><br><span class="line">&#125;,</span><br><span class="line">"devDependencies": &#123;</span><br><span class="line">  "@babel/cli": "^7.1.5",</span><br><span class="line">  "@babel/core": "^7.1.6",</span><br><span class="line">  "@babel/preset-env": "^7.1.6",</span><br><span class="line">  "@babel/register": "^7.0.0",</span><br><span class="line">  "babel-plugin-module-resolver": "^3.1.1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，所有的babel包全在<code>devDependencies</code>下，因为线上我们运行的是build之后的代码，我们简述一下每个包的作用：</p><ul><li>@babel/cli：命令行运行babel，为了build（构建）</li><li>@babel/core：各种包的Peer Dependencies ，在7版本下几乎是一个必装的包</li><li>@babel/preset-env：preset选env，没毛病</li><li>@babel/register：开发环境使用，实时编译</li><li>babel-plugin-module-resolver：唯一单独装的plugin，目的是设置常用包的别名（非必须）</li></ul><p>再看下babel.config.js的配置（只看presets）：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="string">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,<span class="comment">// 使用preset-env</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"targets"</span>: &#123;</span><br><span class="line">          <span class="string">"node"</span>: <span class="string">"current"</span>,<span class="comment">// 目标版本</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"useBuiltIns"</span>: <span class="string">"usage"</span>,<span class="comment">// 是否polyfill</span></span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"comments"</span>: <span class="literal">false</span><span class="comment">// 去掉注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>node版本配置为current，这个后端项目我使用的是最新的LTS——v10.13.0，编译后发现代码差的不多，没有面目全非，主要是因为node版本高，所以不支持的语法已经不多。然后我把node目标版本换成8，发现没什么区别，直到我换成6，出现了<code>_asyncToGenerator</code>，说明在6版本，node还不支持<code>async/await</code>的语法糖，但是我启动项目发现可以运行，最后，我把target的node选项置为空，直接使用default的配置，这次终于运行不起来了。错误如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: regeneratorRuntime is not defined</span><br></pre></td></tr></table></figure><p>可以看到是缺少regeneratorRuntime，要增加这个方法只能上<code>polyfill</code>了，参考我们上期写的，我们有三个选择，<code>@babel/runtime</code>、<code>@babel/runtime-corejs2</code>或者<code>@babel/polyfill</code>，任选其一即可，先试了一下<code>@babel/polyfill</code>，<code>useBuiltIns</code>选项配置成<code>entry</code>，终于运行没问题了（折腾完后在<code>targets</code> 为node 10/8环境运行正常，切换到node 6版本运行，发现<code>koa-bodyparser</code>这个包报错，查看源码，里面用了<code>async function</code>，而<code>node_modules</code>里的文件并没有转换，意味着这个包最低要求node 8版本了，实际上我们已经用10了，我们切换低版本只是为了检验<code>babel</code>中各个包的作用）。发现<code>require</code>了比较多的包进来，根据我们上次的总结，设置成<code>entry</code>会将<code>polyfills</code>拆分引入，仅引入不支持的<code>polyfill</code>，虽然相比不做任何处理已经有所优化，但这仍然不是我想要的，其实上次我们说过该配置还有一个选项是<code>usage</code>，可以做到检测代码中<code>ES6/7/8</code>等的使用情况，仅仅加载代码中用到的<code>polyfills</code>，这才是我们想要的，用上之后可以减少很大的代码量。我们可以看到配置了<code>useBuiltIns: usage</code>之后，真的实现了按需引用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">"core-js/modules/es6.promise"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">"regenerator-runtime/runtime"</span>);</span><br></pre></td></tr></table></figure><p>这时看到一条提示：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102017.jpg" alt="image-20190304101357553"></p><p>说明使用了<code>useBuiltins: usage</code>已经不需要使用<code>import &#39;@babel/polyfill</code>了，删除这句引入后我又在想，是否可以干脆干掉<code>@babel/polyfill</code>这个包呢，我们上次说过这个包现在包括<code>corejs</code>和<code>regenerator</code>，而<code>@babel/register</code>带了<code>core-js</code>，那么还差<code>regenerator-runtime</code>，而升级到node10之后我们已经不需要<code>regenerator-runtime</code>，所以我觉得完全可以不再使用<code>@babel/polyfill</code>，而是直接使用 <code>present-env</code> 的<code>useBuiltIns: usage</code>进行按需加载。</p><p>接下来我又尝试了更换<code>@babel/runtime</code>进行<code>polyfill</code>，<code>@babel/plugin-transform-runtime</code>负责转换语法，<code>@babel/runtime</code>/<code>@babel/runtime-corejs2</code>负责提供<code>polyfill</code>，<code>core-js</code>和<code>regenerator-runtime</code>的引入是日常操作，对比<code>@babel/polyfill</code>，我们发现多了<code>helper</code>，<code>helper</code>可以帮助我们减少重复定义。（同时我观察到，既有<code>polyfill（useBuiltIns）</code>，又有<code>@babel/plugin-transform-runtime</code> 的情况下，填充<code>built-ins</code>和<code>rgenerator</code>还是按照不污染全局的方式来的，而如果使用了实例的方法，结果还是污染了全局的变量，这部分对打包lib的转换影响大一些，这里不细说了，可以看下面lib的配置）</p><p>针对使用<code>useBuiltIns</code>没有<code>helper</code>的问题，我们可以使用<code>@babel/plugin-external-helpers</code>进行<a href="https://babel.bootcss.com/docs/plugins/external-helpers/" target="_blank" rel="noopener">优化</a>：</p><ol><li>安装 plugin，执行 babel-external-helpers 生成 helpers.js 文件，</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-plugin-external-helpers</span><br><span class="line"></span><br><span class="line">node_modules/.bin/babel-external-helpers &gt; helpers.js</span><br></pre></td></tr></table></figure><ol start="2"><li>然后在 babel 的配置文件加入</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"external-helpers"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>入口文件引入 helpers.js</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'./helpers.js'</span>);</span><br></pre></td></tr></table></figure><p>实际上为了处理运行时问题，<code>polyfill（useBuiltIns）</code>和<code>@babel/plugin-transform-runtime</code> 我们只需选一个，区别在于<code>polyfill</code>会污染全局，这在我们自己项目里使用时是没有问题的，但是设计到开发一个<code>library</code>时就会导致污染使用者的全局变量，所以我们在自己的项目里使用<code>polyfill（useBuiltIns: usage）</code>（如果使用了<code>@babel/register</code>，那么就有了<code>core-js</code>，并且node版本在6以上，不再需要<code>regenerator-runtime</code>，可以直接不再使用<code>@babel/polyfill</code>，针对没有<code>helper</code>的问题，我们可以使用<code>@babel/plugin-external-helpers</code>进行优化），开发<code>library</code>时使用<code>@babel/plugin-transform-runtime</code> 。</p><p>日常使用时，并没有必要折腾这么多，服务放docker里，上最新的LTS加适当的配置（配置参考上面，我觉得已经足够简洁）就够了，现在大部分语法已经不需要太多转换了，如果不是npm包项目，直接选择<code>present-env</code>按需加载<code>polyfill</code>就可以，污染全局变量的问题在除了开发npm包之外的地方并不存在，并且如果<code>corejs</code>由<code>@babel/register</code>提供的话，<code>@babel/polyfill</code>都不需要了。</p><h2 id="后端library"><a href="#后端library" class="headerlink" title="后端library"></a>后端library</h2><p>如果是library包，我们就要考虑全局变量污染的问题。因为如果你的包污染了使用者的全局变量的话，</p><p>babel-runtime：corejs2</p><p>babel-cli</p><h2 id="后端编译执行"><a href="#后端编译执行" class="headerlink" title="后端编译执行"></a>后端编译执行</h2><p>所谓后端编译执行就是在<strong>线上环境</strong>执行编译后的代码。</p><h3 id="如何进行"><a href="#如何进行" class="headerlink" title="如何进行"></a>如何进行</h3><p><a href="https://juejin.im/entry/59f3e429518825295f5d3058" target="_blank" rel="noopener">https://juejin.im/entry/59f3e429518825295f5d3058</a></p><h3 id="带来的好处"><a href="#带来的好处" class="headerlink" title="带来的好处"></a>带来的好处</h3><p><img src="https://images.leotian.cn/blog/2019-04-29-102018.jpg" alt="1*uFKLXuq6bqU-7rgnOFdLlg.png">如上图所说，babel实时编译产生的代码会缓存在内存中，导致内存占用过高。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 编译器 </tag>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>升级Babel到7版本</title>
      <link href="/posts/a5bd/"/>
      <url>/posts/a5bd/</url>
      
        <content type="html"><![CDATA[<p>8月底Babel官方宣布正式推出 Babel 7.0。这次 Babel 7 的发布，距离上次 Babel 6 的发布差不多过去了整整 3 年的时间。之前的两篇文章都是基于Babel 6，最近我们升级了Babel 7，总结一下变化。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101907.jpg" alt="âbabel 7âçå¾çæç´¢ç&quot;æ"><a id="more"></a></p><h1 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h1><p>这次更新号称断崖式变更，更新内容较多，我会挑选一些我注意到的重要变化，完整的列表可以参考<a href="https://babeljs.io/docs/en/v7-migration" target="_blank" rel="noopener">官网</a>，并且肯定还有很多东西需要动态调整，所以大家有什么觉得不对的地方建议去官网验证并且回来留言告诉我。</p><h2 id="Renames（命名变化）"><a href="#Renames（命名变化）" class="headerlink" title="Renames（命名变化）"></a>Renames（命名变化）</h2><h3 id="Scoped-Packages"><a href="#Scoped-Packages" class="headerlink" title="Scoped Packages"></a>Scoped Packages</h3><p>Babel 团队会从7版本开始通过使用 “scoped” packages 的方式，来给自己的 babel package name 加上 @babel 命名空间（<a href="http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#renames-scoped-packages-babel-x" target="_blank" rel="noopener">详情</a>），这样以便于区分官方 package 以及 非官方 package，所以 babel-core 会变成 @babel/core。至于选择scoped packages更多的好处可以看<a href="https://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#renames-scoped-packages-babel-x" target="_blank" rel="noopener">这里</a>。</p><h3 id="plugin统一使用proposal"><a href="#plugin统一使用proposal" class="headerlink" title="plugin统一使用proposal"></a>plugin统一使用proposal</h3><p>放弃 <code>Stage</code> presets（<code>@babel/preset-stage-0</code> 等），选择支持单个 proposal。相似的地方还有，会默认移除 <code>@babel/polyfill</code>对 proposals 支持（<a href="https://github.com/babel/babel/pull/8440" target="_blank" rel="noopener">详情</a>）。想知道更多相关的细节，可以考虑阅读整篇<a href="https://babeljs.io/blog/2018/07/27/removing-babels-stage-presets" target="_blank" rel="noopener">博文</a>。</p><p>所有 TC39 proposal plugin 的名字都已经变成以 <code>@babel/plugin-proposal</code> 开头，替换之前的 <code>@babel/plugin-transform</code>（<a href="http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#renames-proposal" target="_blank" rel="noopener">详情</a>）。有些 package 已经换名字，所以 <code>@babel/plugin-transform-class-properties</code> 变成 <code>@babel/plugin-proposal-class-properties</code>。</p><h3 id="Drop-the-year-from-the-plugin-name"><a href="#Drop-the-year-from-the-plugin-name" class="headerlink" title="Drop the year from the plugin name"></a>Drop the year from the plugin name</h3><p>如果插件名称中包含了规范名称 (<code>-es2015-</code>, <code>-es3-</code> 之类的)，一律删除。例如 <code>babel-plugin-transform-es2015-classes</code> 变成了 <code>@babel/plugin-transform-classes</code>。</p><h2 id="presets"><a href="#presets" class="headerlink" title="presets"></a>presets</h2><h3 id="弃用年份-presets"><a href="#弃用年份-presets" class="headerlink" title="弃用年份 presets"></a>弃用年份 presets</h3><p>弃用（并且停止发布）所有与 yearly 有关的 presets（<code>preset-es2015</code> 等）（<a href="http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#deprecated-yearly-presets-eg-babel-preset-es20xx" target="_blank" rel="noopener">详情</a>）。<code>@babel/preset-env</code> 会取代这些 <code>presets</code>，这是因为 <code>@babel/preset-env</code> 囊括了所有 yearly <code>presets</code> 的功能，而且<code>@babel/preset-env</code> 还具备了针对特定浏览器进行“因材施教”的能力，而不需要开发者投入精力。凡是使用 es201x 的开发者，都应当使用 env 进行替换。但这里的弃用（原文 deprecated）并不是删除，只是不推荐使用了（好像马上就准备删了）。</p><h3 id="弃用-stage-x"><a href="#弃用-stage-x" class="headerlink" title="弃用 stage-x"></a>弃用 stage-x</h3><p>如上面所说，stage-x 不再维护了。这是因为 babel 团队认为为这些 “不稳定的草案” 花费精力去更新 preset 相当浪费。stage-x 虽然停止维护（同样也是deprecated），但它包含的插件并没有删除（只是被更名了），我们依然可以显式地声明这些插件来获得等价的效果。<a href="https://github.com/babel/babel/tree/master/packages/babel-preset-stage-0#babelpreset-stage-0" target="_blank" rel="noopener">完整列表</a>。</p><h2 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h2><h3 id="拆分-babel-runtime"><a href="#拆分-babel-runtime" class="headerlink" title="拆分 babel-runtime"></a>拆分 <code>babel-runtime</code></h3><p><code>@babel/runtime</code> 是 babel 生态里最让人困惑的一个包，好像到处都有。而在 babel 7 下，我们还多了一个 <code>@babel/runtime-corejs2</code>。之前的 <code>@babel/runtime</code> 已经被分成 <code>@babel/runtime</code> 以及 <code>@babel/runtime-corejs2</code>（<a href="https://github.com/babel/babel/pull/8266" target="_blank" rel="noopener">PR</a>）。前者保留了 regenerator-runtime 函数和 helpers，后者保留了 polyfill 函数（例如，Symbol，Promise，其实就是拆出了core-js，运行时扩展包括的两个内容拆开了）、regenerator-runtime 函数和 helpers（目前看到是这样的）。corejs2的使用方法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"plugins": [</span><br><span class="line">    [<span class="string">"@babel/plugin-transform-runtime"</span>,&#123;<span class="attr">"corejs"</span>: <span class="number">2</span>&#125;]</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>所以现在使用<code>@babel/plugin-transform-runtime</code>搭配<code>@babel/runtime</code>的话其实只有 regenerator 的转换，填充是没有的，具体配置请看<a href="https://babeljs.io/docs/en/babel-plugin-transform-runtime#corejs" target="_blank" rel="noopener">这里</a>（设为true的话是从core-js作填充，所以必须要装core-js，不过装<code>@babel/register</code>的话会带core-js）。</p><h3 id="Remove-proposal-polyfills-in-babel-polyfill"><a href="#Remove-proposal-polyfills-in-babel-polyfill" class="headerlink" title="Remove proposal polyfills in @babel/polyfill"></a><a href="https://babel.docschina.org/docs/en/v7-migration#remove-proposal-polyfills-in-babel-polyfill-https-githubcom-babel-babel-issues-8416" target="_blank" rel="noopener">Remove proposal polyfills in <code>@babel/polyfill</code></a></h3><p>基于和废弃stage相似的思想，<code>@babel/polyfill</code>（ <a href="https://github.com/babel/babel/blob/master/packages/babel-polyfill/src/index.js" target="_blank" rel="noopener">Source</a>）中的 polyfill proposals也被删除。现在<code>@babel/polyfill</code> 几乎就是<code>@babel/runtime-corejs2</code>的一个别名，包含的内容只有<code>core-js</code>和<code>regenerator-runtime</code>（说几乎可能是因为<code>@babel/runtime-corejs2</code>多了helpers）。</p><h3 id="自动-polyfill（实验性质）"><a href="#自动-polyfill（实验性质）" class="headerlink" title="自动 polyfill（实验性质）"></a>自动 polyfill（实验性质）</h3><p>在环境不支持一些新特性如 Promise，Symbol，而你需要开启的情况下，就需要 Polyfills。能够区分得出 Babel 在作为编译器（转换语法）以及 作为 polyfill（实现内置的方法/对象）都做了哪些事情，这很重要。</p><p>之前我们只需要简单的引入一套完整的解决方案，比如 <code>@babel/polyfill</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"@babel/polyfill"</span>;</span><br></pre></td></tr></table></figure><p>但是 <code>@babel/polyfill</code> 会把整个 polyfill 都 import 进来（something that covers everything），而且如果浏览器已经支持一些特性，那么就没有必要把整个 polyfill 给 import 进来。<code>@babel/preset-env</code> 所解决的语法问题和 polyfill 所解决的问题，其实是同一个问题——兼容性，所以在这里会把 <code>@babel/preset-env</code> 应用在解决 polyfill 问题上。设置 useBuiltins: “entry” 可以解决整个 polyfill 被 import 的问题（根据<code>target</code>中浏览器版本的支持，将<code>polyfills</code>拆分引入，仅引入不支持的<code>polyfill</code>）。</p><p>但其实我们能做的更好，我们可以只 import 代码中用到的 polyfill，最好可以检测代码中<code>ES6/7/8</code>等的使用情况，仅仅加载代码中用到的<code>polyfills</code>。设置 useBuiltIns: “usage” 就可以开启类似的功能（<a href="https://babeljs.io/docs/en/babel-preset-env#usebuiltins" target="_blank" rel="noopener">文档</a>）。</p><p>tip：这到底是如何做到的呢？对于JS这种动态语言来说，只静态分析应该无法做到这一步，必须要加载执行后才可以，还需要经过大量测试，解析AST甚至是模拟引擎执行？</p><h2 id="JavaScript-配置文件"><a href="#JavaScript-配置文件" class="headerlink" title="JavaScript 配置文件"></a>JavaScript 配置文件</h2><h3 id="babel-config-js"><a href="#babel-config-js" class="headerlink" title="babel.config.js"></a>babel.config.js</h3><p>Babel 7 正在引入<a href="https://babeljs.io/docs/en/next/config-files#project-wide-configuration" target="_blank" rel="noopener"><code>babel.config.js</code></a>。注意：使用 <code>babel.config.js</code> 并不是一个必要条件；或者也可以这样说，<code>babel.config.js</code>甚至不是 <code>.babelrc</code> 的替代品，不过在一些特定的场景下，使用 <code>babel.config.js</code> 还是有帮助的。</p><p>用 <code>*.js</code> 来做配置文件的做法，在 JavaScript 的生态里面已经相当常见。ESlint 和 Webpack 都已经考虑到用 <code>.eslintrc.js</code> 以及 <code>webpack.config.js</code> 来做配置文件。</p><p>下面说的就是这个例子 —— 只会在“生产”环境中使用 <code>babel-plugin-that-is-cool</code> 插件来编译（当然，你也可以在 <code>.babelrc</code> 配置文件，通过配置 <code>env</code> 配置项的方式来做这件事）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> env = process.env.NODE_ENV;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    env === <span class="string">"production"</span> &amp;&amp; <span class="string">"babel-plugin-that-is-cool"</span></span><br><span class="line">  ].filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babelrc的查找行为"><a href="#babelrc的查找行为" class="headerlink" title=".babelrc的查找行为"></a>.babelrc的<a href="https://www.babeljs.cn/docs/usage/babelrc/#%E6%9F%A5%E6%89%BE%E8%A1%8C%E4%B8%BA" target="_blank" rel="noopener">查找行为</a></h3><p>Babel6会在正在被转录的文件的当前目录中查找一个 <code>.babelrc</code> 文件。 如果不存在，它会遍历目录树，直到找到一个 <code>.babelrc</code> 文件，或一个 <code>package.json</code> 文件中有 <code>&quot;babel&quot;: {}</code> 。比如使用babel-register，你可以使用<a href="https://babel.bootcss.com/docs/usage/babel-register/#%E6%8C%87%E5%AE%9A%E9%80%89%E9%A1%B9" target="_blank" rel="noopener">选项</a>，包括 <code>plugins</code> 和 <code>presets</code>等等，但是每个文件最接近的 <a href="https://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener"><code>.babelrc</code></a> 仍然适用，并且优先于你在此处传入的任何选项，如果不想查找只能在选项中使用 “babelrc”: false 来停止查找行为，或者提供–no-babelrc CLI 标志。</p><p>与 <code>.babelrc</code> 相比，针对查找配置文件的这件事，Babel 对 <code>babel.config.js</code> 有着不同的解决方案。Babel 总是会先从 <code>babel.config.js</code> 来获取配置内容。和 <code>.babelrc</code> 或 <code>package.json</code>中的 <code>babel</code> 字段不同，这个配置文件不会使用基于文件位置的方案，而是会一致地运用到项目根目录以下的所有文件，包括 <code>node_modules</code> 内部的依赖。</p><p>这样就可以利用发布的下一个功能，<code>overrides</code>。</p><h3 id="使用-overrides，实现配置有选择性的“表达”"><a href="#使用-overrides，实现配置有选择性的“表达”" class="headerlink" title="使用 overrides，实现配置有选择性的“表达”"></a>使用 <code>overrides</code>，实现配置有选择性的“表达”</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="comment">// defeault config...</span></span><br><span class="line">  ],</span><br><span class="line">  overrides: [&#123;</span><br><span class="line">    test: [<span class="string">"./node_modules"</span>],</span><br><span class="line">    presets: [</span><br><span class="line">      <span class="comment">// config for node_modules</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    test: [<span class="string">"./tests"</span>],</span><br><span class="line">    presets: [</span><br><span class="line">      <span class="comment">// config for tests</span></span><br><span class="line">    ],</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就实现在一个项目当中，可以针对测试代码、客户端代码以及服务端代码使用不同的编译配置（compilation configs），就很好的避免了需要你为每个文件夹都创建一个新的 .babelrc 配置文件的情况。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><h3 id="Peer-dependencies"><a href="#Peer-dependencies" class="headerlink" title="Peer dependencies"></a>Peer dependencies</h3><p>为所有的 plugins（例如<code>@babel/plugin-class-properties</code>），presets（<code>@babel/preset-env</code>），and 顶级包（<code>@babel/cli</code>、 <code>babel-loader</code>），都加上了 <code>@babel/core</code> 作为 <code>peerDependency</code>（<a href="http://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#peer-dependencies-integrations" target="_blank" rel="noopener">详情</a>）。</p><blockquote><p>peerDependencies are dependencies expected to be used by your code, as opposed to dependencies only used as an implementation detail — <a href="https://stackoverflow.com/a/34645112" target="_blank" rel="noopener">Stijn de Witt via StackOverflow</a></p></blockquote><p><code>babel-loader</code> 已经把  <code>babel-core</code>作为<code>peerDependency</code>，所以只是改成了<code>@babel/core</code>。</p><h3 id="支持-“Pure”-注释"><a href="#支持-“Pure”-注释" class="headerlink" title="支持 “Pure” 注释"></a>支持 “Pure” 注释</h3><p>在 <a href="https://github.com/babel/babel/pull/6209" target="_blank" rel="noopener">#6209</a> 之后，Babel 编译 ES6 class 之后的代码，会带有 <code>/*#__PURE__*/</code> 注释，至于为啥要这样做呢？是因为 Babel 要给压缩工具留一些线索，以便于压缩工具，比如 <a href="https://github.com/mishoo/UglifyJS2" target="_blank" rel="noopener">Uglify</a>、<a href="https://github.com/babel/minify" target="_blank" rel="noopener">babel-minify</a> 去掉 dead code。这些注释也会用于其它的 helper 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  m() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> C =</span><br><span class="line"><span class="comment">/*#__PURE__*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><h3 id="babel-node-从-babel-cli-中独立"><a href="#babel-node-从-babel-cli-中独立" class="headerlink" title="@babel/node 从 @babel/cli 中独立"></a>@babel/node 从 @babel/cli 中独立</h3><p>和 babel 6 不同，如果要使用 <code>@babel/node</code>，就必须单独安装，并添加到依赖中。</p><h3 id="不再支持低版本-node"><a href="#不再支持低版本-node" class="headerlink" title="不再支持低版本 node"></a>不再支持低版本 node</h3><p>对那些已经不维护的 node 版本不予支持，包括 0.10、0.12、4、5（<a href="http://babeljs.io/blog/2017/09/12/planning-for-7.0#drop-support-for-unmaintained-node-versions-010-012-5-4315-https-githubcom-babel-babel-issues-4315" target="_blank" rel="noopener">详情</a>），相当于要求 nodejs &gt;= 6。</p><p>这里的不再支持，指的是在这些低版本 node 环境中不能使用 babel 转译代码，但 babel 转译后的代码依然能在这些环境上运行，这点不要混淆。</p><h2 id="babel-upgrade"><a href="#babel-upgrade" class="headerlink" title="babel-upgrade"></a>babel-upgrade</h2><p><a href="https://github.com/babel/babel-upgrade" target="_blank" rel="noopener"><code>babel-upgrade</code></a>，Babel 团队开发的新工具，旨在用来处理升级过程中的琐事（changes）：目前只是针对 <code>package.json</code> 的 <code>dependencies</code> 以及 <code>.babelrc</code>配置，它会检测 babel 配置中的 stage-x 并且替换成对应的 plugins。除此之外它还有其他功能，但大目标就是让你更加平滑地迁移到 babel 7。</p><p>Babel 团队推荐在项目里面直接运行 <code>npx babel-upgrade</code>，或者你可以通过 <code>npm install -g babel-upgrade</code> 的方式，在全局安装 <code>babel-upgrade</code>。</p><p>如果你想修改文件，你可以传 <code>--write</code> 以及 <code>--install</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel-upgrade --write --install</span><br></pre></td></tr></table></figure><p>这款升级工具的功能包括：（这里并不列出完整列表，只列出比较重要和常用的内容）</p><ul><li>package.json</li></ul><ol><li>把依赖（和开发依赖）中所有的 <code>babel-*</code> 替换为 <code>@babel/*</code></li><li>并把这些 <code>@babel/*</code> 依赖的版本更新为最新版 (例如 <code>^7.0.0</code>)，如果 <code>scripts</code> 中有使用 <code>babel-node</code>，自动添加 <code>@babel/node</code> 为开发依赖</li><li>如果有 <code>babel</code> 配置项，检查其中的 <code>plugins</code> 和 <code>presets</code>，把短名（<code>env</code>） 替换为完整的名字 （<code>@babel/preset-env</code>）</li></ol><ul><li>.babelrc</li></ul><ol><li>检查其中的 <code>plugins</code> 和 <code>presets</code>，把短名（<code>env</code>）替换为完整的名字（<code>@babel/preset-env</code>）</li><li>检查是否包含 <code>preset-stage-x</code>，如有替换为对应的插件并添加到 <code>plugins</code></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th style="text-align:center">v7包名（v6包名）</th><th style="text-align:center">作用</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">@babel/cli（babel-cli）</td><td style="text-align:center">命令行使用bable命令</td><td style="text-align:center">少了一些包，并把@babel/core作为peerDependencies</td></tr><tr><td style="text-align:center">@babel/node（babel-node）</td><td style="text-align:center">命令行直接转译 + 执行node文件</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101908.jpg" alt="image-20181116171602076"><br>依然是babel-polyfill<code>+</code>babel-register，同样把@babel/core作为了peerDependencies</td></tr><tr><td style="text-align:center">@babel/register（babel-register）</td><td style="text-align:center">改写require命令，为其加载的文件进行转码，但是不会对当前文件转码，包含了corejs</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101909.jpg" alt="image-20181116173312093"><br>同样把@babel/core作为了peerDependencies</td></tr><tr><td style="text-align:center">@babel/polyfill（babel-polyfill）</td><td style="text-align:center">现在包括corejs和regenerator</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101910.jpg" alt="image-20181116171914153"></td></tr><tr><td style="text-align:center">@babel/runtime（babel-runtime）</td><td style="text-align:center">现在包括regenerator和helpers</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101911.jpg" alt="image-20181116214155724"></td></tr><tr><td style="text-align:center">@babel/runtime-corejs2</td><td style="text-align:center">现在包括corejs、regenerator和helpers</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101912.jpg" alt="image-20181116171806763"></td></tr><tr><td style="text-align:center">@babel/plugin-transform-runtime（babel-plugin-transform-runtime）</td><td style="text-align:center">让 babel 自动且按需的进行 polyfill（不污染全局变量和prototype）</td><td style="text-align:center">同样把@babel/core作为了peerDependencies<br><img src="https://images.leotian.cn/blog/2019-04-29-101913.jpg" alt="image-20181116171624202"></td></tr><tr><td style="text-align:center">@babel/core（babel-core）</td><td style="text-align:center">原来只是在代码里使用 babel，现在目前来看基本是最重要的一个包了，不管装什么都对把其作为peerDependencies</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-101914.jpg" alt="image-20181116171551115"></td></tr><tr><td style="text-align:center">@babel/preset-env</td><td style="text-align:center">整合了 es201x，并自动根据目标平台分析需要用哪些插件</td><td style="text-align:center">plugin太多，不截图了，把除了babel开头的截一下，同样把@babel/core作为了peerDependencies<br><img src="https://images.leotian.cn/blog/2019-04-29-101915.jpg" alt="image-20181120222334071"></td></tr><tr><td style="text-align:center">babel-loader（babel-loader）</td><td style="text-align:center">使用webpack时作为一个loader，在代码混淆前进行转码</td><td style="text-align:center">新版把@babel/core作为peerDependencies</td></tr><tr><td style="text-align:center">babel-eslint（babel-eslint）</td><td style="text-align:center">使用eslint时，进行前置转码</td><td style="text-align:center">依然把eslint作为<a href="https://nodejs.org/zh-cn/blog/npm/peer-dependencies/" target="_blank" rel="noopener"><code>Peer Dependencies</code></a></td></tr></tbody></table><p>暂时先写到这里，其实核心机制方面没有变化，插件，preset，解析转译生成这些都没有变化，但是断舍离方面改动很大。重点看应用吧，下一篇讲应用。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.w3ctech.com/topic/2150" target="_blank" rel="noopener">Babel 7 于今天发布</a></p><p><a href="https://babeljs.io/blog/2017/12/27/nearing-the-7.0-release#renames-proposal" target="_blank" rel="noopener">Nearing the 7.0 Release</a>/<a href="https://babel.docschina.org/blog/2018/08/27/7.0.0" target="_blank" rel="noopener">Babel 7 发布</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 编译器 </tag>
            
            <tag> babel </tag>
            
            <tag> 7.0版本 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再谈Babel-polyfill</title>
      <link href="/posts/d0c9/"/>
      <url>/posts/d0c9/</url>
      
        <content type="html"><![CDATA[<p>Babel 包含编译和polyfill两部分，这次我们专门来说一下polyfill部分（感觉很容易搞混）。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102039.jpg" alt="âbabel 7âçå¾çæç´¢ç&quot;æ"></p><a id="more"></a><h1 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h1><p>直接说结论，Polyfill 的准确意思为：<strong>用于实现低版本浏览器还不支持的原生API的代码。</strong></p><p>例如，<code>querySelectorAll</code>是很多现代浏览器都支持的原生Web API，但是有些古老的浏览器并不支持，那么假设有人写了库，只要用了这个库，你就可以在古老的浏览器里面使用<code>document.querySelectorAll</code>，使用方法跟现代浏览器原生API无异。那么这个库就可以称为<code>Polyfill</code>或者<code>Polyfiller</code>。</p><h2 id="polyfill的来历"><a href="#polyfill的来历" class="headerlink" title="polyfill的来历"></a>polyfill的来历</h2><p><code>Polyfill</code>或者<code>Polyfiller</code>，是英国Web开发者 <a href="https://remysharp.com/" target="_blank" rel="noopener">Remy Sharp</a> 在咖啡店蹲坑的时候拍脑袋造出来的。当时他想用一个词来形容：用 JavaScript（或者Flash之类的什么鬼）来实现一些浏览器不支持的原生API。<code>Shim</code>这个已经有的词汇第一时间出现在他的脑海里。但是他回头想了一下<code>Shim</code>一般有自己的API，而不是单纯实现原生不支持的API。苦思冥想一直想不到合适的单词，于是他一怒之下造了一个单词<code>Polyfill</code>。除了他自己用这个词以外，他还给其他开发者用。随着他在各种Web会议演讲和他写的书《Introducing HTML5》中频繁提到这个词，大家用了都觉得很好，就一起来用。</p><p>tip：术语polyfill来自于一个家装产品Polyfilla，Polyfilla是一个英国产品，（在美国称之为Spackling Paste，在中国称为腻子，刮墙的）。把旧的浏览器想象成为一面有了裂缝的墙。这些 [polyfills] 会帮助我们把这面墙的裂缝抹平,还我们一个更好的光滑的墙壁（浏览器）。</p><h2 id="shim和polyfill的区别"><a href="#shim和polyfill的区别" class="headerlink" title="shim和polyfill的区别"></a>shim和polyfill的区别</h2><p>一个shim是一个库，它将一个新的API引入到一个旧的环境中，而且仅靠旧环境中已有的手段实现。两者对比网上说法有很多，这里从中选了一种我认为比较靠谱的：<a href="https://www.zhihu.com/question/22129715/answer/21242550" target="_blank" rel="noopener">shim和polyfill有什么区别? - 李靖威的回答 - 知乎</a></p><blockquote><p>polyfill 是 shim 的一种。</p><p>shim 是将不同 api 封装成一种，比如 jQuery 的 $.ajax 封装了 XMLHttpRequest 和 IE 用 ActiveXObject 方式创建 xhr 对象；</p><p>polyfill 特指 shim 成的 api 是<strong>遵循标准</strong>的，其典型做法是在IE浏览器中增加 window.XMLHttpRequest ，内部实现使用 ActiveXObject。</p><p>在实际中为了方便做对比，会特指 shim 的 api，<strong>不是</strong>遵循标准的，而是自己设计的。</p></blockquote><p>tip：还有一种叫shiv的东西，它的作用是使得不支持HTML5标签的浏览器诸如ie6-8, 支持html5标签。</p><h1 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h1><p>其实之前我们提到的”Babel 只编译语法不编译 API“说法并不完全正确（语法才需要编译，API不存在只能填充），Babel 是处于构建时（也就是传统Java等语言的编译时），转译出来的结果在默认情况下并不包括 ES6 对运行时的扩展，例如，builtins（内建对象，包括 Promise、Set、Map 等）、内建类型上的扩展（如 ES6 对 Array、Object、String 等内建类型上的扩展）以及 Regenerator（用于generators / yield）等都不包括在内。</p><p>tips：</p><ol><li>built-ins（内建），又可以叫”natives”（本地人） ，可以理解为内建对象，比如 String 和 Number。</li><li><a href="http://facebook.github.io/regenerator/" target="_blank" rel="noopener">Regenerator</a>，是Facebook开发的，一个用来转换es6的yield语法到es5的工具。</li></ol><h2 id="core-js-标准库"><a href="#core-js-标准库" class="headerlink" title="core-js 标准库"></a>core-js 标准库</h2><p>这是所有 Babel polyfill 方案都需要依赖的开源库<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js" target="_blank" rel="noopener">zloirock/core-js</a>，它提供了 ES5、ES6 的 polyfills，包括 <a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23ecmascript-6-promise" target="_blank" rel="noopener">promises</a> 、<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23ecmascript-6-symbol" target="_blank" rel="noopener">symbols</a>、<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23ecmascript-6-collections" target="_blank" rel="noopener">collections</a>、iterators、<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23ecmascript-6-typed-arrays" target="_blank" rel="noopener">typed arrays</a>、<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23ecmascript-7-proposals" target="_blank" rel="noopener">ECMAScript 7+ proposals</a>、<a href="https://link.zhihu.com/?target=https%3A//github.com/zloirock/core-js%23setimmediate" target="_blank" rel="noopener">setImmediate</a> 等等。</p><p><strong>如果使用了 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill，你就可以间接的引入了 core-js 标准库。例如，Array.from 就是来自于 core-js/array/from.js 。</strong></p><h2 id="regenerator-运行时库"><a href="#regenerator-运行时库" class="headerlink" title="regenerator 运行时库"></a>regenerator 运行时库</h2><p>这是 Facebook 提供的 <a href="https://link.zhihu.com/?target=https%3A//github.com/facebook/regenerator" target="_blank" rel="noopener">facebook/regenerator</a> 库，用来实现 ES6/ES7 中 generators、yield、async 及 await 等相关的 polyfills。在下面即将提到的 babel-runtime 中被引用。有些初学者遇到的<a href="https://stackoverflow.com/questions/33527653/babel-6-regeneratorruntime-is-not-defined" target="_blank" rel="noopener"><code>regeneratorRuntime is not defined</code></a>就是因为只在 preset 中配置了 stage-0 却忘记加上 babel-polyfill。</p><p><strong>如果使用了 babel-runtime、babel-plugin-transform-runtime 或者 babel-polyfill，你就可以间接的引入了 regenerator-runtime 运行时库。</strong></p><h2 id="babel-runtime-库"><a href="#babel-runtime-库" class="headerlink" title="babel-runtime 库"></a>babel-runtime 库</h2><p>babel-runtime 是由 Babel 提供的 polyfill 库，它本身就是由 core-js 与 regenerator-runtime  库组成，除了做简单的合并与映射外，并没有做任何额外的加工。</p><p>所以在使用时，你需要自己去 require，举一个例子，如果你想使用 Promise，你必须在每一处需要用到 Promise 的 module 里，手工引入 promise 模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'babel-runtime/core-js/promise'</span>);</span><br></pre></td></tr></table></figure><p><strong>由于这种方式十分繁琐，事实上严谨的使用还要配合 interopRequireDefault（作用是判断引入的是否是es6模块，是则直接返回obj，如果是commonjs模块，则将引入的内容放在一个对象的default属性上返回） 方法使用，所以 Babel 提供了一个插件，即 babel-plugin-transform-runtime。</strong></p><h2 id="babel-plugin-transform-runtime-插件"><a href="#babel-plugin-transform-runtime-插件" class="headerlink" title="babel-plugin-transform-runtime 插件"></a>babel-plugin-transform-runtime 插件</h2><p>这个插件让 Babel 发现代码中使用到 Symbol、Promise、Map 等新类型时，自动且按需进行 polyfill，因为是“自动”所以非常受大家的欢迎。</p><p>在官网中，Babel 提醒大家如果正在开发一个 library 的话，建议使用这种方案，因为没有全局变量和 prototype 污染。</p><p>全局变量污染，是指 babel-plugin-transform-runtime 插件会帮你实现一个沙盒（sandbox），虽然你的 ES6 源代码显式的使用了看似全局的 Promise、Symbol，但是在沙盒模式下，Babel 会将它们转译成：</p><p><strong>ES6 代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="built_in">Symbol</span>.iterator]());</span><br></pre></td></tr></table></figure><p><strong>转译后的代码</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _getIterator2 = <span class="built_in">require</span>(<span class="string">"babel-runtime/core-js/get-iterator"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _getIterator3 = _interopRequireDefault(_getIterator2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _promise = <span class="built_in">require</span>(<span class="string">"babel-runtime/core-js/promise"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _promise2 = _interopRequireDefault(_promise);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _symbol = <span class="built_in">require</span>(<span class="string">"babel-runtime/core-js/symbol"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _symbol2 = _interopRequireDefault(_symbol);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sym = (<span class="number">0</span>, _symbol2.default)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> _promise2.default();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log((<span class="number">0</span>, _getIterator3.default)(arr));</span><br></pre></td></tr></table></figure><p>你会发现，这个插件至始至终没有在 Global 对象下挂载全局的 Symbol 和 Promise 变量。这样一来，如果你引入的其他类库使用了 bluebird 之类的第三方 polyfill 也不会受此影响。</p><p>那么什么是 prototype 污染呢，这就要说到 ES6 的 Array、String 等内建类型扩展了很多新方法，<strong>如 Array 原型上的 includes()、filter() 等新方法（实例方法），babel-plugin-transform-runtime 插件是不会进行扩展修改的，很多人往往忽略了这一点。要区分的是，Array.from 等静态方法（或者叫类方法）还是会被插件 polyfill 的。因此，babel-plugin-transform-runtime 这个插件更适合于开发类库（library）时去使用，而不适合直接用在独立的前端工程中。另外，它可以按需polyfill，所以从一定程度上控制了polyfill 文件的大小。</strong></p><h2 id="babel-polyfill-1"><a href="#babel-polyfill-1" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h2><p>最后回到 babel-polyfill，它的初衷是emulate（模拟）一整套 ES2015+ 运行时环境，所以它的确会以全局变量的形式 polyfill Map、Set、Promise 之类的类型，也的确会以类似 Array.prototype.includes() 的方式去注入污染原型，这也是官网中提到最适合应用级开发的 polyfill，再次提醒如果你在开发 library 的话，不推荐使用（或者说绝对不要使用）。</p><p><strong>不同于插件（babel-plugin-transform-runtime 就是一个插件，需要配置在<code>.babelrc</code>中）</strong>，你所要做的事情很简单，就是将<code>babel-polyfill</code>一次性的引入到你的工程中，通常是和其他的第三方类库（如 jQuery、React 等）一同打包在 vendor.js（vendor中文翻译为厂商，即第三方， webpack 中通常用vendor来命名我们项目中使用的第三方库，俗称三方库）中即可。在你写程序的时候，你完全不会感知 babel-polyfill 的存在，如果你的浏览器已经支持 Promise，它会优先使用 native 的 Promise，如果没有的话，则会采用 polyfill 的版本（这个行为与 babel-plugin-transform-runtime 一致），在使用 babel-polyfill 后，你不需要引入 babel-plugin-transform-runtime 插件和其他依赖的类库。它的缺点也显而易见，那就是占文件空间并且无法按需定制。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102041.jpg" alt="image-20181115130650463"></p><p>tip：babel-polyfill 并不是一定会污染全局环境，在引入这个 js，并运行的时候，它会先判断当前有没有这个方法，在看要不要重写，如上图，是对<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/sign" target="_blank" rel="noopener"><code></code>Math.sign()`</a>方法的替换。</p><h2 id="对比babel-polyfill和babel-plugin-transform-runtime"><a href="#对比babel-polyfill和babel-plugin-transform-runtime" class="headerlink" title="对比babel-polyfill和babel-plugin-transform-runtime"></a>对比babel-polyfill和babel-plugin-transform-runtime</h2><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">babel-polyfill</th><th style="text-align:center">babel-plugin-transform-runtime</th></tr></thead><tbody><tr><td style="text-align:center">根本区别</td><td style="text-align:center">不是一个plugin（插件），要所有代码之前引入，并且如果当前项目已经引入一次 polyfill 了，那你只能保留其一，改造目标环境，让目标环境拥有本来不支持的特性</td><td style="text-align:center">是一个plugin（插件），写的顺序应该没所谓，会改造你的代码，让你的代码能在所有目标环境上运行，但不改造目标环境</td></tr><tr><td style="text-align:center">是否依赖<code>bable-runtime</code></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td></tr><tr><td style="text-align:center">builtins（内建，包括 Promise、Set、Map）支持</td><td style="text-align:center">支持（优先使用 native 的 Promise，如果没有的话，则会采用 polyfill 的版本）</td><td style="text-align:center">支持（优先使用 native 的 Promise，如果没有的话，则会采用 polyfill 的版本）</td></tr><tr><td style="text-align:center">是否支持内建类型上的扩展</td><td style="text-align:center">支持类方法和原型方法（污染prototype）</td><td style="text-align:center">支持类方法，不支持原型方法（所以不污染prototype）</td></tr><tr><td style="text-align:center">Regenerator</td><td style="text-align:center">支持</td><td style="text-align:center">支持</td></tr><tr><td style="text-align:center">使用时间</td><td style="text-align:center">一开始就全量转换</td><td style="text-align:center">babel发现使用到时自动且按需</td></tr></tbody></table><p>如果你还是困惑，我推荐一个非常简单的区分方法 - 打开浏览器开发者工具，在 console 里执行代码：</p><ol><li>引入 babel-polyfill 后的 IE 11，你可以在 console 下执行 <code>Object.assign({}, {})</code></li><li>而引入 babel-plugin-transform-runtime 后的 IE 11，仍然提示你：<code>Object doesn&#39;t support property or method &#39;assign&#39;</code></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 内，<code>babel-plugin-syntax</code>开头的插件是语法插件，负责解析新的语法，<code>babel-plugin-transform</code>开头的插件负责转译，也就是解析语法+转换代码，也就是我们最终的目的，所以如果使用了转译插件，就不用再使用语法插件了。preset可以整合众多plugin，如早期的<code>babel-preset-es2015</code>整合了es6的语法和转译插件，现在推荐使用env。转译/编译是构建阶段的操作，除了转译/编译，babel还包括polyfill部分，处理运行时扩展，主要使用babel-runtime（包括core-js、regenerator和helpers）完成，使用又包括 babel-polyfill 和 transform-runtime，区别见上面讨论。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/49382420/answer/223915243" target="_blank" rel="noopener">Babel 编译出来还是 ES 6？难道只能上 polyfill？ - Henry的回答 - 知乎</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 编译器 </tag>
            
            <tag> babel </tag>
            
            <tag> polyfill </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Babel第一讲</title>
      <link href="/posts/a5ff/"/>
      <url>/posts/a5ff/</url>
      
        <content type="html"><![CDATA[<p>最近在小伙伴的推动下进行了一波工具的升级，包括webpack、babel。这两大工具都是前端工程化的常用工具，我准备依次总结一下这两样工具的使用。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102001.jpg" alt="âbabel 7âçå¾çæç´¢ç&quot;æ"></p><a id="more"></a><h1 id="what’s-babel"><a href="#what’s-babel" class="headerlink" title="what’s babel"></a>what’s babel</h1><p><a href="https://babeljs.io/" target="_blank" rel="noopener">Babel</a>是一个广泛使用的转码器，可以将使用了ES6、ES7或更新的仍然在proposal（提案）阶段语法的代码转为ES5代码，从而使低端运行环境（如浏览器和node）能够认识并执行。严格来说，babel 也可以转化为更低的规范。但以目前情况来说，es5 规范已经足以覆盖绝大部分浏览器，因此常规来说转到 es5 是一个安全且流行的做法。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>一般存在一下几种方式：</p><ol><li>使用单体文件（standalone script，如使用<a href="https://github.com/Daniel15/babel-standalone" target="_blank" rel="noopener">babel-standalone</a>模块提供的浏览器版本，将其插入网页，但网页中实时将ES6代码转为ES5，对性能会有影响，生产环境一般使用已经转码完成的脚本）。</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// Your ES6 code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Babel还提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL在线编译器</a>，可以在线将ES6代码转为ES5代码。转换后的代码，可以直接作为ES5代码插入网页运行。</li><li>命令行（cli），多见于 package.json 中的 <code>scripts</code> 段落中的某条命令。</li><li>使用构建工具的插件（webpack 的 babel-loader，rollup 的 rollup-plugin-babel）集成到构建工具中。</li></ol><p>其中后两种比较常见，我们重点讨论，不过这些方式的差别只是于入口不同而已，调用的 babel 内核，处理方式都是一样的。</p><h2 id="运行方式和插件"><a href="#运行方式和插件" class="headerlink" title="运行方式和插件"></a>运行方式和插件</h2><p>babel 总共分为三个阶段：解析，转换，生成。</p><p>babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的。</p><p>插件总共分为语法插件和转译插件两种：</p><ul><li>当我们添加 <strong>语法插件</strong> 之后，就在解析这一步使得 babel 能够解析更多的语法。（tip：babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发）</li></ul><p>举个简单的例子，当我们定义或者调用方法时，最后一个参数之后是不允许增加逗号的，如 <code>callFoo(param1, param2,)</code> 就是非法的。如果源码是这种写法，经过 babel 之后就会提示语法错误。</p><p>但最近的JavaScript<a href="https://github.com/tc39/proposal-trailing-function-commas" target="_blank" rel="noopener">提案</a>中已经允许了这种新的写法（让代码 diff 更加清晰）。为了避免 babel 报错，就需要增加语法插件 <code>babel-plugin-syntax-trailing-function-commas</code>。</p><ul><li>当我们添加 <strong>转译插件</strong> 之后，在转换这一步把源码转换并输出。这也是我们使用 babel 最本质的需求。</li></ul><p>比起语法插件，转译插件其实更好理解，比如箭头函数 <code>(a) =&gt; a</code> 就会转化为 <code>function (a) {return a}</code>。完成这个工作的插件叫做 <code>babel-plugin-transform-es2015-arrow-functions</code>。</p><p>同一类语法可能同时存在语法插件版本和转译插件版本。<strong>如果我们使用了转译插件，就不用再使用语法插件了。</strong></p><h2 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h2><p>插件的配置方式如下：</p><ol><li>使用 <code>npm install babel-plugin-xxx</code> 进行安装</li><li>将插件的名字增加到配置文件中（根目录下创建 .babelrc 或者 package.json 的 <code>babel</code> 里面，格式相同）</li></ol><h2 id="preset"><a href="#preset" class="headerlink" title="preset"></a>preset</h2><p>我们平常所说的es6（也就是es2015）其实是一套规范，包含大概十几二十个转译插件。如果每次要开发者一个个添加并安装，首先使用<code>npm install</code>一个个安装就很麻烦，配置文件也会越来越长，跟不用说还有同时使用的其他插件。为了解决这个问题，babel 还提供了一组插件的集合（类似于一个全家桶套餐，也就是preset，意思是预先设置）。因为常用，所以不必重复配置和一个个安装。</p><p>preset 分为以下几种：</p><ul><li><p>官方内容，目前包括 env、react、flow、minify 等（tip：这里最重要的是 env，后面会详细介绍）。</p></li><li><p>es201x、latest<br>这些是已经纳入到标准规范的语法。例如 es2015 包含 <code>arrow-functions</code>，es2017 包含 <code>syntax-trailing-function-commas</code>。但因为 env 的出现，使得 es2016 和 es2017 都已经废弃。所以我们经常可以看到 es2015 被单独列出来（es2015先于env出现），但极少看到其他两个。<br>latest 是 env 的雏形，它是一个每年更新的 preset，目的是包含所有 es201x。但也是因为更加灵活的 env 的出现，已经废弃。</p></li><li>stage-x，这里面包含的都是当年最新规范的草案，每年更新（tip：babel 7已经不推荐使用，后面也会讲）。例如 <code>syntax-dynamic-import</code> 就是 stage-2 的内容，<code>transform-object-rest-spread</code> 就是 stage-3 的内容。此外，低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2和stage-3的所有内容。stage-4 是不存在的因为它就是上面的 es2015。</li></ul><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>简单的几条原则：</p><ul><li>Plugin 会运行在 Preset 之前。</li><li>Plugin 会从前到后顺序执行。</li><li>Preset 的顺序则 <strong>刚好相反</strong>（从后向前）。</li></ul><p>preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 <code>[&#39;es2015&#39;, &#39;stage-0&#39;]</code>。这样必须先执行 <code>stage-0</code> 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，<strong>其实只要按照规范的时间顺序列出即可。</strong></p><h2 id="插件和-preset-的配置项"><a href="#插件和-preset-的配置项" class="headerlink" title="插件和 preset 的配置项"></a>插件和 preset 的配置项</h2><p>简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项（或者说参数），就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。</p><p>最需要配置的当属 env，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">"presets": [</span><br><span class="line">  // 带了配置项，自己变成数组</span><br><span class="line">    [</span><br><span class="line">        // 第一个元素依然是名字</span><br><span class="line">        <span class="string">"env"</span>,</span><br><span class="line">        // 第二个元素是对象，列出配置项</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"modules"</span>: <span class="literal">false</span></span><br><span class="line">          // 指将ES6模块语法转换为另一种模块类型。设置为 <span class="literal">false</span> 则不会转换模块</span><br><span class="line">          // 推荐将 modules 设置为 <span class="literal">false</span>，即交由 Webpack 来处理模块化，通过其 TreeShaking 特性将有效减少打包出来的 JS 文件大小</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 不带配置项，直接列出名字</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="env（重点）"><a href="#env（重点）" class="headerlink" title="env（重点）"></a>env（重点）</h2><p>env 最常用也最重要，所以我们需要重点关注。Babel 的官网上在2017年9月就宣布 ES2015 / ES2016/ ES2017 等等 ES20xx 时代的 presets 通通被废弃（deprecated），取而代之的是 babel-preset-env，并且承诺它将成为“未来不会过时的（future-proof）”解决方案。</p><blockquote><p>在过去，Babel 将 babel-preset-es2015 放在 babel/babel 的主仓库中进行维护，而 babel-preset-env 则独立为一级项目，这从某种程度上也显示出 Babel 官方对这款 preset 的重视程度和更长远的规划。</p></blockquote><p>env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。例如目标浏览器支持 es2015，那么 es2015 这个 preset 其实是不需要的，于是代码就可以小一点（一般转化后的代码总是更长），构建时间也可以缩短一些。</p><p>如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加（不包含 stage-x 中的插件）。env 包含的插件列表维护在<a href="http://link.zhihu.com/?target=https%3A//github.com/babel/babel-preset-env/blob/master/data/plugin-features.js" target="_blank" rel="noopener">这里</a>。</p><p>下面列出几种比较常用的配置方法：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">        <span class="attr">"browsers"</span>: [<span class="string">"last 2 versions"</span>, <span class="string">"safari &gt;= 7"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置将考虑所有浏览器的最新2个版本（safari大于等于7.0的版本）的特性，将必要的代码进行转换。而这些版本已有的功能就不进行转化了。这里的语法可以参考 <a href="http://link.zhihu.com/?target=https%3A//github.com/browserslist/browserslist" target="_blank" rel="noopener">browserslist</a>。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, &#123;</span><br><span class="line">      <span class="attr">"targets"</span>: &#123;</span><br><span class="line">        <span class="attr">"node"</span>: <span class="string">"6.10"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上配置将目标设置为 nodejs，并且支持 6.10 及以上的版本。也可以使用 <code>node: &#39;current&#39;</code> 来支持最新稳定版本。例如箭头函数在 nodejs 6 及以上将不被转化，但如果是 nodejs 0.12 就会被转化了。</p><p>另外一个有用的配置项是 <code>modules</code>。它的取值可以是 <code>amd</code>, <code>umd</code>, <code>systemjs</code>, <code>commonjs</code> 和 <code>false</code>。这可以让 babel 以特定的模块化格式来输出代码。如果选择 <code>false</code> 就不进行模块化处理。</p><h1 id="其他配套工具"><a href="#其他配套工具" class="headerlink" title="其他配套工具"></a>其他配套工具</h1><p>以上讨论了 babel 的核心处理机制和配置方法等，不论任何入口调用 babel 都走这一套。不过 package.json 中的一堆 <code>babel-*</code> 还是让人一头雾水。实际上这些 <code>babel-*</code> 大多是不同的入口(方式)来使用 babel，下面来简单介绍一下。</p><h2 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h2><p>顾名思义，cli 是命令行工具。安装了 <code>babel-cli</code> 就能够在命令行中使用 <code>babel</code> 命令来编译文件。</p><p>在开发 npm package 时经常会使用如下模式：</p><ul><li>把 <code>babel-cli</code> 安装为 <code>devDependencies</code></li><li>在 package.json 中添加 <code>scripts</code> (比如 <code>prepublish</code>)，使用 <code>babel</code> 命令编译文件</li><li><code>npm publish</code></li></ul><p>这样既可以使用较新规范的 JS 语法编写源码，同时又能支持旧版环境。因为项目可能不太大或者是个后端工具，用不到构建工具 （webpack 或者 rollup），于是在发布之前用 <code>babel-cli</code> 进行处理。</p><h2 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h2><p><code>babel-node</code> 是 <code>babel-cli</code> 的一部分，它不需要单独安装，而是<code>babel-cli</code>的一个命令，存在于<code>babel-cli/bin/</code>中。</p><p>它的作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。例如我们有一个 js 文件以 es2015 的语法进行编写(如使用了箭头函数)。我们可以直接使用 <code>babel-node es2015.js</code> 进行执行，而不用再进行转码了。</p><p>或者说<code>babel-node</code> = <code>babel-polyfill</code> + <code>babel-register</code>。接下来介绍这两个工具。</p><h2 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h2><p>babel-register 模块改写 <code>require</code> 命令，为它加上一个钩子。此后，每当使用 <code>require</code> 加载 <code>.js</code>、<code>.jsx</code>、<code>.es</code> 和 <code>.es6</code> 后缀名的文件，就会先用 babel 进行转码。</p><p>使用时，必须首先加载 <code>require(&#39;babel-register&#39;)</code>。</p><p>需要注意的是，babel-register 只会对 <code>require</code> 命令加载的文件转码，而 <strong>不会对当前文件转码</strong>。</p><p>另外，由于它是实时转码，所以 <strong>只适合在开发环境使用</strong>。</p><h2 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h2><p>babel 默认只转换 js 语法，而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 <code>Object.assign</code>）都不会转码。</p><p>举例来说，es2015 在 Array 对象上新增了 <code>Array.from</code> 方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用 <code>babel-polyfill</code>。（内部集成了 <code>core-js</code> 和 <code>regenerator</code>）</p><p>使用时，在所有代码运行之前增加 <code>require(&#39;babel-polyfill&#39;)</code>。或者更常规的操作是在 <code>webpack.config.js</code> 中将 <code>babel-polyfill</code> 作为第一个 entry。因此必须把 <code>babel-polyfill</code> 作为 <code>dependencies</code> 而不是 <code>devDependencies</code></p><p><code>babel-polyfill</code> 主要有两个缺点：</p><ol><li>使用 <code>babel-polyfill</code> 会导致打出来的包非常大，因为 <code>babel-polyfill</code> 是一个整体，把所有方法都加到原型链上。比如我们只使用了 <code>Array.from</code>，但它把 <code>Object.defineProperty</code>也给加上了，这就是一种浪费了。这个问题可以通过单独使用 <a href="https://github.com/zloirock/core-js#readme" target="_blank" rel="noopener"><code>core-js</code></a> 的某个类库来解决，<code>core-js</code> 都是分开的（core-js 是babel-polyfill 的底层依赖，通过各种奇技淫巧，用 ES3 实现了大部分的 ES2017 原生标准库）。</li><li><code>babel-polyfill</code> 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。</li></ol><p>因此在实际使用中，如果我们无法忍受这两个缺点（尤其是第二个，比如要写一个npm包，如果引入导致污染了使用者的全局变量是不太好的，可能对使用者项目带来不确定性），通常我们会倾向于使用 <code>babel-plugin-transform-runtime</code>。</p><p>但如果代码中包含高版本 js 中类型的实例方法（例如 <code>[1,2,3].includes(1)</code>），这还是要使用 polyfill。</p><h2 id="babel-runtime-和-babel-plugin-transform-runtime"><a href="#babel-runtime-和-babel-plugin-transform-runtime" class="headerlink" title="babel-runtime 和 babel-plugin-transform-runtime"></a>babel-runtime 和 babel-plugin-transform-runtime</h2><p>我们时常在项目中看到 .babelrc 中使用 <code>babel-plugin-transform-runtime</code>，而 <code>package.json</code> 中的 <code>dependencies</code>（注意不是 <code>devDependencies</code>） 又包含了 <code>babel-runtime</code>，那这两个的关系和作用分别是什么呢？是不是要成套使用呢？</p><p>先说 <code>babel-plugin-transform-runtime</code>。</p><p>babel 会转换 js 语法，之前已经提过了。以 <code>async/await</code> 举例，如果不使用这个 plugin（但要使用env或者stage-3，因为<code>async/await</code>语法属于es2016，也就是es7），转换后的代码大概是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// babel 添加一个方法，把 async 转化为 generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_asyncToGenerator</span>(<span class="params">fn</span>) </span>&#123; <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;....&#125;&#125; <span class="comment">// 很长很长一段</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用处</span></span><br><span class="line"><span class="keyword">var</span> _ref = _asyncToGenerator(<span class="function"><span class="keyword">function</span>* (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> (<span class="number">0</span>, something)(arg1, arg2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不用过于纠结具体的语法，只需看到，这个 <code>_asyncToGenerator</code> 在当前文件被定义，然后被使用了，以替换源代码的 <code>await</code>。但每个被转化的文件都会插入一段 <code>_asyncToGenerator</code> 这就导致重复和浪费了。</p><p>在使用了 <code>babel-plugin-transform-runtime</code> 了之后，转化后的代码会变成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从直接定义改为引用，这样就不会重复定义了。</span></span><br><span class="line"><span class="keyword">var</span> _asyncToGenerator2 = <span class="built_in">require</span>(<span class="string">'babel-runtime/helpers/asyncToGenerator'</span>);</span><br><span class="line"><span class="keyword">var</span> _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体使用处是一样的</span></span><br><span class="line"><span class="keyword">var</span> _ref = _asyncToGenerator3(<span class="function"><span class="keyword">function</span>* (<span class="params">arg1, arg2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> (<span class="number">0</span>, something)(arg1, arg2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从定义方法改成引用，那重复定义就变成了引用，就不存在代码重复的问题了。</p><p>但在这里，我们也发现 <code>babel-runtime</code> 出场了，它就是这些方法的集合处，也因此，<strong>在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。</strong></p><p>再说 <code>babel-runtime</code>，它内部集成了：</p><ol><li><code>core-js</code>：转换一些内置类 (<code>Promise</code>, <code>Symbols</code>等等) 和静态方法 (<code>Array.from</code> 等)。绝大部分转换是这里做的。自动引入。</li><li><code>regenerator</code>：作为 <code>core-js</code> 的拾遗补漏，主要是 <code>generator/yield</code> 和 <code>async/await</code>两组的支持。当代码中有使用 <code>generators/async</code> 时自动引入。</li><li><code>helpers</code>：如上面的 <code>asyncToGenerator</code> 就是其中之一，其他还有如 <code>jsx</code>, <code>classCallCheck</code>等等，可以查看 <a href="http://link.zhihu.com/?target=https%3A//github.com/babel/babel/blob/6.x/packages/babel-helpers/src/helpers.js" target="_blank" rel="noopener">babel-helpers</a>。在代码中有内置的 helpers 使用时(如上面的第一段代码)移除定义，并插入引用(于是就变成了第二段代码)。</li></ol><p><code>babel-plugin-transform-runtime</code> <strong>不支持</strong> 实例方法（例如 <code>[1,2,3].includes(1)</code>）</p><p>此外补充一点，把 helpers 抽离并统一起来，避免重复代码的工作还有一个 plugin 也能做，叫做 <code>babel-plugin-external-helpers</code>。但因为我们使用的 <code>transform-runtime</code> 已经包含了这个功能，因此不必重复使用。而且 babel 的作者们也已经开始讨论这两个插件过于类似，正在讨论在 babel 7 中把 <code>external-helpers</code> 删除，讨论在 <a href="http://link.zhihu.com/?target=https%3A//github.com/babel/babel/issues/5699" target="_blank" rel="noopener">issue#5699</a> 中。</p><h2 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel-loader"></a>babel-loader</h2><p>前面提过 babel 的三种使用方法，并且已经介绍过了 <code>babel-cli</code>。但一些大型的项目都会有构建工具（如 webpack 或 rollup）来进行代码构建和压缩（uglify）。理论上来说，我们也可以对压缩后的代码进行 babel 处理，但那会非常慢。因此如果在 uglify 之前就加入 babel 处理，岂不完美？</p><p>所以就有了 babel 插入到构建工具内部这样的需求。以 webpack 为例，webpack 有 loader 的概念，因此就出现了 <code>babel-loader</code>。</p><p>和 <code>babel-cli</code> 一样，<code>babel-loader</code> 也会读取 .babelrc 或者 package.json 中的 <code>babel</code> 段作为自己的配置，之后的内核处理也是相同。唯一比 <code>babel-cli</code> 复杂的是，它需要和 webpack 交互，因此需要在 webpack 这边进行配置。比较常见的如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude: <span class="regexp">/(node_modules|bower_components)/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想在这里传入 babel 的配置项，也可以把改成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loader: 'babel-loader' 改成如下：</span></span><br><span class="line">use: &#123;</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  options: &#123;</span><br><span class="line">    <span class="comment">// 配置项在这里</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的配置项优先级是最高的。但我认为放到单独的配置文件中更加清晰合理，可读性强一些。</p><h2 id="babel-eslint"><a href="#babel-eslint" class="headerlink" title="babel-eslint"></a>babel-eslint</h2><p>许多工具需要Babel进行前置转码，这里举两个例子：ESLint和Mocha。</p><p><a href="http://eslint.org/" target="_blank" rel="noopener">ESLint</a> 用于静态检查代码的语法和风格，为了使用新语法我们需要安装 babel-eslint 作为<code>parser</code>（解释器）。使用方法是在eslint的配置文件<code>.eslint</code>中，加入<code>parser</code>字段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再在<code>package.json</code>之中，加入相应的<code>scripts</code>脚本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"my-module"</span>,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"lint"</span>: <span class="string">"eslint my-files.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-eslint"</span>: <span class="string">"..."</span>,</span><br><span class="line">    <span class="string">"eslint"</span>: <span class="string">"..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">Mocha</a> 则是一个测试框架，如果需要执行使用ES6语法的测试脚本，可以修改<code>package.json</code>的<code>scripts.test</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"mocha --ui qunit --compilers js:babel-core/register"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面命令中，<code>--compilers</code>参数指定脚本的转码器，规定后缀名为<code>js</code>的文件，都需要使用<code>babel-core/register</code>先转码。</p><h2 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h2><p>我们看到上面使用 Mocha 时候，选择了<code>babel-core/register</code>作为转码器。那么 babel-core 是什么呢？</p><p>简单的说，如果你需要以编程的方式来使用 Babel，使用 <code>babel-core</code> 这个包，可以在代码里调用Babel的API。相当于是编程的方式去使用 babel，是把代码以字符串的形式从文件或者网络请求等读入，调用它的 transform 方法，转化为新的字符串，再写回文件或者网络返回。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> es6Code = <span class="string">'let x = n =&gt; n + 1'</span>;</span><br><span class="line"><span class="keyword">var</span> es5Code = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line">  .transform(es6Code, &#123;</span><br><span class="line">    presets: [<span class="string">'es2015'</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  .code;</span><br></pre></td></tr></table></figure><p>babel-core 可以把 js 代码分析成 AST ，方便各个插件分析语法进行相应的处理。有些新语法在低版本 js 中是不存在的，如箭头函数，rest 参数，函数默认值等，这种语言层面的不兼容只能通过将代码转为 AST，分析其语法后再转为低版本 js。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th style="text-align:center">包名</th><th style="text-align:center">作用</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">babel-cli</td><td style="text-align:center">命令行使用bable命令</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-102002.jpg" alt="img"></td></tr><tr><td style="text-align:center">babel-node</td><td style="text-align:center">命令行直接转译 + 执行node文件</td><td style="text-align:center">babel-cli的一部分<br>babel-node<code>=</code>babel-polyfill<code>+</code>babel-register</td></tr><tr><td style="text-align:center">babel-register</td><td style="text-align:center">改写require命令，为其加载的文件进行转码，但是不会对当前文件转码</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-102003.jpg" alt="image-20181113224837212"><br>只适用于开发环境</td></tr><tr><td style="text-align:center">babel-polyfill</td><td style="text-align:center">填充内建对象，缺失的为所有API增加兼容方法</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-102004.jpg" alt="image-20181113224808773"><br>需要在所有代码之前<code>require</code>，而且体积较大</td></tr><tr><td style="text-align:center">babel-runtime 和 babel-plugin-transform-runtime</td><td style="text-align:center">让 babel 自动且按需的进行 polyfill（不污染全局变量和prototype）</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-102005.jpg" alt="image-20181113230350432"><br><img src="https://images.leotian.cn/blog/2019-04-29-102006.jpg" alt="image-20181113224911651"></td></tr><tr><td style="text-align:center">babel-core</td><td style="text-align:center">在代码里使用 babel</td><td style="text-align:center"><img src="https://images.leotian.cn/blog/2019-04-29-102007.jpg" alt="img"></td></tr><tr><td style="text-align:center">babel-preset-env</td><td style="text-align:center">整合了 es201x，并自动根据目标平台分析需要用哪些插件</td><td style="text-align:center">plugin太多，不截图了，把除了babel开头的截一下<br><img src="https://images.leotian.cn/blog/2019-04-29-102008.jpg" alt="image-20181120224948380"></td></tr><tr><td style="text-align:center">babel-loader</td><td style="text-align:center">使用webpack时作为一个loader，在代码混淆前进行转码</td><td style="text-align:center">babel-loader和babel-core是<a href="https://nodejs.org/zh-cn/blog/npm/peer-dependencies/" target="_blank" rel="noopener"><code>Peer Dependencies</code></a>关系，不装会报<code>UNMET PEER DEPENDENCY</code></td></tr><tr><td style="text-align:center">babel-eslint</td><td style="text-align:center">使用eslint时，进行前置转码</td><td style="text-align:center">babel-eslint和eslint也是<a href="https://nodejs.org/zh-cn/blog/npm/peer-dependencies/" target="_blank" rel="noopener"><code>Peer Dependencies</code></a>关系，不装会报<code>UNMET PEER DEPENDENCY</code></td></tr></tbody></table><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zhuanlan.zhihu.com/p/43249121" target="_blank" rel="noopener">一口（很长的）气了解 babel</a></p><p><a href="https://zhuanlan.zhihu.com/p/29506685" target="_blank" rel="noopener">再见，babel-preset-2015</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> 编译器 </tag>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB联表查询</title>
      <link href="/posts/80bb/"/>
      <url>/posts/80bb/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.mongodb.com/" target="_blank" rel="noopener">MongoDB</a>是典型的NoSQL数据库，因此不提供JOIN操作。但有时我们仍然希望引用其他集合中的文档。最近使用到了MongoDB的联表查询，总结一下。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102045.jpg" alt="âmongodbâçå¾çæç´¢ç&quot;æ"></p><a id="more"></a><p>首先我们知道，在关系型数据库中，通过连接运算符可以实现多个表联合查询。而非关系型数据库的特点是数据是<a href="https://github.com/qianjiahao/MongoDB/wiki/%E5%A5%97%E5%A8%83%E5%85%B3%E7%B3%BB--%E6%96%87%E6%A1%A3%E3%80%81%E9%9B%86%E5%90%88%E3%80%81%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">文档</a>型，表内无模式，表之间属于弱关联，其本身特性不建议对多Collection关联处理，自然就很难在关系型数据库中非常擅长的多表关联上发挥作用。</p><p>MongoDB作为NoSQL代表，虽然属于非关系型数据库，但也是最像关系型数据库的一种NoSQL，提供了一些方法来解决此类问题。</p><h2 id="建模和关系"><a href="#建模和关系" class="headerlink" title="建模和关系"></a>建模和关系</h2><p>MongoDB是非关系型数据库，具有灵活的模式。因为支持内嵌对象和数组类型，所以MongoDB建模也可以有两种方式，一种是内嵌（Embed），另一种是引用（References）。</p><p>而关系表示多个文档之间在逻辑上的相互联系，关系可以有：1:1（1对1）、1: N（1对多）、N: 1（多对1）、N: N（多对多）4种。文档间可以通过嵌入和引用来建立联系，也对应了MongoDB建模的两种方式。</p><p>接下来我们来以用户与用户地址的关系为例。一个用户可以有多个地址，所以是一对多的关系。</p><h3 id="嵌入式关系"><a href="#嵌入式关系" class="headerlink" title="嵌入式关系"></a>嵌入式关系</h3><p>使用嵌入式方式（即内嵌）建模，我们可以把用户地址嵌入到用户的文档中：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:ObjectId(<span class="string">"5bdc18178bf520001167208b"</span>),</span><br><span class="line">   <span class="attr">"contact"</span>: <span class="string">"123456"</span>,</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">   <span class="attr">"address"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"building"</span>: <span class="string">"22 A, 中心大厦"</span>,</span><br><span class="line">         <span class="attr">"pincode"</span>: <span class="number">123456</span>,</span><br><span class="line">         <span class="attr">"city"</span>: <span class="string">"上海"</span>,</span><br><span class="line">         <span class="attr">"state"</span>: <span class="string">"浦东"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="attr">"building"</span>: <span class="string">"301 A, 首东国际"</span>,</span><br><span class="line">         <span class="attr">"pincode"</span>: <span class="number">456789</span>,</span><br><span class="line">         <span class="attr">"city"</span>: <span class="string">"北京"</span>,</span><br><span class="line">         <span class="attr">"state"</span>: <span class="string">"东城"</span></span><br><span class="line">      &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上数据保存在单一的文档中，可以比较容易的获取和维护数据。这种数据结构的缺点是，如果用户和用户地址在不断增加，数据量不断变大，会影响读写性能。</p><h3 id="引用式关系"><a href="#引用式关系" class="headerlink" title="引用式关系"></a>引用式关系</h3><p>引用式关系是设计数据库时经常用到的方法，这种方法把用户数据文档和用户地址数据文档分开，通过引用文档的 <strong>id</strong> 字段来建立关系。</p><h4 id="手动引用（Manual-References）"><a href="#手动引用（Manual-References）" class="headerlink" title="手动引用（Manual References）"></a>手动引用（Manual References）</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:ObjectId(<span class="string">"5bdc18178bf520001167208b"</span>),</span><br><span class="line">   <span class="attr">"contact"</span>: <span class="string">"123456"</span>,</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">   <span class="attr">"address_ids"</span>: [</span><br><span class="line">      ObjectId(<span class="string">"52ffc4a5d85242602e000000"</span>),</span><br><span class="line">      ObjectId(<span class="string">"52ffc4a5d85242602e000001"</span>)</span><br><span class="line">   ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例中，用户文档的 <strong>address_ids</strong> 字段包含用户地址的对象id（ObjectId）数组。我们可以读取这些用户地址的对象id（ObjectId）来获取用户的详细地址信息。这种方法需要两次查询，第一次查询用户地址的对象id（ObjectId），第二次通过查询的id获取用户的详细地址信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = db.users.findOne(&#123;<span class="string">"name"</span>:<span class="string">"Tom Benzamin"</span>&#125;,&#123;<span class="string">"address_ids"</span>:<span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> addresses = db.address.find(&#123;<span class="string">"_id"</span>:&#123;<span class="string">"$in"</span>:result[<span class="string">"address_ids"</span>]&#125;&#125;)</span><br></pre></td></tr></table></figure><h4 id="DBRefs"><a href="#DBRefs" class="headerlink" title="DBRefs"></a>DBRefs</h4><p>考虑这样的一个场景，我们在不同的集合中（address_home，address_office，address_mailing等）存储不同的地址（住址，办公室地址，邮件地址等）。这样，我们在调用不同地址时，也需要指定集合，一个文档从多个集合引用文档，我们应该使用 DBRefs。</p><p>DBRef的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">$ref</span> : , <span class="attr">$id</span> : , <span class="attr">$db</span> :  &#125;</span><br></pre></td></tr></table></figure><p>三个字段表示的意义为：</p><ul><li>$ref：集合名称</li><li>$id：引用的id</li><li>$db：数据库名称，可选参数</li></ul><p>以下实例中用户数据文档使用了 DBRef, 字段 address：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span>:ObjectId(<span class="string">"5bdc18178bf520001167208b"</span>),</span><br><span class="line">   <span class="attr">"address"</span>: &#123;</span><br><span class="line">     <span class="attr">"$ref"</span>: <span class="string">"address_home"</span>,</span><br><span class="line">     <span class="attr">"$id"</span>: ObjectId(<span class="string">"534009e4d852427820000002"</span>),</span><br><span class="line">     <span class="attr">"$db"</span>: <span class="string">"runoob"</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="attr">"contact"</span>: <span class="string">"123456"</span>,</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"小明"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>address</strong> DBRef 字段指定了引用的地址文档是在 runoob 数据库下的 address_home 集合，id 为 534009e4d852427820000002。</p><p>以下代码中，我们通过指定 $ref 参数（address_home 集合）来查找集合中指定id的用户地址信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = db.users.findOne(&#123;<span class="string">"name"</span>:<span class="string">"小明"</span>&#125;)</span><br><span class="line"><span class="keyword">const</span> dbRef = user.address</span><br><span class="line">db[dbRef.$ref].findOne(&#123;<span class="string">"_id"</span>:(dbRef.$id)&#125;)</span><br></pre></td></tr></table></figure><p>以上实例返回了 address_home 集合中的地址数据：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"_id"</span> : ObjectId(<span class="string">"534009e4d852427820000002"</span>),</span><br><span class="line">   <span class="attr">"building"</span> : <span class="string">"301 A, 首东国际"</span>,</span><br><span class="line">   <span class="attr">"pincode"</span> : <span class="number">123456</span>,</span><br><span class="line">   <span class="attr">"city"</span> : <span class="string">"北京"</span>,</span><br><span class="line">   <span class="attr">"state"</span> : <span class="string">"东城"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>综上，针对过于复杂或数据量很大的字段，我们使用引用而不是内嵌。并且，从广义上讲，这些是标准化数据模型。</p><h2 id="lookup"><a href="#lookup" class="headerlink" title="$lookup"></a>$lookup</h2><p>在MongoDb 3.2之前，我们需要使用DBRefs进行引用的设置。MongoDB 3.2 中增加了$lookup，而且放到了<a href="https://docs.mongodb.com/manual/aggregation/" target="_blank" rel="noopener">Aggregation</a>（聚合）这种重量级的pipeline分析框架上。</p><p>MongoDB中Aggregation（聚合）主要用于处理数据（诸如统计平均值，求和等），并返回计算后的数据结果。有点类似sql语句中的 <code>count(*)</code>。MongoDB的聚合管道将MongoDB文档在一个管道处理完毕后将结果传递给下一个管道处理，并且管道操作是可以重复的。举例说明：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.getCollection('courses').aggregate([&#123;</span><br><span class="line">    $sort: &#123; createtime: -1 &#125;,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    $lookup: &#123;</span><br><span class="line">        from: "transcode_tasks",</span><br><span class="line">        as: "video",</span><br><span class="line">        localField: "id",</span><br><span class="line">        foreignField: "course_id",</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;,&#123;</span><br><span class="line">    $match: &#123;</span><br><span class="line">        project_id: 'f9606053-aca9-4186-880f-de1179388cbf',</span><br><span class="line">        'audit.status': &#123; $in: [0, 2] &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><p>以上语句首先声明以<code>createtime</code>倒序排列，然后以<code>courses</code>表为基础，合并了<code>transcode_tasks</code>表联合查询，作为video字段，主键为id，外键为course_id，并且加入了筛选匹配了<code>project_id</code>和<code>audit.status</code>字段。MongoDB不是一个关系型数据库，但以上我们实际上使用$lookup实现了一次左连接操作。</p><h2 id="populate"><a href="#populate" class="headerlink" title="populate"></a>populate</h2><p>Mongoose提供了node.js中优雅的mongodb对象建模方案。MongoDB在版本&gt; = 3.2中具有类似连接的$ lookup聚合运算符。而Mongoose有一个更强大的替代方法叫做<code>populate（）</code>，它允许你引用其他集合中的文档。</p><p><a href="https://mongoosejs.com/docs/populate.html" target="_blank" rel="noopener">Population</a>（填充）是使用来自其他集合的文档自动替换文档中的指定路径的过程。我们可以填充单个文档，多个文档，普通对象，多个普通对象或从查询返回的所有对象。我们来看一些例子。</p><h3 id="外键引用"><a href="#外键引用" class="headerlink" title="外键引用"></a>外键引用</h3><p>在Schema字段的定义中，可以添加<code>ref</code>属性来指向另一个Schema。 该<code>ref</code>属性在此后被填充（<a href="http://mongoosejs.com/docs/api.html#model_Model.populate" target="_blank" rel="noopener"><code>populate</code></a>）时将被读Mongoose取。 下面是存在互相引用的<code>Person</code>与<code>Story</code>的Schema定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>), Schema = mongoose.Schema</span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> personSchema = Schema(&#123;</span><br><span class="line">  <span class="comment">// _id默认为Schema.Types.ObjectId类型</span></span><br><span class="line">  _id     : <span class="built_in">Number</span>,</span><br><span class="line">  name    : <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storySchema = Schema(&#123;</span><br><span class="line">  creator : &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">ref</span>: <span class="string">'Person'</span> &#125;,</span><br><span class="line">  title    : <span class="built_in">String</span>,</span><br><span class="line">  <span class="comment">// 可以看到外键引用可以定义在嵌套的属性中。</span></span><br><span class="line">  fans     : [&#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">ref</span>: <span class="string">'Person'</span> &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Story  = mongoose.model(<span class="string">'Story'</span>, storySchema);</span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>, personSchema);</span><br></pre></td></tr></table></figure><p>外键的类型可以是<code>ObjectId</code>, <code>Number</code>, <code>String</code>, <code>Buffer</code>中任何一种，在赋值与填充时保持一致即可。</p><h3 id="保存与填充"><a href="#保存与填充" class="headerlink" title="保存与填充"></a>保存与填充</h3><p><code>Story</code>中保存<code>Person</code>对象的<code>_id</code>，此后在Query上调用<code>.populate()</code>即可用<code>Person</code>的文档来替换掉原来的字段。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> alice = <span class="keyword">new</span> Person(&#123; <span class="attr">_id</span>: <span class="number">0</span>, <span class="attr">name</span>: <span class="string">'Alice'</span>&#125;);</span><br><span class="line"># 保存其ID即可</span><br><span class="line"><span class="keyword">const</span> story = <span class="keyword">new</span> Story(&#123; <span class="attr">title</span>: <span class="string">'xx'</span>, <span class="attr">creator</span>: alice._id &#125;);</span><br><span class="line"></span><br><span class="line">Story.findOne(&#123;<span class="attr">title</span>: <span class="string">'yy'</span>&#125;)</span><br><span class="line">    .populate(<span class="string">'creator'</span>)</span><br><span class="line">    .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, story</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">console</span>.log(story.creator.name);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>更复杂的填充方式可以参考「<a href="https://harttle.land/2016/07/29/mongoose-populate.html" target="_blank" rel="noopener">在mongoose中填充外键</a>」中的介绍。</p><h3 id="动态填充"><a href="#动态填充" class="headerlink" title="动态填充"></a>动态填充</h3><p>上文中调用<code>.populate()</code>之前有一个条件：被填充的字段已被设置过<code>ref</code>选项。Mongoose会去<code>ref</code>指定的集合中去查找对应ID。 如果是动态字段怎么办？可以在填充的同时指定其<code>ref</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> studentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    _id: <span class="built_in">Number</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    teacher: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line">Student.</span><br><span class="line">    findOne(&#123; <span class="attr">name</span>: <span class="string">'Val'</span> &#125;).</span><br><span class="line">    populate(&#123;</span><br><span class="line">        path: <span class="string">'teacher'</span>,</span><br><span class="line">        model: <span class="string">'Teacher'</span>   <span class="comment">// 在User集合中查找该ID</span></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.runoob.com/mongodb/mongodb-relationships.html" target="_blank" rel="noopener">MongoDB 关系</a></p><p><a href="https://harttle.land/2016/07/29/mongoose-populate.html" target="_blank" rel="noopener">在mongoose中填充外键</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> 联表查询 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用传递和值传递总结</title>
      <link href="/posts/c92b/"/>
      <url>/posts/c92b/</url>
      
        <content type="html"><![CDATA[<p>又一个从大学开始看了又看，每次看完就忘的经典问题，总结一下。</p><a id="more"></a><h2 id="讨论之前先要搞清楚的问题"><a href="#讨论之前先要搞清楚的问题" class="headerlink" title="讨论之前先要搞清楚的问题"></a>讨论之前先要搞清楚的问题</h2><h3 id="基本类型和引用类型的区别"><a href="#基本类型和引用类型的区别" class="headerlink" title="基本类型和引用类型的区别"></a>基本类型和引用类型的区别</h3><p>基本类型（primitive types，也称值类型，基本/基础数据类型、原始数据类型）：值就直接保存在变量中。基本数据类型的值是按值访问的。</p><p>引用类型（reference types）：变量中保存的是实际对象的地址。一般称这种变量为”引用”，引用指向实际对象，实际对象中保存着内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">String str = <span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>如图所示：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101846.jpg" alt="image-20181011190327208"></p><h3 id="赋值运算符（-）的作用"><a href="#赋值运算符（-）的作用" class="headerlink" title="赋值运算符（=）的作用"></a>赋值运算符（=）的作用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">20</span>;</span><br><span class="line">str = <span class="string">"java"</span>;</span><br></pre></td></tr></table></figure><p><img src="https://images.leotian.cn/blog/2019-04-29-101847.jpg" alt="image-20181011191902401"></p><p>对于基本类型 num ，赋值运算符会直接改变变量的值，原来的值被覆盖掉。</p><p>对于引用类型 str，赋值运算符会改变引用中所保存的地址，原来的地址被覆盖掉。但是原来的对象不会被改变。</p><p>如上图所示，”hello” 字符串对象没有被改变。（没有被任何引用所指向的对象是垃圾，会被垃圾回收器回收）。</p><h3 id="本质上是求值策略问题"><a href="#本质上是求值策略问题" class="headerlink" title="本质上是求值策略问题"></a>本质上是求值策略问题</h3><p>值传递与引用传递，在计算机领域是专有名词，如果你没有专门了解过，一般很难自行悟出其含义。而且在理解下面的解释时，请不要把任何概念往你所熟悉的语言功能上套。很容易产生误解。比如Reference，请当个全新的概念，它和C#引用类型中的引用，和C++的&amp;，一点儿关系都没有。</p><h4 id="求值策略（以下参考Hugo-Gu在知乎的答案）"><a href="#求值策略（以下参考Hugo-Gu在知乎的答案）" class="headerlink" title="求值策略（以下参考Hugo Gu在知乎的答案）"></a>求值策略（以下参考<a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank" rel="noopener">Hugo Gu在知乎的答案</a>）</h4><p><strong>值传递和引用传递，属于函数调用时参数的求值策略（</strong>wiki： <a href="https://link.zhihu.com/?target=http%3A//en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="noopener">Evaluation Strategy</a>、<a href="https://zh.wikipedia.org/wiki/求值策略" target="_blank" rel="noopener">求值策略</a>），这是对调用函数时，求值和传值的方式的描述，而非传递的内容的类型**（内容指：是值类型还是引用类型，是值还是指针）。值类型/引用类型，是用于区分两种内存分配方式，值类型在调用栈上分配，引用类型在堆上分配。（不要问我引用类型里定义个值类型成员或反之会发生什么，这不在这个本文的讨论范畴内，而且你看完之后，你应该可以自己想明白）。一个描述内存分配方式，一个描述参数求值策略，两者之间无任何依赖或约束关系。</p><p>在函数调用过程中，调用方提供实参，这些实参可以是常量：<code>Call(1);</code>，也可以是变量：<code>Call(x);</code>，也可以是他们的组合：<code>Call(2 * x + 1);</code>，也可以是对其它函数的调用：<code>Call(GetNumber());</code>，但是所有这些实参的形式，都统称为表达式(Expression)。求值（Evaluation）即是指对这些表达式的简化并求解其值的过程。</p><p><strong>求值策略（值传递和引用传递）的关注的点在于，这些表达式在调用函数的过程中，求值的时机、值的形式的选取等问题</strong>。求值的时机，可以是在函数调用前，也可以是在函数调用后，由被调用者自己求值。这里所谓调用后求值，可以理解为Lazy Load（延迟加载）或On Demand（一经请求）的一种求值方式。</p><p>而且，除了值传递和引用传递，还有一些其它的求值策略。这些求值策略的划分依据是：求值的时机（调用前还是调用中）和值本身的传递方式。详见下表：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101848.jpg" alt="img"></p><p>看到这里的名传递，可能就有人联想到C++里的别名(alias)，其实也是两码事儿。语言层直接支持名传递的语言很不主流，但是在C#中，名传递的行为可以用Func<t>来模拟，说到这儿应该能大概猜出名传递的大致行为了。不过这不是重点，重点是值传递和引用传递。上面给出的传值方式的表述有些单薄，下表列出了一些二者在行为表象上的区别。</t></p><p><img src="https://images.leotian.cn/blog/2019-04-29-101849.jpg" alt="img"></p><p><strong>这里的改变不是指mutate（变动），而是change（改变）</strong>，指把一个变量指向另一个对象，而不是指仅仅改变属性或是成员什么的（如Java，所以说Java是Pass by Balue，原因是它调用时Copy，实参不能指向另一个对象，而不是因为被传递的东西本质上是个Value，这么讲计算机上什么不是Value？所以如果探究传递的内容的类型，那么很容易陷入 <em>“一切传引用其实本质上是传值“</em> 这种并不能解决问题无意义论战中）。</p><p>这些行为，与参数类型是值类型还是引用类型无关。对于值传递，无论是值类型还是引用类型，都会在调用栈上创建一个副本，不同是，对于值类型而言，这个副本就是整个原始值的复制。而对于引用类型而言，由于引用类型的实例在堆中，在栈上只有它的一个引用（一般情况下是指针），其副本也只是这个引用的复制，而不是整个原始对象的复制。</p><p><strong>这便引出了值类型和引用类型（这不是在说值传递）的最大区别：值类型用做参数会被复制，但是很多人误以为这个区别是值类型的特性。其实这是值传递带来的效果，和值类型本身没有关系。</strong>只是最终结果是这样。</p><p>求值策略定义的是函数调用时的行为，并不对具体实现方式做要求，但是指针由于其汇编级支持的特性，成为实现引用传递方式的首选。但是纯理论上，你完全可以不用指针，比如用一个全局的参数名到对象地址的HashTable来实现引用传递，只是这样效率太低，所以根本没有哪个编程语言会这样做。（自己写来模拟玩玩的不算）。</p><p>综上所述，对于Java的函数调用方式最准确的描述是：<strong>参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result（直译为求值结果，我觉得实际上是说值传递传递的是值的副本而不是值本身），第二个值是value content（值的内容））</strong>。</p><p>由于这个描述太绕，而且在字面上与Java总是传引用的事实冲突。于是对于Java，Python、Ruby、JavaScript等语言使用的这种求值策略，起了一个更贴切名字，叫<a href="https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing" target="_blank" rel="noopener">Call by sharing</a>。这个名字诞生于40年前。</p><h2 id="分语言讨论问题"><a href="#分语言讨论问题" class="headerlink" title="分语言讨论问题"></a>分语言讨论问题</h2><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByValue</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指针运算符 &amp;（取地址）返回变量的地址。例如 &amp;a; 将给出变量的实际地址。</span></span><br><span class="line"><span class="comment">但是这里的 &amp; 搭配int后不再是取地址符号，而是引用符号，变量的引用就是变量的别名。</span></span><br><span class="line"><span class="comment">讲的通俗一点就是另外一个名字，同样可以理解如果变量a是变量b的引用。</span></span><br><span class="line"><span class="comment">那么无论a，b中任何一个值改变，另外一个也相应的改变（a和b是一个内存地址）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByRef</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">指针运算符 *（指针）指向一个变量。例如，*var; 将指向变量 var。</span></span><br><span class="line"><span class="comment">* 是一元运算符，返回操作数所指定地址的变量的值。</span></span><br><span class="line"><span class="comment">而 int* a 则代表一个整型的指针，指针是一个变量，其值为另一个变量的地址。</span></span><br><span class="line"><span class="comment">即，内存位置的直接地址。Pointer即指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByPointer</span><span class="params">(<span class="keyword">int</span>* a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">*a = *a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>** args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">ByValue(v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 1, v 没有改变</span></span><br><span class="line"></span><br><span class="line">ByRef(v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by Reference</span></span><br><span class="line">ByPointer(&amp;v);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pass by Value</span></span><br><span class="line"><span class="keyword">int</span>* vp = &amp;v;</span><br><span class="line">ByPointer(vp);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出 4, 但是vp是参数, vp没有改变，仍然是值传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Main函数里的前两种方式没有什么好说，第一个是值传递，第二个函数是引用传递，但是<strong>后面两种，同一个函数，一次调用是Call by reference, 一次是Call by value</strong>。</p><p><code>ByPointer(vp);</code> 没有改变vp，其实是无法改变（只能将指针指向的地址的值改变，无法改变指针本身）。</p><p><code>ByPointer(&amp;v);</code> 改变了v。（你可能会说，这传递的其实是 v 的地址，而ByPointer无法改变 v 的地址，所以这是Call by value。这听上去可以自圆其说，但是 v 的地址，是个纯数据，在调用方的代码中并不存在，对于调用者而言，只有 v ，而 v 的确被ByPointer函数改了，这个结果，正是Call by reference的行为。<strong>从行为考虑，才是求值策略的本意。如果把所有东西都抽象成值，从数据考虑问题，那根本就没有必要引入求值策略的概念去混淆视听</strong>）。C++中指针的更多理解可以参考<a href="http://www.runoob.com/cplusplus/cpp-pointers.html" target="_blank" rel="noopener">这里</a>。</p><p>C语言不支持引用，只支持指针，但是如上文所见，使用指针的函数，不能通过签名明确其求值策略。C++引入了引用，它的求值策略可以确定是Pass by reference。于是C++的一个奇葩的地方来了，它语言本身（模拟的不算，什么都能模拟）支持Call by value和Call by reference两种求值策略，但是却提供了三种语法去做这俩事儿。</p><p>C#的设计就相对合理，函数声明里，有ref/out，就是引用传递，没有ref/out，就是值传递，与参数类型无关。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个例子：基本类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    value = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(num); <span class="comment">// num 没有被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二个例子：没有提供改变自身方法的引用类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">    text = <span class="string">"windows"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo(str); <span class="comment">// str 也没有被改变</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三个例子：提供了改变自身方法的引用类型</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.append(<span class="string">"4"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 被改变了，变成了"iphone4"。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第四个例子：提供了改变自身方法的引用类型，但是不使用，而是使用赋值运算符。</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"iphone"</span>);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder = <span class="keyword">new</span> StringBuilder(<span class="string">"ipad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(sb); <span class="comment">// sb 没有被改变，还是 "iphone"。</span></span><br></pre></td></tr></table></figure><p>同样的，前两个方法也没有什么好说的，原始值没有任何改变，Pass by value 没有任何问题。第三个例子，虽然sb被改变了，表面看是改变了原始对象，但是这种改变属于mutate（变动），而不是change（改变），也就是只改变了对象的属性，而没有把一个变量指向另一个对象。而第四个例子，虽然指向了新对象，但是不是这里改变的变量不是原始变量，而只是形参，也就是调用时产生的局部变量，所以归根结底，都属于Pass by value。</p><p>其实综合C++引用传递的实现来看，Java没有引用和指针这两种语法，也就无法实现Pass by Reference（引用传递）。不过鉴于Java中还有引用的概念，像上面讲的，就把这种调用方式或者叫求职策略称为 Call by sharing（共享调用）好了。</p><h3 id="分享传递是值传递的特殊情况"><a href="#分享传递是值传递的特殊情况" class="headerlink" title="分享传递是值传递的特殊情况"></a>分享传递是值传递的特殊情况</h3><p>刚才提到的，对于Java，Python、Ruby、JavaScript等语言使用的这种求值策略，还有一个更贴切名字，叫Call by sharing。by sharing（共享）策略在1974年为了<a href="https://en.wikipedia.org/wiki/CLU_(programming_language" target="_blank" rel="noopener">CLU</a>)编程语言被提出并被Barbara Liskov首次命名。这种策略也可以叫做”call by object（通过对象调用）” 或 “call by object-sharing（对象共享调用）“。</p><p>这个策略的主要区别是函数接收对象引用的副本（即参数的值不是直接别名，而是地址的副本）。此引用副本与形式参数关联，并且成为它的值。在这种情况下，为参数赋值新值不会影响传递的外部（在传递的是一个引用的情况下）。但是，由于形式参数仍然接收到地址，因此它可以访问原始对象的字段，并对其进行变更（mutate）。该策略假定大多数语言使用对象而不是原始值进行操作。</p><p>共享策略用于多种语言：Java，ECMAScript，Python，Ruby，Visual Basic等。</p><p>此外，在Python社区中，确切地使用了这个术语 — 通过共享。但在其他语言中，例如在Java，ECMAScript和其他语言中，这种策略也被称为值传递，意思是特殊的值 — 引用的副本。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>支持多种求值策略可以给语言带来更高的灵活性，但是同时也需要一个“灵活”的人来良好地驾驭。Java通过牺牲这种价值不大还可能带来问题的灵活性，带来了语言自身语法一致性、逻辑鲁棒性及更容易学习等多个好处。</p><p>不仅仅Java和C#，每个语言，在设计时都需要在这些特性间做出自己独特的取舍来体现自己的设计理念，并适应不同人，不同使用环境的要求。虽然说没有什么功能是一个语言可以做，而另一个语言做不了的。但是每个语言，都有它最适合的范畴与不适合的范畴。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/20628016/answer/28970414" target="_blank" rel="noopener">为什么 Java 只有值传递，但 C# 既有值传递，又有引用传递，这种语言设计有哪些好处？</a></p><p><a href="https://www.zhihu.com/question/31203609" target="_blank" rel="noopener">Java 到底是值传递还是引用传递？</a></p><p><a href="http://dmitrysoshnikov.com/ecmascript/chapter-8-evaluation-strategy/#call-by-sharing" target="_blank" rel="noopener">Evaluation strategy</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
            <tag> 经典问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近的一些思考</title>
      <link href="/posts/232a/"/>
      <url>/posts/232a/</url>
      
        <content type="html"><![CDATA[<p>刚过完国庆，时间过的很快，过年之前没有休息时间了。最近事情很多，总结一下关于工作和生活的一些想法。</p><a id="more"></a><h2 id="关于工作"><a href="#关于工作" class="headerlink" title="关于工作"></a>关于工作</h2><p>最近公司开掉了商业这边所有的产品，准备推倒重来，关于产品和技术的冲突已经持续很长时间了。但是我觉得在冲突背后，并非某些技术和某些产品的冲突，而是项目制和产品制的冲突，是资源冲突，如果把产品负责人换成别人，产品团队全部重招，很难说能多大程度的解决问题，并且很可能又遇到之前的问题。</p><p>产品经理的本职工作，是需求分析和设计，而不是售前和项目经理，不得不说之前的几个产品同事都很优秀，张诚、晓丰、还有刚离开的段芳，从他们的去向都是一线大厂也可以看出来，而在工作初期遇到他们也是我的幸运。</p><p>这些优秀的产品都渴望做设计，但是面对各种压力（可能是公司盈利方面的也可能是其他），他们的设计80%会被销售否掉，于是，要么安心当传话筒，要么离开。如果你是产品经理，你的设计总被否定，不能做自己擅长的事情，想必谁都会选择离开。他们离开之后，压力就直接给技术了。这也是之前说的，冲突的是角色，不论是谁承担这个角色。</p><blockquote><p>正式开发前的需求分析，产品设计都属于研发，只有开发没有研发的团队只能做外包</p></blockquote><p>其实定制化开发本身没有问题，但是我们如果在前进过程中丢掉了平台，丢掉了研发，那我们无疑就会变成一个外包的团队，我们拒绝了那么多微信公众号、小程序的开发，为的就是建立我们自己的平台，开发我们自己的产品，但是我觉得我们确实暂时偏离了方向。</p><p>就目前的情况来看，有不少项目在产品设计时就抛给运营了，如果按投入产出来算，技术更便宜，但是技术已经没了资源，短时间也是无法补充的，所以面临突然激增的需求和资源的不足，正如上面所说的，我们好像慢慢丢掉了研发，最终还是走上了类似外包的道路。在一个个优秀的产品离开之后，剩下的这些所谓的产品大部分是之前的运营转过来的，对产品设计了解不够，经常只专注于具体的业务，成为了销售人员的传话筒，所以技术在不停的听到为了某个项目单独开发功能的要求，再没有人分析总结需求，统一产品思路了，而我们的技术还是有一定追求的，并不想每天写重复的业务代码，所以产品化变成了一种自下而上的模式，由技术来推动，技术在工作中去分析总结哪些工作是重复的，那么这些重复的工作是不是可以统一成一个功能供所有项目使用，这对技术的负责人是一个考验，而长期这样错位的工作分散了技术人员的精力，对技术也是很难受的。</p><p>当问题复杂到一定程度，就很难用好坏对错来评判，也无法用线性思维来解决。没有人是坏人，case by case 来解问题，可能就是当下的最佳方案了。</p><p>就我自己来说，待的时间也挺长了，好好准备一下，希望年底能把工作换了，换一个环境。</p><h2 id="关于生活"><a href="#关于生活" class="headerlink" title="关于生活"></a>关于生活</h2><p>既然决定在北京，那么第一件事就是要忘掉公平这件事，人没有办法决定自己拿到的牌，这些牌包括你的出生，你的机遇，你所处时代的环境等等。最近几年的经济形势可能都不会太好，各公司都有缩招的迹象，而房价高企，生活成本倒是越来越高了。但是我们这个年代的人，步入的社会注定就是这个样子的，想太多没用，我们只能选择尽量把自己手里的牌打好，环境不好并不代表可以怨天尤人不努力了，而是让你有机会经历人生，大浪淘沙，在一个自己有热情的领域创造出更大的价值。</p><blockquote><p>世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它</p></blockquote><p>总之一句话，不要想太多，勇敢去选择热爱的生活吧。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中的this全解析</title>
      <link href="/posts/435b/"/>
      <url>/posts/435b/</url>
      
        <content type="html"><![CDATA[<p>针对this的使用已经看过好多文章，但每次遇到this还是要想半天，今天尝试总结下我们可能遇到的所有情况，不一定完善，有问题请指出。</p><a id="more"></a><h2 id="what’s-this？"><a href="#what’s-this？" class="headerlink" title="what’s this？"></a>what’s this？</h2><p>谈及 Javascript 中的 this，竟然让人觉得头疼，它不像 Java，C++ 中的 this 指向调用 this 的对象。</p><p>首先，this 是 JavaScript中的一个keyword（关键词），以下是MDN的解释。</p><blockquote><p>A <strong>function’s this keyword</strong> behaves a little differently in JavaScript compared to other languages. It also has some differences between <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/Strict_mode" target="_blank" rel="noopener">strict mode</a> and non-strict mode.</p><p>与其他语言相比，<strong>函数的 this 关键字</strong>在 JavaScript 中的表现略有不同，此外，在<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="noopener">严格模式</a>和非严格模式之间也会有一些差别。</p><p>In most cases, the value of <code>this</code> is determined by how a function is called. It can’t be set by assignment during execution, and it may be different each time the function is called. ES5 introduced the <code>bind</code> method to <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this#The_bind_method" target="_blank" rel="noopener">set the value of a function’s <code>this</code> regardless of how it’s called</a>, and ES2015 introduced <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a> which don’t provide their own <code>this</code> binding (it retains the <code>this</code> value of the enclosing lexical context).</p><p>在绝大多数情况下，函数的调用方式决定了<code>this</code>的值。<code>this</code>不能在执行期间被赋值，并且在每次函数被调用时<code>this</code>的值也可能会不同。ES5引入了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener">bind</a>方法来设置函数的<code>this</code>值，而不用考虑函数如何被调用的，ES2015 引入了支持<code>this</code>词法解析的箭头函数（它在闭合的执行上下文内设置<code>this</code>的值）。</p></blockquote><p>理解上面这段话，我们来看两个例子，第一个例子中，同一个函数由于调用方式的不同，this指向了不一样的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(); <span class="comment">// 10</span></span><br><span class="line">fn.call(obj); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure><p>除此之外，<strong>this 为保留字，你不能重写 this，也就是this一旦被确定，执行期间就不可更改了：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span> = obj; <span class="comment">// 这句话试图修改this，运行后会报错</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>接下里我们要牢记：<strong>在函数中 this 到底取何值，是在函数真正被调用执行的时候确定下来的，函数定义的时候确定不了。</strong> 也就是<strong>执行上下文被创建时确定</strong>的。因此，一个函数中的this指向，可以是非常灵活的，接下来来看我们可能会遇到的情况。</p><h2 id="全局中的this"><a href="#全局中的this" class="headerlink" title="全局中的this"></a>全局中的this</h2><p>在全局环境中，this 永远指向全局对象（宿主环境为web时即 window，在nodejs中为 global），不需过多考虑。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);     <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="普通函数中的this"><a href="#普通函数中的this" class="headerlink" title="普通函数中的this"></a>普通函数中的this</h2><p>首先我们复习一下刚才的话，<strong>在一个函数上下文中，this由调用者提供，由调用函数的方式来决定</strong>。</p><p>其次我们直接抛出结论：<strong>如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined</strong>（但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象，也就是window），从结论中我们可以看出，想要准确确定this指向，<strong>找到函数的调用者以及区分他是否是独立调用</strong>就变得十分关键。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn();  <span class="comment">// fn是调用者，独立调用</span></span><br><span class="line"><span class="built_in">window</span>.fn();  <span class="comment">// fn是调用者，被window所拥有</span></span><br></pre></td></tr></table></figure><p>在上面的简单例子中，<code>fn()</code>作为独立调用者，按照定义的理解，它内部的 this 指向就为 undefined。而<code>window.fn()</code>则因为fn被window所拥有，内部的this就指向了window对象。</p><p>掌握了这个规则大部分问题都可以解决。</p><h2 id="构造函数中的this"><a href="#构造函数中的this" class="headerlink" title="构造函数中的this"></a>构造函数中的this</h2><p>所谓的构造函数就是一种特殊的方法，主要用来在创建对象时初始化对象，一般构造函数的函数名首字母大写，例如像 Object，Function，Array 这些都属于构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的this指向了谁?</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(<span class="string">'Nick'</span>, <span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。</p><p>通过new操作符调用构造函数，会经历以下4个阶段：</p><ul><li>创建一个新的对象；</li><li>将构造函数的this指向这个新对象；</li><li>指向构造函数的代码，为这个对象添加属性，方法等；</li><li>返回新对象</li></ul><p>因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。</p><h2 id="原型上函数的this"><a href="#原型上函数的this" class="headerlink" title="原型上函数的this"></a>原型上函数的this</h2><p>原型上函数的this，其实没有什么特殊之处。在下面的例子中，借用我们上面的规则，<code>foo.getX()</code>中getX为调用者，他被foo所有，因此getX中的 this 指向了foo对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.x = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getX = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);        <span class="comment">//Foo &#123;x: 10, getX: function&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);      <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.getX();</span><br></pre></td></tr></table></figure><h2 id="箭头函数中的this"><a href="#箭头函数中的this" class="headerlink" title="箭头函数中的this"></a>箭头函数中的this</h2><p><strong>箭头函数本身没有this，需要通过查找作用域链来确定 this 的值</strong>。</p><p>这就意味着如果箭头函数被非箭头函数包含，this 绑定的就是最近一层非箭头函数的 this。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">10</span>,</span><br><span class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>);    <span class="comment">// Object &#123;x: 10&#125;</span></span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);  <span class="comment">//10</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fn()()();</span><br><span class="line">        fn.bind(&#123;<span class="attr">x</span>: <span class="number">14</span>&#125;)()()();</span><br><span class="line">        fn.call(&#123;<span class="attr">x</span>: <span class="number">14</span>&#125;)()();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br></pre></td></tr></table></figure><p>所以，用 call() 或者 apply() 调用箭头函数时，无法对 this 进行绑定，即传入的第一个参数被忽略。</p><p>如果使用箭头函数，以前的这种 hack 写法：<code>var self = this</code> ，就不再需要了。</p><h2 id="使用call、apply或bind显示指定this"><a href="#使用call、apply或bind显示指定this" class="headerlink" title="使用call、apply或bind显示指定this"></a>使用call、apply或bind显示指定this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    x: <span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);     <span class="comment">//&#123;x: 10&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);   <span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj);</span><br><span class="line">foo.apply(obj);</span><br><span class="line">foo.bind(obj)();</span><br></pre></td></tr></table></figure><p>JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。</p><p>call()、apply()可以改变函数运行时的执行环境，foo.call()、foo.apply()这样的语句可以看作执行foo()，只不过foo()中的this指向了后面的第一个参数。 </p><p>foo.bind({a:1})却并不如此，执行该条语句仅仅得到了一个新的函数，新函数的this被绑定到了后面的第一个参数，亦即新的函数并没有执行。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信企业号加密方法分析</title>
      <link href="/posts/c769/"/>
      <url>/posts/c769/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>程序中的时间问题总结</title>
      <link href="/posts/bb9f/"/>
      <url>/posts/bb9f/</url>
      
        <content type="html"><![CDATA[<p>日期和时间在程序中应用广泛，但是，一旦涉及到跨时区的日期和时间的处理时，大多数人总还是不明白如何正确地处理日期和时间，今天总结一下。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101927.jpg" alt="image-20181211171522136"></p><a id="more"></a><h2 id="常用概念"><a href="#常用概念" class="headerlink" title="常用概念"></a>常用概念</h2><h3 id="GMT和UT时间"><a href="#GMT和UT时间" class="headerlink" title="GMT和UT时间"></a>GMT和UT时间</h3><p>格林尼治标准时间（英语：Greenwich Mean Time，GMT）是指位于英国伦敦郊区的皇家格林尼治天文台当地的平太阳时，因为本初子午线被定义为通过那里的经线。</p><p>UT（世界时）和GMT（格林威治标准时）是相同的时间标准，都是基于天体观察的。UT 是相同标准的“科学”名称。GMT：格林威治时间，是标准的“民间”名称。因此，格林威治标准时（GMT）和世界时 (UT) 是相等的。</p><p>由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治平时基于天文观测本身的缺陷，已经被原子钟报时的协调世界时（UTC）所取代。</p><h3 id="UTC时间"><a href="#UTC时间" class="headerlink" title="UTC时间"></a>UTC时间</h3><p>协调世界时（英语：Coordinated Universal Time，法语：Temps Universel Coordonné，简称UTC）是最主要的世界时间标准，其以原子时秒长为基础。在时刻上尽量接近于世界时（UT）的一种时间计量系统。</p><p>对于大多数用途来说，UTC时间被认为能与GMT时间互换，但GMT时间已不再被科学界所确定。</p><h3 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h3><p>各个国家分布在地球的不同位置上，因此不同国家的日出、正午、日落时间可能有所偏差，在现实生活中，人们更关注本地时间（Localtime），因为和 UTC 相比，本地时间更适合用于当地的生产和生活。1863 年，<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA" target="_blank" rel="noopener">时区</a>的概念被首次提出，它以区域为范围设定标准时间，某地的本地时间通常指该地所在时区的标准时间。理论时区以被 15 整除的子午线为中心，向东西两侧延伸 7.5 度，即每 15 度划分一个时区，这是理论时区。但是，为了避开国界线，有的时区的形状并不规则，而且比较大的国家以国家内部行政分界线为时区界线，这是实际时区，即法定时区。</p><h3 id="CST时间"><a href="#CST时间" class="headerlink" title="CST时间"></a>CST时间</h3><p>北京时间，又名中国标准时间，是中国大陆的标准时间，从时区上来讲，北京位于东八区，故其时区为 UTC+8（或GMT +8），北京时间比格林威治标准时间早 8 小时，即比协调世界时快八小时（也即UTC+8），与香港、澳门、台北、吉隆坡、新加坡等地的标准时间相同。</p><h3 id="时区表示法"><a href="#时区表示法" class="headerlink" title="时区表示法"></a>时区表示法</h3><p>参考ISO_8601日期格式标准<a href="https://zh.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO_8601日期格式标准</a>：</p><ul><li>如果时间在零时区，并恰好与<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">协调世界时</a>相同（UTC时间也叫祖鲁时间，北约音标字母中用“Zulu”表示“Z”），那么（不加空格地）在时间最后加一个大写字母Z。Z是相对<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="noopener">协调世界时</a>时间0偏移的代号，如下午2点30分5秒表示为<strong>14:30:05Z</strong>或<strong>143005Z；只表示</strong>小时和分，为1430Z或14:30Z；只表示小时，则为14Z或14Z。</li><li>其他<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA" target="_blank" rel="noopener">时区</a>用实际时间加时差表示，当时的UTC+8时间表示为<strong>22:30:05+08:00</strong>或<strong>223005+0800</strong>，也可以简化成<strong>223005+08</strong>。</li><li>合并表示时，要在时间前面加一大写字母T，如要表示北京时间2004年5月3日下午5点30分8秒，可以写成<strong>2004-05-03T17:30:08+08:00</strong>或<strong>20040503T173008+08</strong>。</li></ul><h3 id="更多（不需要掌握）"><a href="#更多（不需要掌握）" class="headerlink" title="更多（不需要掌握）"></a>更多（不需要掌握）</h3><p><strong>CST</strong>：实际上，CST可以同时代表以下 4 个不同的时区，不过我们使用默认为中国标准时间。</p><ul><li>Central Standard Time (USA) UT-6:00</li><li>Central Standard Time (Australia) UT+9:30</li><li>China Standard Time UT+8:00</li><li>Cuba Standard Time UT-4:00</li></ul><p><strong>闰秒</strong>：是指为保持协调世界时（UTC）接近于世界时时刻（UT），由国际计量局统一规定在年底或年中（也可能在季末）对协调世界时增加或减少1<strong>秒</strong>的调整，操作系统会进行处理，对程序员应该<a href="https://www.zhihu.com/question/27500849" target="_blank" rel="noopener">影响不大</a>。</p><p><strong>DST</strong>：<a href="https://zh.wikipedia.org/wiki/%E5%A4%8F%E6%97%B6%E5%88%B6" target="_blank" rel="noopener">夏令时(Summer Time)</a> 又称日光节约时制或日光节约时间，是一种为节约能源而人为规定地方时间的制度。一般在天亮较早的夏季人为将时间调快一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。各个采纳夏时制的国家具体规定不同，目前全世界有近 110 个国家每年要实行夏令时，如美国、欧盟等；中国、日本等国家曾经实行过夏令时，但是目前不予实行。</p><h2 id="程序员用到的时间"><a href="#程序员用到的时间" class="headerlink" title="程序员用到的时间"></a>程序员用到的时间</h2><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="Unix-时间"><a href="#Unix-时间" class="headerlink" title="Unix 时间"></a>Unix 时间</h4><p><a href="https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">Unix 时间</a>又称 Posix 时间，UNIX时间戳是程序中最常用的，指自 UTC 时间 1970 年 1 月 1 日 0 时 0 分 0 秒起值现在的总秒数。是 Unix 和 类 Unix 系统使用的表达方式，他的特点是<strong>和时区无关，无论在地球上的那个角落，同一时刻，UNIX时间戳都是一样的</strong>。所以可以作为一个通用的时间偏移度量，计算每个时区当地时间时，都可以用时间戳推算出来。，可用 <code>date +%s</code> 查看 Unix 时间：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101928.jpg" alt="image-20181211180804328"></p><p>由上可知，Unix 时间 1479655113 表示的日期为 Sun Nov 20 15:18:33 UTC 2016。</p><p>现在有些系统采用 32 位有符号整数保存 Unix 时间，所以它最多只能表示 136 年，即：1901-12-13 20:45:52 至 2038-1-19 3:14:07。和 <a href="https://zh.wikipedia.org/wiki/2000%E5%B9%B4%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">千年虫问题</a> 类似，32 位 Unix/Linux 的系统在 2038 年可能会发生故障，所以又叫<a href="https://zh.wikipedia.org/wiki/UNIX%E6%97%B6%E9%97%B4#2038%E5%B9%B4%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">2038年问题</a>。</p><h4 id="时区信息数据库"><a href="#时区信息数据库" class="headerlink" title="时区信息数据库"></a>时区信息数据库</h4><p>我们经常会看到这样的时区表示：”Asia/Shanghai”，这些信息就是保存在<a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%8C%BA%E4%BF%A1%E6%81%AF%E6%95%B0%E6%8D%AE%E5%BA%93" target="_blank" rel="noopener">时区信息数据库</a>里面的。Ubuntu安装命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEBIAN_FRONTEND=noninteractive(非交互安装) &amp;&amp; apt-get install -y tzdata</span><br></pre></td></tr></table></figure><h4 id="硬件时钟"><a href="#硬件时钟" class="headerlink" title="硬件时钟"></a>硬件时钟</h4><p>硬件时钟也叫RTC（Real Time Clock）或者CMOS时钟，这个是保存在BIOS中的，由主板电池供电来维持运行，系统开机时要读取这个时间，并根据它来设定系统时间。仅能保存：年、月、日、时、分、秒这些时间数值，无法保存当前时区以及是否使用夏令时调节。所以BIOS时间即硬件时间没有时区。</p><h4 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h4><p>系统时钟也叫软件时钟，在系统时钟里是有时区等概念的，在Linux内核里，是保存为自 UTC 时间 1970 年1月1日经过的秒数。系统启动时会读取硬件时钟，并根据<code>/etc/adjtime</code>的设置计算当前的时钟。系统启动之后，系统时钟与硬件时钟独立运行，Linux 通过时钟中断计数维护系统时钟。一般说来就是我们执行 date 命令看到的时间，linux系统下所有的时间调用（除了直接访问硬件时间的命令）都是使用的这个时间。</p><h4 id="etc-localtime"><a href="#etc-localtime" class="headerlink" title="/etc/localtime"></a>/etc/localtime</h4><p>这个文件一般情况下是一个软链接，链接到<code>/usr/share/zoneinfo/</code>目录下的一个对应时区的二进制文件，比如设置<code>Asia/Shanghai</code>的时区，则<code>/etc/localtime -&gt; /usr/share/zoneinfo/Asia/Shanghai</code>，调用<code>date</code>等工具获取时间时会考虑这个配置。建议并强烈建议将这个文件设置为软链接，很多人会直接拷贝文件，其实是不推荐的。所有的Linux系统都会依赖这个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><h4 id="etc-timezone"><a href="#etc-timezone" class="headerlink" title="/etc/timezone"></a>/etc/timezone</h4><p>这个文件一般会记录时区的直接文字表示，或者是一个时间偏移（很少见），比如如果设置时区为<code>Asia/Shanghai</code>，则这个文件的内容就会是<code>Asia/Shanghai</code>。这个文件并不是在所有Linux中都存在。这个文件一般也仅仅是一个简单的表示（所以好像改了localtime就行）。</p><p>tip：<a href="https://unix.stackexchange.com/questions/384971/whats-the-difference-between-localtime-and-timezone-files" target="_blank" rel="noopener">What’s the difference between localtime and timezone files?</a></p><h3 id="程序和数据库中"><a href="#程序和数据库中" class="headerlink" title="程序和数据库中"></a>程序和数据库中</h3><p>基于“数据的存储和显示相分离”的设计原则，我们只要把表示绝对时间的时间戳（无论是Long型还是Float）存入数据库，在显示的时候根据用户设置的时区格式化为正确的字符串即可。想了解更多可以看下廖雪峰的这篇<a href="https://www.liaoxuefeng.com/article/0014132675721847f569c3514034f099477472c73b5dee2000" target="_blank" rel="noopener">文章</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 编程基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从使用autoprefixer遇到的一个小问题说起</title>
      <link href="/posts/6a81/"/>
      <url>/posts/6a81/</url>
      
        <content type="html"><![CDATA[<p>最近一直在写应用里的webview项目，使用webpack打包前端代码时遇到了一个小问题，具体来讲是<code>autoprefixer</code>的问题，记录一下。</p><a id="more"></a><p>遇到的问题是一个样式在页面写好，结果qa打包出的结果里一直没有这个样式，具体情况是这样的：</p><h2 id="要实现的和遇到的问题"><a href="#要实现的和遇到的问题" class="headerlink" title="要实现的和遇到的问题"></a>要实现的和遇到的问题</h2><p>简单讲就是溢出文本显示省略号，如果是单行文本可以直接使用<code>text-overflow:ellipsis</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure><p>但是这个属性并不支持多行文本溢出显示省略号，而针对移动端绝大部分是WebKit内核的浏览器，页面实现也比较简单，可以直接使用WebKit的CSS扩展属性（WebKit是私有属性）<code>-webkit-line-clamp</code> ；注意：这是一个 不规范的属性（<a href="http://developer.apple.com/safari/library/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/doc/uid/TP30001266-UnsupportedProperties" target="_blank" rel="noopener">unsupported WebKit property</a>），它没有出现在 CSS 规范草案中。</p><p><code>-webkit-line-clamp</code>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：</p><ol><li><code>display: -webkit-box;</code> 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</li><li><code>-webkit-box-orient</code> 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</li><li><code>text-overflow: ellipsis;</code>，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 。</li></ol><p>所以可以这样写：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span> : <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 2;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure><p>但是发现webpack编译以后，<code>-webkit-box-orient: vertical</code>检查元素样式并没有这个属性，其他的几个属性都有，现在只有把这个属性放入内联样式才行。</p><h2 id="关于autoprefixer"><a href="#关于autoprefixer" class="headerlink" title="关于autoprefixer"></a>关于autoprefixer</h2><p>查了查发现这个样式会被干掉，干掉他的是正是<code>autoprefixer</code>，而干掉的理由也是李菊福的，以下是<code>autoprefixer</code>作者Andrey Sitnik（同时创作了<code>PostCSS</code>）给出的解释：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101951.jpg" alt="27F3AD95-3C53-4045-97C9-05B732BC45D5"></p><p>按照这位大神接下来的说法，最好的解决方法是：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101952.jpg" alt="2FA6FCEC-BA24-4B84-A732-50CCE5B10FA2"></p><p>然鹅我并不想因为一个属性增加太多复杂性，所以找了一种简单的方法hack了这个问题：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* autoprefixer: off */</span></span><br><span class="line"><span class="comment">/* stylelint-disable */</span></span><br><span class="line">-webkit-box-orient: vertical;</span><br><span class="line"><span class="attribute">display</span>: -webkit-box;</span><br><span class="line"><span class="comment">/* autoprefixer: on */</span></span><br><span class="line"><span class="comment">/* stylelint-enable */</span></span><br></pre></td></tr></table></figure><p>是的，我直接用注释把<code>autoprefixer</code>关了，然后<code>stylelint</code>又报错，我又不得不把他也关了，大神不太推荐这种做法，不过我感觉还OK，而且挺多人这么搞的🤣。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101953.jpg" alt="0A16AE75-137F-4B0C-A0DA-88A496484EDE"></p><h2 id="疑惑之处"><a href="#疑惑之处" class="headerlink" title="疑惑之处"></a>疑惑之处</h2><p>最后在此位置关闭<code>autoprefixer</code>发现确实有效，但是还有个让我困惑的地方，那就是为什么我本地的dev环境没有问题，到了qa就有问题了呢？也就是经过build的代码是有问题的，这显然应该跟qa环境的webpack配置有关，经过对比我把目标锁定在了<code>optimize-css-assets-webpack-plugin</code>这个插件。</p><p>查阅 <a href="https://github.com/NMFR/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener">optimize-css-assets-webpack-plugin</a> 文档：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101954.jpg" alt="7FF418BC-23E0-4EA1-85D2-98EFCDAE48FC"></p><p>意思是说，啥都没做，只是把 <code>cssProcessorOptions</code> 的配置传给处理器 <code>cssProcessor</code> ，默认为<code>cssnano</code>来优化css，而<code>cssnano</code>内部自然又调用了<code>autoprefixer</code>。</p><p>再查阅 <a href="http://cssnano.co/guides/optimisations/" target="_blank" rel="noopener">cssnano</a> 文档，可以看到，默认情况下，<code>autoprefixer</code> 是不开启的，但是在项目中莫名其妙默认开启了。仔细检查了下，项目中使用的 <code>cssnano</code> 是 3.10.0 版本。也就是说，v3 系列默认都是开启的，文档看的是 v4 的。可以参考这个 <a href="https://github.com/ben-eb/cssnano/issues/358" target="_blank" rel="noopener">issue</a>。如果在参数里面加上 <code>safe/isSafe</code> 字段，也可以解决此问题。</p><p>但是，等等。我明明已经加了safe了好吗？所以说不应该啊，难道我误会了这个插件？然后继续看还有哪些包引用了<code>autoprefixer</code>，结果如下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101956.jpg" alt="FD571AC2-EAB0-40DF-9293-F5260F986DA5"></p><p>看来就是<code>css-loader</code>无疑了，看了下<code>.postcssrc.js</code>确实引用了<code>autoprefixer</code>作为插件，遂删除重新构建，属性正常了，没有被删除，果然是这个浓眉大眼的家伙叛变了革命。但是为什么本地环境没有问题，到了qa就有问题了呢，我试了下把<code>autoprefixer</code>的<code>remove</code>属性配置为false，果然没有再删除我的属性了。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101957.jpg" alt="D5C61F5C-5C5C-4B1A-9B00-30780D5176A8"></p><p>我又分别看了下本地和qa环境<code>autoprefixer</code>的版本，发现一致，并且自动添加前缀，兼容浏览器的功能是生效的，但在qa环境build和在本地使用<code>webpack-dev-middleware</code>或build产生的结果就是不同的，我想还是可能跟某个依赖版本有关系吧，于是我生成了<code>shrinkwrap.json</code>，在qa上又了一版，果然跟本地表现一致了，所以还是跟某个依赖的版本有关，具体哪个不细究了，侧面证明了版本锁的重要性，npm 5大法好，问题暂时告一段落。</p><h2 id="关于loader和plugin"><a href="#关于loader和plugin" class="headerlink" title="关于loader和plugin"></a>关于loader和plugin</h2><p><code>autoprefixer</code>的作用，官方解释：<code>Parse CSS and add vendor prefixes to CSS rules using values from the Can I Use website</code>，也就是说它是一个自动检测兼容性给各个浏览器加个内核前缀的插件。<code>autoprefixer</code>算是<code>PostCSS</code>的插件，但不是webpack的。</p><p>恰逢组里webpack分享，简单学习了一些webpack中lodaer和plugin的知识，对于lodaer和plugin的区别，简单版本：</p><ul><li>Loader：模块转换器，用于把模块原内容按照需求转换成新内容（例如使用<code>babel-loader</code>将前端js代码从ES6转到ES5）。</li><li>Plugin：扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。</li></ul><p>更详细的下次再写。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.css88.com/archives/5206" target="_blank" rel="noopener">多行文本溢出显示省略号(…)全攻略</a></p><p><a href="https://github.com/postcss/autoprefixer/issues/776" target="_blank" rel="noopener">https://github.com/postcss/autoprefixer/issues/776</a></p><p><a href="http://www.yukapril.com/2018/02/10/less-zindex.html" target="_blank" rel="noopener">使用 webpack 编译 less 后 z-index 值改变处理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> webpack </tag>
            
            <tag> postcss </tag>
            
            <tag> autoprefixer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ios下使用iframe遇到的问题</title>
      <link href="/posts/d267/"/>
      <url>/posts/d267/</url>
      
        <content type="html"><![CDATA[<p>最近在ios下使用iframe遇到一些问题，刚开始是载入后不能滑动，然后是点击首屏以下的按钮或输入框时回闪到页面顶部，这里记录一下解决方法。</p><a id="more"></a><h3 id="不能滑动"><a href="#不能滑动" class="headerlink" title="不能滑动"></a>不能滑动</h3><p>通过外层套一个div解决，并且内层外层都要设置overflow</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height:100%; -webkit-overflow-scrolling:touch; overflow-y:auto"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"iframePage"</span> <span class="attr">style</span>=<span class="string">"overflow-y:auto; width:100%"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="闪烁问题"><a href="#闪烁问题" class="headerlink" title="闪烁问题"></a>闪烁问题</h3><p>在iframe页面加载完成后，获取加载的外部链接的body高度来设置Iframe的高度（注意跨域的话不就不好获取了，我做了一层代理解决跨域问题）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframePage = <span class="built_in">document</span>.getElementById(<span class="string">"iframePage"</span>);</span><br><span class="line">iframePage.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> iframeHeight = $(<span class="string">"#iframePage"</span>).contents().find(<span class="string">"body"</span>).height();</span><br><span class="line">  <span class="comment">//原生使用 iframePage.contentDocument.body.clientHeight 获取高度</span></span><br><span class="line">  $(<span class="string">"#iframePage"</span>).height(iframeHeight);</span><br><span class="line">  <span class="comment">//原生使用 iframePage.style.height 设置高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> ios </tag>
            
            <tag> iframe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs的几种文件路径</title>
      <link href="/posts/25df/"/>
      <url>/posts/25df/</url>
      
        <content type="html"><![CDATA[<p>上次写删除文件夹的时候用到了<code>fs</code>模块，也集中用到了很多种路径，当时就想写一下，在Node中使用各种路径的问题，于是就简单写了一下，可以从 <a href="https://github.com/leotian/path-test" target="_blank" rel="noopener">这里</a> 获取demo源代码。</p><a id="more"></a><p>刚写Node的时候经常会遇到这种情况：比如项目入口是<code>app.js</code>，而<code>app.js</code>并不一定在根目录下，比如他在<code>bin</code>目录下，到了启动项目时，使用<code>node /bin/app.js</code>和进入<code>bin</code>文件夹直接<code>node app.js</code>总会有一个起不起来，都是些路径找不到的错误，究其原因就是启动应用时执行的目录不同了，不过为什么启动脚本的位置会有这么多影响呢，让我们来总结一下。</p><h2 id="对比常用的几种路径"><a href="#对比常用的几种路径" class="headerlink" title="对比常用的几种路径"></a>对比常用的几种路径</h2><p>Node 中的文件路径大概有 <code>__dirname</code>，<code>__filename</code>，<code>process.cwd()</code>，<code>./</code> 或者 <code>../</code>。前三个都是绝对路径，为了便于比较，<code>./</code> 和 <code>../</code> 我们通过 <code>path.resolve(&#39;./&#39;)</code>来转换为绝对路径。先看一个简单的例子。</p><p>假如我们有这样的文件结构：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101852.jpg" alt="B0903800-AC17-4F20-961B-7A07D13942F9"></p><p>在 <code>server.js</code> 里编写如下的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(__dirname);</span><br><span class="line"><span class="built_in">console</span>.log(__filename);</span><br><span class="line"><span class="built_in">console</span>.log(process.cwd());</span><br><span class="line"><span class="built_in">console</span>.log(path.resolve(<span class="string">'./'</span>));</span><br></pre></td></tr></table></figure><p>在 <code>path-test</code> 目录下运行 <code>node bin/server.js</code> 得到的结果：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101854.jpg" alt="A384F0C7-7DCF-49C9-9F35-4C5973245C62"></p><p>进入 <code>bin</code> 目录下运行 <code>node server.js</code> 得到的结果：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101855.jpg" alt="B3CDC14D-1B0A-430C-A8F0-1C447A8E8981"></p><p>现在我们可以总结下这几个路径的意思：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__dirname：    Nodejs的一个全局变量，获得当前执行文件所在目录的完整目录名</span><br><span class="line">__filename：   Nodejs的一个全局变量，获得当前执行文件的带有完整绝对路径的文件名</span><br><span class="line">process.cwd()：Nodejs的全局变量process的一个方法，返回当前进程的工作目录</span><br><span class="line">./：           一般情况跟 process.cwd() 一样，返回 node 命令运行时所在的文件夹的绝对路径</span><br></pre></td></tr></table></figure><p>注意<code>__dirname</code>得到的目录和命令执行所在的目录、<code>__filename</code>得到的文件名和参数指定的文件名都不一定相同，因为可能在一个文件中调用了另一个目录中的另一个文件。</p><h2 id="更复杂的情况"><a href="#更复杂的情况" class="headerlink" title="更复杂的情况"></a>更复杂的情况</h2><p>我们把例子升级一下，在<code>bin</code>目录下新建一个<code>test.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./server.js'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./server.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> <span class="built_in">console</span>.log(err);</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>现在目录结构如下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101856.jpg" alt="F8DE8DD3-DA17-4144-99B5-8012BF83ADC8"></p><p>我们这次先进入<code>bin</code>目录执行<code>node test.js</code>，得到的结果：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101857.jpg" alt="6D160866-8F82-4F81-B05C-AB3B34F3CF86"></p><p>可以看到是正常的，然后我们退出<code>bin</code>目录，在上一级执行<code>node bin/test.js</code>，得到结果：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101858.jpg" alt="54CF6CF2-BA04-4103-968A-1838AACD40F3"></p><p>我们可以看到报错了，但是<code>require</code>是OK的，只是<code>fs.readFile</code>时路径出现了错误。从第一个例子我们可以知道，使用相对路径出现错误是预期之内的，因为在<code>bin</code>目录外执行时目录下已经没有<code>server.js</code>这个文件了，但是为什么在<code>require</code>中使用相对路径，就不受启动应用时执行命令目录不同的影响呢？实际上是<code>require</code>有自己的搜索机制，具体可以看<a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">require() 源码解读</a>。</p><h2 id="使用path模块处理文件路径"><a href="#使用path模块处理文件路径" class="headerlink" title="使用path模块处理文件路径"></a>使用path模块处理文件路径</h2><p>面对复杂的路径问题，path模块可以帮你规范化连接和解析路径，还可以用于绝对路径到对路径的转换、提取路径的组成部分及判断路径是否存在等。常用的两个命令：</p><h3 id="path-join"><a href="#path-join" class="headerlink" title="path.join"></a>path.join</h3><p>path.join()方法可以连接任意多个路径字符串，只是简单的连接，不会看是否真的存在。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">//合法的字符串连接</span></span><br><span class="line">path.join(<span class="string">'/foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz/asdf'</span>, <span class="string">'quux'</span>, <span class="string">'..'</span>)</span><br><span class="line"><span class="comment">// 连接后</span></span><br><span class="line"><span class="string">'/foo/bar/baz/asdf'</span></span><br></pre></td></tr></table></figure><h3 id="path-resolve"><a href="#path-resolve" class="headerlink" title="path.resolve"></a>path.resolve</h3><p>path.resolve()方法可以将多个路径解析为一个规范化的绝对路径。其处理方式类似于对这些路径逐一进行cd操作，与cd操作不同的是，这引起路径可以是文件，并且可不必实际存在（resolve()方法不会利用底层的文件系统判断路径是否存在，而只是进行路径字符串操作）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'foo/bar'</span>, <span class="string">'/tmp/file/'</span>, <span class="string">'..'</span>, <span class="string">'a/../subfile'</span>)</span><br></pre></td></tr></table></figure><p>其处理方式类型于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd foo/bar</span><br><span class="line">cd /tmp/file/</span><br><span class="line">cd ..</span><br><span class="line">cd a/../subfile</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure><p>如果解析的不是绝对路径，path.resolve()会将<strong>当前工作目录</strong>（非进程工作目录）加到解析结果的前面。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>)</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="string">'/foo/bar/baz'</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>)</span><br><span class="line"><span class="comment">// 输出结果为</span></span><br><span class="line"><span class="string">'/tmp/file'</span></span><br><span class="line"></span><br><span class="line">path.resolve(<span class="string">'wwwroot'</span>, <span class="string">'static_files/png/'</span>, <span class="string">'../gif/image.gif'</span>)</span><br><span class="line"><span class="comment">// 当前的工作路径是 /Users/tyb/workspace/NodeJs/path-test/bin，则输出结果为</span></span><br><span class="line"><span class="string">'/Users/tyb/workspace/NodeJs/path-test/bin/wwwroot/static_files/gif/image.gif'</span></span><br></pre></td></tr></table></figure><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><ol><li>join只是把各个path片段连接在一起， resolve会把‘／’当成根目录</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">'/a'</span>, <span class="string">'/b'</span>)    <span class="comment">// 返回 '/a/b'</span></span><br><span class="line">path.resolve(<span class="string">'/a'</span>, <span class="string">'/b'</span>) <span class="comment">// 返回 '/b'</span></span><br></pre></td></tr></table></figure><ol start="2"><li>join直接拼接字段，resolve解析路径，如果解析的不是绝对路径，会在前面增加当前文件所在的目录</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path.join(<span class="string">"a"</span>, <span class="string">"b1"</span>, <span class="string">".."</span>, <span class="string">"b2"</span>)    <span class="comment">// 返回 'a/b2'</span></span><br><span class="line">path.resolve(<span class="string">"a"</span>, <span class="string">"b1"</span>, <span class="string">".."</span>, <span class="string">"b2"</span>) <span class="comment">// 返回 '/Users/tyb/workspace/NodeJs/path-test/bin/a/b2'</span></span><br></pre></td></tr></table></figure><h3 id="相同之处"><a href="#相同之处" class="headerlink" title="相同之处"></a>相同之处</h3><ol><li>都会规范化路径</li><li>都不会去验证路径是否真的存在</li></ol><h2 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h2><p>最好只在 <code>require()</code> 时才使用相对路径<code>./</code>或者<code></code>../<code>的写法，其他地方一律配合</code>path`模块使用绝对路径。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/imsobear/blog/issues/48" target="_blank" rel="noopener">浅析 NodeJs 的几种文件路径</a></p><p><a href="https://github.com/jawil/blog/issues/18" target="_blank" rel="noopener">Node.js的<strong>dirname，</strong>filename，process.cwd()，./的一些坑</a></p><p><a href="https://itbilu.com/nodejs/core/NJHZjdRN.html" target="_blank" rel="noopener">Node.js使用path模块处理文件路径</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> path </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PWA入门实践</title>
      <link href="/posts/26fe/"/>
      <url>/posts/26fe/</url>
      
        <content type="html"><![CDATA[<p>Progressive Web Apps 是 Google 提出的，用前沿的 Web 技术在网页中实现和原生应用相近的用户体验的一系列方案。网上的介绍已经够多了，贴了几个链接可以先自己了解下。这篇文章通过改造我的博客来介绍其中的关键技术。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102047.jpg" alt="6BC9FE87-7F63-4971-81D7-197E7FFBCF95"></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>网上的介绍已经够多了，这里放两个链接可以自己了解下。</p><p><a href="https://zhuanlan.zhihu.com/p/22578965" target="_blank" rel="noopener">PWA是什么和PWA的优势</a></p><p><a href="https://lavas.baidu.com/ready" target="_blank" rel="noopener">PWA兼容性</a></p><h1 id="三大核心技术"><a href="#三大核心技术" class="headerlink" title="三大核心技术"></a>三大核心技术</h1><p>一个 PWA 应用首先是一个网页，可以通过 Web 技术编写出一个网页应用，随后添加上 App Manifest 和 Service Worker 来实现 PWA 的安装和离线缓存功能，再加上Push Notification实现推送，妥妥的变成了一个Native APP。接下来我将通过把我的Hexo博客改造成一个PWA应用，介绍其中的关键技术。</p><h2 id="App-Manifest"><a href="#App-Manifest" class="headerlink" title="App Manifest"></a>App Manifest</h2><p>我们从最简单的开始，我们需要在Hexo的根目录中增加一个manifest.json文件。下面给出我博客中使用的配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"天生爱走神"</span>,</span><br><span class="line">  <span class="attr">"short_name"</span>: <span class="string">"走神PWA版"</span>,</span><br><span class="line">  <span class="attr">"theme_color"</span>: <span class="string">"#2196f3"</span>,</span><br><span class="line">  <span class="attr">"background_color"</span>: <span class="string">"#2196f3"</span>,</span><br><span class="line">  <span class="attr">"display"</span>: <span class="string">"standalone"</span>,</span><br><span class="line">  <span class="attr">"Scope"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"start_url"</span>: <span class="string">"/"</span>,</span><br><span class="line">  <span class="attr">"icons"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"src"</span>: <span class="string">"images/icons/icon-72x72.png"</span>,</span><br><span class="line">      <span class="attr">"sizes"</span>: <span class="string">"72x72"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"image/png"</span></span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>详细的参数和说明可以参考<a href="https://developers.google.com/web/fundamentals/web-app-manifest/?hl=zh-cn" target="_blank" rel="noopener">这里</a>或者<a href="https://developer.mozilla.org/en-US/docs/Web/Manifest" target="_blank" rel="noopener">这里</a>。你需要将创建这个文件到<strong>source</strong>目录下。如何快速生成manifest文件呢？推荐两款工具：<a href="https://app-manifest.firebaseapp.com/" target="_blank" rel="noopener">App Manifest Generator</a> 和 <a href="http://www.manifoldjs.com/generator" target="_blank" rel="noopener">manifoldjs.com</a>，这两个网站可以引导我们快速创建。</p><p>相关的icon图片放在博客的<strong>source/images/icons</strong>目录下就可以。没有这个目录就创建一个，记得要和manifest.json中的icon路径匹配。</p><p>Manifest.json文件需要在head标签里引用，我使用的是next主题，所以我在<strong>layout/_partials/head.swing</strong>文件中添加一句代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"manifest"</span> <span class="attr">href</span>=<span class="string">"/manifest.json"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果不是next主题，就自己找下位置吧。配置好manifest后，我用hexo进行了部署，并从豌豆荚下载了最新的移动版Chrome，然后使用添加到主屏幕功能，成功的将我的网站添加到了桌面，效果如下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102048.jpg" alt="ADDD97FE-A10B-47C4-A816-3EA0296E9895"></p><h2 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h2><p>现在我们来考虑实现一个Service Worker，Google官方提供了一个Service Worker的<a href="https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker/basic" target="_blank" rel="noopener">示例项目</a>，这是一个手动实现的基础例子。借助工具我们有sw-toolbox和sw-precache，配合gulp和webpack我们可以定制缓存策略并生成ServiceWorker。而对于Hexo，最简单的方法是借助插件<a href="https://github.com/JLHwung/hexo-offline" target="_blank" rel="noopener">hexo-offline</a>，该插件可以帮助我们生成ServiceWoker，据了解<a href="https://github.com/vuejs/vuejs.org" target="_blank" rel="noopener">vuejs官网</a>也用的这个。安装很简单：</p><p><code>npm i hexo-offline --save</code></p><p>关于它的使用及配置，参考文档即可。需要注意的一点是，出于安全考虑，注册 Service Worker 要求你的 web 应用部署于 HTTPS 协议下，以免利用 Service Worker 的中间人攻击，所以我把网站升级了https。接下来我主要说下加上Service Worker之后的效果。</p><ol><li><p>最直观就是可以离线打开页面了，同样关闭WiFi的情况下，对比如下图：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102050.jpg" alt="未标题-1">可以看到左边的会提示离线状态，但是会提示联网时下载，右边还可以正常浏览，其实浏览的是在线时下载的离线版。</p></li><li><p>除了将浏览器离线我们还可以通过其他方法知道Service Worker生效，打开chrome://inspect/#service-workers可以查看到当前运行的Service Worker：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102051.jpg" alt="4053FC97-F771-4F14-89F3-BFF723843E34"></p><p>通过chrome的开发者工具我们也可以观测到serverwork的运行：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102053.jpg" alt="1C50E55B-388B-4AEC-9A9A-52A109DD8E30"></p><p>通过这两张图，我们可以清楚地知道ServiceWorker确实在后台工作着，而Cache Storage确实对博客内的静态资源做了缓存处理。事实上对Hexo这样的静态博客而言，整个博客都是静态资源，所以在实际运行中它会对所有内容进行缓存，我们在本地启动hexo s，可以看到资源缓存的情况：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102054.jpg" alt="98E9EB0B-4B00-4068-88E4-8B677882F4CB"></p></li><li><p>用Lighthouse测了下评分，Lighthouse目前非常关注PWA的特性，例如添加到主屏幕和离线支持，结果如下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102056.jpg" alt="EBBD27DF-2BBD-494D-84CF-50D763291020"></p><p>可以看到评分还是不错的，不足的地方主要在首屏的加载，css文件请求时间较长，这个可以通过增加一些CDN解决，首屏优化可以通过添加骨架图改进体验，具体可以看<a href="https://tianxiaobo.cn/2017/10/25/%E4%BD%BF%E7%94%A8Skeleton-Screen%E4%BC%98%E5%8C%96%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD/" target="_blank" rel="noopener">《使用Skeleton Screen优化首屏加载》</a>这篇文章。</p></li></ol><h2 id="Push-Notification"><a href="#Push-Notification" class="headerlink" title="Push Notification"></a>Push Notification</h2><p>PWA 推送通知中的「推送」与「通知」，其实使用的是两个不同但又相得益彰的 API：Notification API和Push API，前者用于向用户展示通知，而后者用于订阅推送消息。对Hexo这样一个静态博客生成器而言，先不考虑消息推送的相关问题。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，我的Hexo博客就已经支持PWA啦，不过这不是终点，关于PWA的尝试还会继续，接下来我还会写两篇文章详细介绍一下Service Worker和Push Notification的使用。</p><p>目前国内的PWA重视程度还不是很好，而据了解在一些 Google 服务健全、标配 Chrome 的 Android 手机市占率非常高的国家，比如印度，PWA 的用户数量已经相当可观。移动应用现在已经如此的流行，但是原生应用迭代慢，跨平台弱体验强，而Web迭代快，跨平台强体验弱，我们一直在想办法解决这个鱼和熊掌的难题，而PWA的出现让鱼与熊掌兼得变成了可能，已经希望可以尽快看到这项技术更多更好的应用在移动开发上，最后借用乔布斯的一句话：</p><blockquote><p>虽然现阶段Native App给了用户更好的体验，但Web才是未来。如果现在的开发者不有效利用Web技术，那他就落伍了。</p></blockquote><p>那就让我们用代码证明给这个世界看吧。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://huangxuan.me/2017/02/09/nextgen-web-pwa/" target="_blank" rel="noopener">下一代 Web 应用模型 —— Progressive Web App</a></p><p><a href="https://qinyuanpei.github.io/2017/10/24/migrate-hexo-as-a-progressive-web-app.html#Push-Notification-API" target="_blank" rel="noopener">迁移Hexo博客到Google渐进式Web应用(PWA)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 入门 </tag>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用NodeJs实现代理服务器</title>
      <link href="/posts/b5c3/"/>
      <url>/posts/b5c3/</url>
      
        <content type="html"><![CDATA[<p>最近迁移网站服务，有些页面在旧的服务上，但是客户端还有一些请求打过来，客户端要改url的话又需要发版，所以最后选择了在新服务上做了代理，承接了原来页面的访问。今天就来聊一下nodejs与代理服务器有关的事。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102013.jpg" alt="30894AB2-3E4E-4260-8C12-9F7845C922B4"></p><a id="more"></a><h2 id="正向代理和反向代理"><a href="#正向代理和反向代理" class="headerlink" title="正向代理和反向代理"></a>正向代理和反向代理</h2><p>代理分为两种，一种是正向代理，一种是反向代理。</p><ul><li><p>正向代理是一个位于客户端和目标服务器之间的代理服务器，也就是代理用户访问目标站点的中介服务器，用来把客户端的请求代理到目标服务器，比如科学上网。</p></li><li><p>反向代理就好像是目标服务器，客户端并不知道这个请求具体会被转发到哪里，由反向代理自己判断，比如负载均衡。</p></li></ul><h2 id="用node实现一个代理服务器"><a href="#用node实现一个代理服务器" class="headerlink" title="用node实现一个代理服务器"></a>用node实现一个代理服务器</h2><p>核心思想都是使用stream和pipe。stream即流，可以理解为运载数据的流，HTTP request和process.stdout这些都是流的实例，分为可写流、可读流、可读可写流，使用stream可以实现数据的流式处理，pipe是stream的强大之处，跟unix中的|类似，可以将一个流的输出灌入另一个流的输入，很多强大的工具都使用stream pipe去实现流式处理，比如gulp、Browserify等等。</p><h3 id="利用stream和pipe纯手写"><a href="#利用stream和pipe纯手写" class="headerlink" title="利用stream和pipe纯手写"></a>利用stream和pipe纯手写</h3><h4 id="极简版"><a href="#极简版" class="headerlink" title="极简版"></a>极简版</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>)</span><br><span class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express()</span><br><span class="line">app.use(<span class="string">'/favicon.ico'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.sendfile(<span class="string">'./assets/bbb'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.url)</span><br><span class="line">  <span class="keyword">const</span> url = <span class="string">`http://www.baidu.com/s?wd=<span class="subst">$&#123;req.url.split(<span class="string">'='</span>)[<span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">  req.pipe(request(url)).pipe(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(process.env.PORT || <span class="number">4000</span>)</span><br></pre></td></tr></table></figure><h4 id="复杂版"><a href="#复杂版" class="headerlink" title="复杂版"></a>复杂版</h4><p>见github：<a href="https://github.com/leotian/proxy-test/blob/master/advanced-pipe.js" target="_blank" rel="noopener">https://github.com/leotian/proxy-test/blob/master/advanced-pipe.js</a></p><h3 id="第三方包"><a href="#第三方包" class="headerlink" title="第三方包"></a>第三方包</h3><h4 id="node-http-proxy"><a href="#node-http-proxy" class="headerlink" title="node-http-proxy"></a>node-http-proxy</h4><blockquote><p>较常用，middleware的实现有http-proxy-middleware，使用harmon可以进行内容修改</p></blockquote><ul><li><p>harmon：<a href="https://github.com/No9/harmon" target="_blank" rel="noopener">https://github.com/No9/harmon</a></p></li><li><p>node-http-proxy：<a href="https://github.com/nodejitsu/node-http-proxy" target="_blank" rel="noopener">https://github.com/nodejitsu/node-http-proxy</a></p></li><li><p>http-proxy-middleware：<a href="https://github.com/chimurai/http-proxy-middleware" target="_blank" rel="noopener">https://github.com/chimurai/http-proxy-middleware</a></p></li></ul><h4 id="hoxy"><a href="#hoxy" class="headerlink" title="hoxy"></a>hoxy</h4><blockquote><p>自带cheerio，修改方便，代码拦截流程以及替换流程比较直接，拦截很方便，但是跟express不好结合</p></blockquote><ul><li>hoxy：<a href="https://github.com/greim/hoxy" target="_blank" rel="noopener">https://github.com/greim/hoxy</a></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/24723688" target="_blank" rel="noopener">反向代理为何叫反向代理？</a></p><p><a href="https://cloud.tencent.com/developer/article/1053668" target="_blank" rel="noopener">图解正向代理、反向代理、透明代理</a></p><p><a href="https://cnodejs.org/topic/5a2ffe00d92f2f5b185acde5" target="_blank" rel="noopener">如何编写一个 HTTP 反向代理服务器</a></p><p><a href="https://bupt-hjm.github.io/2017/03/20/reverse-proxy/" target="_blank" rel="noopener">基于node的stream pipe实现反向代理</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 代理服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker部署服务和一些注意事项</title>
      <link href="/posts/7ffc/"/>
      <url>/posts/7ffc/</url>
      
        <content type="html"><![CDATA[<p>从半年前开始，逐渐把新服务都放进了docker，使用也算有了一些心得，在这里总结一下。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101840.jpg" alt="3833F0C1-803C-4D17-AFEA-E56BE886DE1F"></p><a id="more"></a><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>入门学习是看的这本书：<a href="https://yeasy.gitbooks.io/docker_practice/content/" target="_blank" rel="noopener">Docker — 从入门到实践</a>，感觉讲的还不错，都是些很实用的东西。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="Dockerfile的书写"><a href="#Dockerfile的书写" class="headerlink" title="Dockerfile的书写"></a>Dockerfile的书写</h3><p>可以遵循下面的几点规则</p><ol><li><p>合理分层，重复利用镜像缓存</p><p>Dockerfile 中每一个指令都会建立一层：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像。</p><p>创建了过多层的镜像是完全没有意义的，而且很多运行时不需要的东西，都被装进了镜像里，比如编译环境、更新的软件包等等。结果就是产生非常臃肿、非常多层的镜像，不仅仅增加了构建部署的时间，也很容易出错。这是很多初学 Docker 的人常犯的一个错误。</p><p>首先，如果所有的命令只有一个目的，那么就没有必要建立很多层，这只是一层的事情。因此，这里没有使用很多个 <code>RUN</code> 对一一对应不同的命令，而是仅仅使用一个 <code>RUN</code> 指令，并使用 <code>&amp;&amp;</code> 将各个所需命令串联起来。将之前的 7 层，简化为了 1 层。在撰写 Dockerfile 的时候，要经常提醒自己，这并不是在写 Shell 脚本，而是在定义每一层该如何构建。</p></li><li><p>删除当前层中创建的文件（注意只能删除当前层中创建的文件）</p><p>很多人初学 Docker 制作出了很臃肿的镜像的原因之一，就是忘记了每一层构建的最后一定要清理掉无关文件。我们可以在一组命令的最后添加清理工作的命令，删除为了编译构建所需要的软件，清理所有下载、展开的文件，并且清理 <code>apt</code> 缓存文件。这是很重要的一步，我们之前说过，镜像是多层存储，每一层的东西并不会在下一层被删除，会一直跟随着镜像。因此镜像构建时，一定要确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。</p></li><li><p>选择较小体积的基础镜像（比如 alpine）</p></li></ol><h3 id="使用私有仓库"><a href="#使用私有仓库" class="headerlink" title="使用私有仓库"></a>使用私有仓库</h3><p>对于公司来说有自己的私有仓库还是很有必要的，目前我们是用的是阿里云的私有仓库，这部分的使用直接看阿里云的文档即可。并且阿里云还提供个人专属的镜像加速器，这部分阿里云还是很良心的。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101842.jpg" alt="95431CFD-3F49-4F23-8E58-D9D55B29B6BD"></p><h3 id="清楚废弃镜像"><a href="#清楚废弃镜像" class="headerlink" title="清楚废弃镜像"></a>清楚废弃镜像</h3><p>过多不再使用镜像会占用磁盘空间，所以我们需要去删除他们。这些镜像的特征就是标签为none，无标签镜像也被称为 <strong>虚悬镜像(dangling image)</strong> ，可以用下面的命令专门显示这类镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image ls -f dangling=true</span><br></pre></td></tr></table></figure><p>一般来说，虚悬镜像已经失去了存在的价值，是可以随意删除的，可以用下面的命令删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker image prune</span><br></pre></td></tr></table></figure><p>如果这个命令不好使的话，我们还总结了三条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a | grep "Exited" | awk '&#123;print $1 &#125;' | xargs docker stop</span><br><span class="line">docker ps -a | grep "Exited" | awk '&#123;print $1 &#125;' | xargs docker rm //</span><br><span class="line">docker images | grep "&lt;none&gt;" | awk '&#123;print $3&#125;' | xargs docker rmi//</span><br></pre></td></tr></table></figure><p>这三句分别执行了如下的操作：</p><ol><li>停止Exited状态的容器</li><li>删除Exited状态的容器</li><li>删除标签为<none>的镜像</none></li></ol><p>有了这三板斧，基本就可以清除掉废弃的镜像了，我一般把他写在.bashrc里，然后在Jenkins的构建脚本里source .bashrc，来达到每次构建之前腾出一定空间的目的。</p><h3 id="镜像备份"><a href="#镜像备份" class="headerlink" title="镜像备份"></a>镜像备份</h3><p>镜像的标签常用于对应该软件的各个版本。这个主要针对线上服务，测试环境不需要备份，只生成一个image打一个pub标签就够了，而线上服务通常生成一个image后打两个标签分别保存，一个打版本号标签，另一个打lastest标签，这样就做好了一次镜像的备份。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101843.jpg" alt="D034C983-66AB-496B-9067-A069FAB567DD"></p><h2 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h2><h3 id="部署和维护变得更简单"><a href="#部署和维护变得更简单" class="headerlink" title="部署和维护变得更简单"></a>部署和维护变得更简单</h3><p>用docker最大的好处是你可以把你的应用以及应用运行依赖的环境和配置一起打包交付，做到开箱即用。并且环境还可以进行模块化，提高了复用性，不用每次部署新机器都到上面搞各种环境。整个领域的标准化和效率的提高。这里的部署还包括迁移，前段时间公司从青云迁移到了阿里云，公司的运维就很欢迎我用docker，因为这样对服务的部署和维护都有好处，Dockerfile减少了很多沟通成本，快速开/关机使维护变得简单。</p><h3 id="隔离的环境"><a href="#隔离的环境" class="headerlink" title="隔离的环境"></a>隔离的环境</h3><p>这一点知乎有个回答我觉得说的很清楚：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101845.jpg" alt="A660D3A0-B363-46D7-BC25-4B2FF9194AC8"></p><p>而对于我们来说，就是沙盒化使升级node版本不再是问题，运维给我们开一台服务器，我们就可以部署不同node版本的服务，并且服务之间做到了很好的隔离，不用担心操作一些内容干扰到另一些的运行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用容器部署服务是未来趋势，并且现在在web服务的部署方面已经有了广泛的应用。而docker搭配go语言在分布式计算、大数据甚至机器学习领域的应用也都是令人期待的。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/22871084" target="_blank" rel="noopener">Docker 有什么优势？</a></p><p><a href="https://www.zhihu.com/question/22969309" target="_blank" rel="noopener">Docker 的应用场景在哪里？</a></p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> 服务部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>当循环遇上异步</title>
      <link href="/posts/2465/"/>
      <url>/posts/2465/</url>
      
        <content type="html"><![CDATA[<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://objcer.com/2017/10/12/async-await-with-forEach/" target="_blank" rel="noopener">当 async/await 遇上 forEach</a></p><p><a href="https://zhuanlan.zhihu.com/p/59803048" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59803048</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 循环 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比较JavaScript中的几种循环</title>
      <link href="/posts/7117/"/>
      <url>/posts/7117/</url>
      
        <content type="html"><![CDATA[<blockquote><p>循环是一种很重要的控制结构，它很难被重用，也很难插入到其他操作之中。另外，它意味着随着每次迭代，代码也在不断的变化之中。——Luis Atencio</p></blockquote><a id="more"></a><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>我们先介绍一下语法层面我们可以使用的循环语句。</p><h3 id="while和do-…-while"><a href="#while和do-…-while" class="headerlink" title="while和do … while"></a>while和do … while</h3><p><code>while</code>循环只有一个判断条件，条件满足，就不断循环，条件不满足时则退出循环。而<code>do { ... } while()</code>和<code>while</code>循环的唯一区别在于，不是在每次循环开始的时候判断条件，而是在每次循环完成的时候判断条件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> len = arr.length;</span><br><span class="line"><span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用<code>do { ... } while()</code>循环要小心，循环体会至少执行1次，而<code>for</code>和<code>while</code>循环则可能一次都不执行。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><h4 id="简单for循环"><a href="#简单for循环" class="headerlink" title="简单for循环"></a>简单for循环</h4><p>下面先来看看大家最常见的一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i　&lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率，下面是改进的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-…-in"><a href="#for-…-in" class="headerlink" title="for … in"></a>for … in</h4><p><strong>for-in 循环遍历的是对象的属性，而不是数组的索引。</strong>因此， for-in 遍历的对象便不局限于数组，还可以遍历对象。例子如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    fname: <span class="string">"san"</span>,</span><br><span class="line">    lname: <span class="string">"zhang"</span>,</span><br><span class="line">    age: <span class="number">99</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> info;</span><br><span class="line"><span class="keyword">for</span>(info <span class="keyword">in</span> person) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"person["</span> + info + <span class="string">"] = "</span> + person[info]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-in 被设计用来与以字符串作为键的普通的旧的对象工作，对于数组而言，它不是那么有效。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a[index]);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span> index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然一样可以得到结果，但这是一个糟糕的选择：</p><blockquote><ol><li>赋值给index并不是一个数字,而是一个<code>String</code>。</li><li>作用于数组的<code>for-in</code>循环除了遍历数组元素以外,还会遍历自定义属性，举个例子，如果你的数组中有一个课枚举的类型<code>a.name</code>，那么循环将额外执行一次,遍历到名为<code>name</code>的索引。甚至数组原型链上的属性都能被访问到。</li><li>这段代码可能按照 <strong>随机顺序遍历数组</strong>，即输出的结果顺序与属性在对象中的顺序无关，也与属性的字母顺序无关，与其他任何顺序也无关。</li></ol></blockquote><h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p><code>for...of</code>是ES6新引入的特性。修复了ES5引入的<code>for...in</code>的不足。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"for of:"</span> + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就清晰很多了，注意这里计数器和比较都不用了，你甚至都不用把元素从数组里面取出来。for…of 帮我们做了里面的脏活累活。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如  arguments 对象、DOM NodeList 对象）、 Generator 对象，以及字符串。for…of 还可以正确响应 break, continue, return。如果现在用 for…of 来代替所有的 for 循环，其实就可以很大程度上降低复杂性。但是，我们还可以做进一步的优化。</p><p>for-of 在普通的旧的对象上不能正常工作，但是如果你想要在一个对象的属性上进行循环的话，你可以使用 for–in ( 本来就是它的功能 ) 或者内置的 Object.keys( ) :</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象的自己的枚举属性转储到控制台</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="无循环-JavaScript"><a href="#无循环-JavaScript" class="headerlink" title="无循环 JavaScript"></a>无循环 JavaScript</h2><p>我们先前说过，像循环这样的控制结构引入了复杂性。在 for…of 中虽然我们不必再使用计数器和比较，甚至都不用把元素从数组里面取出来。但是依然需要一些配置性的代码，如想输出一个新数组的话，不得不初始化一个 output 数组并且每次循环都要调用 push() 函数，我们还想做进一步的优化。</p><p>现在假设有一个数组band，我们想用一个函数doodlify处理每一个元素，然后用处理结果组建一个新数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doodlify :: String -&gt; String</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doodlify</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/[aeiou]/g</span>, <span class="string">'oodle'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> band = [<span class="string">'John'</span>, <span class="string">'Paul'</span>, <span class="string">'George'</span>, <span class="string">'Ringo'</span>];</span><br><span class="line"><span class="keyword">let</span> bandoodle = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> band) &#123;</span><br><span class="line">    <span class="keyword">let</span> newItem = doodlify(item);</span><br><span class="line">    bandoodle.push(newItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有两个数组需要调用 doodlify 函数会怎么样？很容易想到的方法是对每个数组都做循环：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bandoodle = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> band) &#123;</span><br><span class="line">    <span class="keyword">let</span> newItem = doodlify(item);</span><br><span class="line">    bandoodle.push(newItem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bandoodle2 = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> band2) &#123;</span><br><span class="line">    <span class="keyword">let</span> newItem = doodlify(item);</span><br><span class="line">    bandoodle2.push(newItem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实没问题，但是重复的代码太多了——不够“<a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself" target="_blank" rel="noopener">DRY</a>”。我们来重构它以降低重复性，创建一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doodlifyArray</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> input) &#123;</span><br><span class="line">        <span class="keyword">let</span> newItem = oodlify(item);</span><br><span class="line">        output.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bandoodle = oodlifyArray(band);</span><br><span class="line"><span class="keyword">let</span> bandoodle2 = oodlifyArray(band2);</span><br></pre></td></tr></table></figure><p>这看起来好多了，可是如果我们想使用另外一个函数该怎么办？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codify</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="regexp">/[aeiou]+/g</span>, <span class="string">'code'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 oodlifyArray() 一点用都没有了。但如果再创建一个 codifyArray() 函数的话，代码又重复了。写出来看看什么效果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doodlifyArray</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> input) &#123;</span><br><span class="line">        <span class="keyword">let</span> newItem = doodlify(item);</span><br><span class="line">        output.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codifyArray</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> input) &#123;</span><br><span class="line">        <span class="keyword">let</span> newItem = codify(item);</span><br><span class="line">        output.push(newItem);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个函数惊人的相似。那么是不是可以把它们抽象成一个通用的模式呢？我们想要的是：给定一个函数和一个数组，通过这个函数，把数组中的每一个元素做操作后放到新的数组中。我们把这个模式叫做 map 。一个数组的 map 函数如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">f, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> a) &#123;</span><br><span class="line">        output.push(f(item));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还是用了循环结构，如果想要完全摆脱循环的话，可以做一个递归的版本出来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>(<span class="params">f, a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length === <span class="number">0</span>) &#123; <span class="keyword">return</span> []; &#125;</span><br><span class="line">    <span class="keyword">return</span> [f(a[<span class="number">0</span>])].concat(map(f, a.slice(<span class="number">1</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解决方法非常优雅，仅仅用了两行代码，几乎没有缩进。但通常不提倡于在这里使用递归，因为在较老的浏览器中的递归性能非常差。实际上，map 完全不需要你自己去手动实现（除非自己想写）。map 模式很常用，因此 JavaScript 提供了一个内置 map 方法。使用这个 map 方法，上面的代码变成了这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bandoodle     = band.map(doodlify);</span><br><span class="line"><span class="keyword">let</span> bandoodle2    = band2.map(doodlify);</span><br><span class="line"><span class="keyword">let</span> bandcode      = band.map(codify);</span><br><span class="line"><span class="keyword">let</span> bandcode2     = band2.map(codify);</span><br></pre></td></tr></table></figure><p>有两个处理字符串的函数：doodlify 和 codefy，这些函数并不需要知道关于数组或者循环的任何事情。同时，有另外一个函数：map ，它来处理数组，它不需要知道数组中元素是什么类型的，甚至你想对数组做什么也不用关心。它只需要执行我们所传递的函数就可以了。现在我们把问题分离了，对数组的处理和对字符串的处理分开，并且用高阶函数（可以接受函数作为参数的函数）的方式把处理函数传递进去，可以注意到，缩进消失，循环消失。当然循环可能转移到了其他地方，但是我们已经不需要去关心它们了。现在的代码简洁有力，完美。</p><p>但是现在我要是只想让数组的元素挨个执行某个函数而不想返回一个新数组呢，其实array对象也已经有方法实现，那就是forEach，类似的还有filter和reduce，他们的区别可以看下面图：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102058.jpg" alt="1"></p><p>至此我们尝试了不用任何循环来处理 JavaScript 数组，为了实现这一点，我们借助了高阶函数，其实给代码增加一点点函数式编程的特性，最终得出的效果是可以降低代码复杂性。</p><p>引入函数式编程可能带来<a href="https://www.zhihu.com/question/263645361" target="_blank" rel="noopener">性能问题</a>，但是作为普通开发者，<strong>过早优化是万恶之源</strong>。应该把可读性，可维护性，可测试性放到首位。</p><h2 id="概念整理"><a href="#概念整理" class="headerlink" title="概念整理"></a>概念整理</h2><p>其实表示“重复”这个含义的词有很多，比如循环(loop)，递归(recursion)，遍历(traversal)， 迭代(iterate)，让我们梳理一下他们各自的概念和之间的关系。</p><p><strong>循环</strong>：算是最基础的概念，凡是重复执行一段代码，都可以称之为循环，大部分的递归、遍历、迭代都是循环 。</p><p><strong>递归</strong>：定义是，根据一种(几种)基本情况定义的算法，其他复杂情况都可以被逐步还原为基本情况。在编程中的特征就是，在函数定义内重复调用该函数。例如斐波那契数列：</p><p>定义F(0) = 1，F(1) = 1，所有其他情况：<code>F(x) = F(x-1) + F(x-2)</code></p><p>所有大于1的整数经过有限次的反推之后都可以转换到两种基本情况。而在编程中，算法则是这样的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span> || x==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;    <span class="comment">//这里是退出递归的条件, 以保证在有限次递归后能够得到结果</span></span><br><span class="line">    <span class="keyword">return</span> F(x<span class="number">-1</span>)+F(x<span class="number">-2</span>);    <span class="comment">//转化为更为基本的情况, 重复调用自身进行计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代在数学和编程中有不同的含义。</p><p><strong>迭代(数学)</strong>：在循环的基础上, 每一次循环, 都比上一次更为接近结果。有很多数学问题, 都是迭代算法, 如牛顿迭代法(求平方根)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int result = 0;</span><br><span class="line">for(int i = 0; i &lt; 10; i++)</span><br><span class="line">    result += i;    //每一次循环之后, result都更加接近结果45</span><br></pre></td></tr></table></figure><p><strong>迭代(编程)</strong>：按顺序访问一个列表中的每一项, 在很多编程语言中表现为foreach语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">arr = [1, 2, 3, 4];</span></span><br><span class="line"><span class="meta">foreach($</span><span class="bash">arr as <span class="variable">$i</span>)</span></span><br><span class="line">    echo $i;</span><br></pre></td></tr></table></figure><p><strong>遍历</strong>：按一定规则访问一个非线性的结构中的每一项，强调非线性结构(树，图)。而迭代一般适用于线性结构(数组, 队列)。</p><p><strong>结论</strong>：</p><ul><li>循环(loop) - 最基础的概念, 所有<strong>重复</strong>的行为</li><li>递归(recursion) - 在<strong>函数内调用自身</strong>, 将复杂情况逐步转化成基本情况</li><li>(数学)迭代(iterate) - 在多次循环中<strong>逐步接近结果</strong></li><li>(编程)迭代(iterate) - 按<strong>顺序</strong>访问<strong>线性</strong>结构中的<strong>每一项</strong></li><li>遍历(traversal) - 按规则访问<strong>非线性</strong>结构中的<strong>每一项</strong></li></ul><p>这些概念都表示“重复”的含义，彼此互相交叉，在上下文清晰的情况下，不必做过于细致的区分。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://jrsinclair.com/articles/2017/javascript-without-loops/" target="_blank" rel="noopener">JAVASCRIPT WITHOUT LOOPS</a></p><p><a href="https://segmentfault.com/q/1010000000199577" target="_blank" rel="noopener">请问编程里迭代和循环有什么区别？</a></p><p><a href="https://www.zhihu.com/question/24927450/answer/29478982" target="_blank" rel="noopener">如何形象地解释 JavaScript 中 map、foreach、reduce 间的区别？</a></p><p><a href="https://www.zhihu.com/question/263645361" target="_blank" rel="noopener">如何从性能方面选择for，map和forEach？</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> loop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs删除非空文件夹的三种方法</title>
      <link href="/posts/ee16/"/>
      <url>/posts/ee16/</url>
      
        <content type="html"><![CDATA[<p>fs即filesystem（文件系统）的缩写，是node自带的I/O模块，用来进行本地文件的读写，所有的API都有异步和同步的形式。删除文件的方法为 fs.rmdir(path, callback)，他的同步版本为fs.rmdirSync(path)，但有个问题是只能删除空文件夹，对于非空文件夹就无能为力了。这里提供了三种方法来实现使用nodejs对一个非空文件夹的删除。可以从 <a href="https://github.com/leotian/fs-test" target="_blank" rel="noopener">https://github.com/leotian/fs-test</a> 获取demo源代码。</p><a id="more"></a><h2 id="使用fs——递归删除文件后删除文件夹"><a href="#使用fs——递归删除文件后删除文件夹" class="headerlink" title="使用fs——递归删除文件后删除文件夹"></a>使用fs——递归删除文件后删除文件夹</h2><p>这个方法依旧使用系统自带的fs模块，实现原理简单粗暴，就是先删除文件夹内所有文件，如果遇到子文件夹再进入子文件夹删除子文件夹内所有文件，直到最后删除所有空文件夹。</p><p>让我们来看看fs中我们可以使用的命令：</p><ol><li>fs.stat &amp;&amp; fs.statSync 提供了访问文件的属性信息</li><li>fs.readdir &amp;&amp; fs.readdirSync 提供读取文件目录信息</li><li>fs.unlink &amp;&amp; unlinkSync  进行删除文件操作，不可以删除文件夹</li><li>fs.rmdir &amp;&amp; fs.rmdirSync 进行删除文件夹操作，但文件夹必须为空文件夹</li></ol><p>接下来进行删除，删除需要两步，分别是：</p><ul><li>第一步：删除所有文件，清空文件夹（包括子文件夹）</li><li>第二步：删除所有空文件夹</li></ul><p>代码实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/aaa`</span><span class="comment">//要删除的文件夹 url</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有的文件(将所有文件夹置空)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emptyDir</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = fs.readdirSync(filePath)<span class="comment">//读取该文件夹</span></span><br><span class="line">  files.forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> nextFilePath = <span class="string">`<span class="subst">$&#123;filePath&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span></span><br><span class="line">    <span class="keyword">const</span> states = fs.statSync(nextFilePath)</span><br><span class="line">    <span class="keyword">if</span> (states.isDirectory()) &#123;</span><br><span class="line">      emptyDir(nextFilePath)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.unlinkSync(nextFilePath)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`删除文件 <span class="subst">$&#123;nextFilePath&#125;</span> 成功`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除所有的空文件夹</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rmEmptyDir</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = fs.readdirSync(filePath)</span><br><span class="line">  <span class="keyword">if</span> (files.length === <span class="number">0</span>) &#123;</span><br><span class="line">    fs.rmdirSync(filePath)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`删除空文件夹 <span class="subst">$&#123;filePath&#125;</span> 成功`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> tempFiles = <span class="number">0</span></span><br><span class="line">    files.forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">      tempFiles++</span><br><span class="line">      <span class="keyword">const</span> nextFilePath = <span class="string">`<span class="subst">$&#123;filePath&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span></span><br><span class="line">      rmEmptyDir(nextFilePath)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//删除母文件夹下的所有字空文件夹后，将母文件夹也删除</span></span><br><span class="line">    <span class="keyword">if</span>(tempFiles === files.length) &#123;</span><br><span class="line">      fs.rmdirSync(filePath)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`删除空文件夹 <span class="subst">$&#123;filePath&#125;</span> 成功`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">emptyDir(filePath)</span><br><span class="line">rmEmptyDir(filePath)</span><br></pre></td></tr></table></figure><p>代码优化：清空文件夹和删除文件夹一次进行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteFolder</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> files = []</span><br><span class="line">  <span class="keyword">if</span> (fs.existsSync(filePath)) &#123;</span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(filePath)</span><br><span class="line">    files.forEach(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> nextFilePath = <span class="string">`<span class="subst">$&#123;filePath&#125;</span>/<span class="subst">$&#123;file&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> states = fs.statSync(nextFilePath)</span><br><span class="line">      <span class="keyword">if</span> (states.isDirectory()) &#123;</span><br><span class="line">        <span class="comment">//recurse</span></span><br><span class="line">        deleteFolder(nextFilePath)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//delete file</span></span><br><span class="line">        fs.unlinkSync(nextFilePath)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    fs.rmdirSync(filePath)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">deleteFolder(filePath)</span><br></pre></td></tr></table></figure><h2 id="使用子进程——执行”rm-rf命令”"><a href="#使用子进程——执行”rm-rf命令”" class="headerlink" title="使用子进程——执行”rm -rf命令”"></a>使用子进程——执行”rm -rf命令”</h2><p>我们都知道 Node.js 是以单线程的模式运行的，但它使用的是事件驱动来处理并发，这样有助于我们在多核 cpu 的系统上创建多个子进程，从而提高性能。</p><p>每个子进程总是带有三个流对象：child.stdin，child.stdout 和child.stderr。他们可能会共享父进程的 stdio 流，或者也可以是独立的被导流的流对象。</p><p>Node 提供了 child_process 模块来创建子进程，方法有：</p><ul><li>exec - child_process.exec 使用子进程执行命令，缓存子进程的输出，并将子进程的输出以回调函数参数的形式返回。</li><li>spawn - child_process.spawn 使用指定的命令行参数创建新进程。</li></ul><ul><li>fork - child_process.fork 是 spawn()的特殊形式，用于在子进程中运行的模块，如 fork(‘./son.js’) 相当于 spawn(‘node’, [‘./son.js’]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/aaa`</span><span class="comment">//要删除的文件夹 url</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> workerProcess = child_process.exec(<span class="string">`rm -rf <span class="subst">$&#123;filePath&#125;</span>`</span>, </span><br><span class="line">    (error, stdout, stderr) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (error) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(error.stack)</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Error code: '</span>+error.code)</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Signal received: '</span>+error.signal)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stdout: '</span> + stdout)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'stderr: '</span> + stderr)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">workerProcess.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'子进程已退出，退出码 '</span>+code);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="使用第三方工具包rimraf"><a href="#使用第三方工具包rimraf" class="headerlink" title="使用第三方工具包rimraf"></a>使用第三方工具包rimraf</h2><p>最简单的方法就是安装第三方工具包——rimraf，rimraf 包的作用：以包的形式包装rm -rf命令，就是用来删除文件和文件夹的，不管文件夹是否为空，都可以删除。</p><ol><li>npm地址：<a href="https://www.npmjs.com/package/rimraf" target="_blank" rel="noopener">https://www.npmjs.com/package/rimraf</a></li><li>GitHub地址：<a href="https://github.com/isaacs/rimraf" target="_blank" rel="noopener">https://github.com/isaacs/rimraf</a></li></ol><p>该包只提供一个方法，就是删除文件/文件夹：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rimraf = <span class="built_in">require</span>(<span class="string">'rimraf'</span>);</span><br><span class="line">rimraf(<span class="string">'./aaa'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; <span class="comment">// 删除当前目录下的 aaa</span></span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看了下rimraf的源码，基本也是使用fs递归删除，之后会考虑写一些nodejs包的源码解读。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://blog.163.com/hule_sky/blog/static/2091622452015112821829773/" target="_blank" rel="noopener">nodejs 文件系统(fs) 删除文件夹及子文件夹下的所有内容</a></p><p><a href="http://www.runoob.com/nodejs/nodejs-process.html" target="_blank" rel="noopener">Node.js 多进程</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> fs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别ChromeApp版Postman</title>
      <link href="/posts/df50/"/>
      <url>/posts/df50/</url>
      
        <content type="html"><![CDATA[<p>如果你还在使用Chrome App版本的Postman，你会发现应用上会有这样一条引导：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101906.jpg" alt="71962DAF-506C-4E85-9551-76D133087F6C"></p><a id="more"></a><p>这是在告诉我们，Google 宣布将在主流平台上停止支持 Chrome 商店里的应用，而Postman作为一个被广泛使用的Chrome App，也同样面临下线的结果。如果你还想使用Postman，需要下载Native版的Postman，本地版会继续支持和有更好的特性。</p><h2 id="首先，什么是Chrome-App？"><a href="#首先，什么是Chrome-App？" class="headerlink" title="首先，什么是Chrome App？"></a>首先，什么是Chrome App？</h2><blockquote><p>Chrome 应用提供了与原生应用能力相同的体验，但是与网页一样安全。就像网上应用一样，Chrome 应用使用 HTML5、JavaScript 和 CSS 编写，但是 Chrome 应用从外观上与行为上都与原生应用类似，它们也具有类似于原生应用的能力，比网上应用可用的更强大。</p></blockquote><p>Chrome App支持离线内容，能以独立窗口运行，在不同设备和系统间同步内容。Chrome App还拥有丰富的硬件权限，可以访问电脑GPU、摄像头、硬盘，通过蓝牙传输文件。Chrome App启动器类似Windows开始菜单，允许用户在不打开浏览器的情况下使用Chrome App。</p><p>Chrome App和Chrome App启动器是暴露野心最明显的举动。它们进一步拓展了插件的功能，能够实现编辑图片、绘制流程图等更加复杂的功能。对GPU、摄像头等硬件调用的支持，将允许开发者开发游戏和聊天工具。</p><p>展示几款代表性的Chrome App：</p><p>Piconion，轻量级Photoshop类应用，支持“图层”、“套索”、“魔棒”等常用功能</p><p>Gorescript，基于JavaScript / WebGL.的FPS游戏</p><p><a href="http://draw.io/" target="_blank" rel="noopener">Draw.io</a>，线框图软件，可以实现轻量级的项目管理和产品线框图绘制</p><p>当然还有我们的Postman和曾经比较出名的马克飞象。以上App都能在完全离线的情况下使用，Chrome展现出了取代操作系统的潜力。</p><h2 id="其次，为什么要停止支持？"><a href="#其次，为什么要停止支持？" class="headerlink" title="其次，为什么要停止支持？"></a>其次，为什么要停止支持？</h2><p>主要还是用的人太少了，据说只有1%的用户在频繁使用。Chrome App最大的问题在于，作为生产力和娱乐应用，它们太过轻量。专业用户和游戏玩家都没有足够的动力使用它们。桌面设备通常用于满足专业生产和更发烧的娱乐需求，但立志取代桌面系统的Chrome在这两方面都没显示出足够强的竞争力。随着Windows、macOS的专业软件逐渐增加对云服务的支持，Chrome云同步的特点也被渐渐抹平。因此推行3年后，Chrome取代操作系统的进展依旧不温不火。Chrome对应的硬件——Chromebook——主要用于教育市场，低廉的Chromebook满足了教育用户对低价设备的需求。因此推行3年后，Chrome取代操作系统的进展依旧不温不火。Chrome对应的硬件——Chromebook——主要用于教育市场，低廉的Chromebook满足了教育用户对低价设备的需求。</p><p>另一边，<strong>Android开始更多侵入桌面市场</strong>。谷歌官方文档里有说明，其实是因为浏览器和web技术的快速发展，使得原本只有通过app能完成的功能web也能完成了，谷歌在推progressive web app，app向web演进，我们未来可能会看到PWA的流行。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>有native版的话，使用native版的就好了，然后现在网页版功能也很强大了，所以很多应用可以转向网页版，比如Draw.io的网页版看起来也还算好用。当然，如果你是重度使用用户，你可能本来就会选择本地版的应用。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/49811598" target="_blank" rel="noopener">如何看待 Google 宣布将在主流平台上停止支持 Chrome 商店里的应用？</a></p><p><a href="http://blog.getpostman.com/2017/03/14/going-native/" target="_blank" rel="noopener">Going native</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> postman </tag>
            
            <tag> chromeApp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用mac时需要熟记的一些按键符号</title>
      <link href="/posts/3d25/"/>
      <url>/posts/3d25/</url>
      
        <content type="html"><![CDATA[<p>刚使用mac的你是否发现，记一些按键对应的符号挺令人挠头的，比如⌥代表Option键，这就导致查看一些快捷键的符号组合后有时候反应不过来应该怎么用，今天就让我们来熟悉一下这些按键和他们的设计理念，来辅助记忆。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101930.jpg" alt="75a8cdadjw1dvdkjid0cuj"></p><a id="more"></a><h1 id="Option-Alt键"><a href="#Option-Alt键" class="headerlink" title="Option/Alt键"></a>Option/Alt键</h1><p>Option/Alt键：据说这是当初苹果的符号设计师的设计理念，在火车并轨的时候有两个选择(two options)。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101931.jpg" alt="489B8AD9-4F29-4F01-8455-39A4E5E705F7"></p><h1 id="Shift键"><a href="#Shift键" class="headerlink" title="Shift键"></a>Shift键</h1><p>Shift键：俗称上档转换键。按住此键，再打字母，出来的就是这个字母的大写体。还可用于中英文转换。以此类推，按住此键，再打数字键，就会出来数字键上方的符号。比如Shift + 2 = @。所以Shift是⇧就是换挡，对应打字机大小写换挡。</p><p>shift 有修饰 command 的作用，主要是用于对字母按键数量不足的补充，毕竟 26 个字母和少量标点不能满足覆盖命令，这时某些相关的命令就会用 shift 和 command 一起修饰，比如 ⌘Z 和 ⇧⌘Z。</p><h1 id="Command键"><a href="#Command键" class="headerlink" title="Command键"></a>Command键</h1><p>Command键：据 Macintosh 开发团队的最初员工安迪·赫茨菲尔德(Andy Hertzfeld)回忆，补充一句，他也是本站翻译过的《硅谷革命》（Revolution in the valley）一书的作者。当时他正与团队其他成员合作，负责将软件菜单的各种命令转移到物理键盘上操作。他们想到一个简单的办法，在键盘上添加一个特别的「功能键」——当这个「功能键」配合其他不同的按键时，就会调用相应的菜单各种命令，这也是键盘快捷键的由来。</p><p>他们给这个特别的「功能键」命名为「Apple key」，并在按键上贴了一个小小的苹果 logo 。但乔布斯讨厌这个想法，更准确地说是，乔布斯讨厌他们在这个「功能键」上贴上苹果 logo 的做法。据安迪·赫茨菲尔德回忆，乔布斯当时说：”屏幕上的苹果已经够多了（注：乔布斯是指 最初的 Mac OS 界面中多处用到苹果 logo 做为按钮元素）。这很荒谬！我们正在让苹果 logo 泛滥、失效（因为用户无法辨别其含义的不同）。”乔布斯下达了一个重新设计命令，他们匆忙找到位图艺术家苏珊·卡尔(Susan Kare)帮助重新设计。这位设计师拿出了一本《国际符号标志辞典》(international symbol dictionary)，翻了翻，然后说她说选中了瑞典一个「⌘」花形符号，“就用这个”。辞典里写到，这个符号用在瑞典的野营或露营地，表示需要提醒人们注意和关注。此外，它还有无限循环、统一码标准等含义。</p><h1 id="Ctrl键"><a href="#Ctrl键" class="headerlink" title="Ctrl键"></a>Ctrl键</h1><p>Ctrl键：^，中文尚无通用名称，可以是插入符号、插入符、脱字符号、脱字符等；英文称为 Caret (英语发音：/ˈkærət/)，是个倒 V 形的字素。打字机有其上标变型；其在法文和葡萄牙文等用作扬抑符。其通常是个”死键”（ dead key），意思是按此键不会令打字机头移动，然后用户可再在其上打上其他字母。</p><p>许多操作系统，包括类 UNIX 系统、 DOS，允许用户按下 Ctrl 键时按下另一个脱字符表示法使用的字母键，来输入控制字符。Mac 的 Command 键的功能与 PC 的 Control 键基本一致，而 Mac 的 Control 键有另外的作用（比如与鼠标左键组合成鼠标辅助键（即所谓的鼠标右键），以及作为辅助修饰键构成更多的快捷键组合）。Mac 的 Control 键不是为了兼容 PC 而存在的。</p><h1 id="Tab键"><a href="#Tab键" class="headerlink" title="Tab键"></a>Tab键</h1><p>Tab键盘：接下来是大名鼎鼎的制表符，也就是Tab键，Tab 键是 tabulator key 的缩写，其含义是“作表的人，制表机，(打字机上为制表用的)跳格键”。它最基本的用法就是用来绘制无边框的表格。tab键在shell中可以自动补全，配合其他键还有切换选项卡或标签、切换窗口等等功能，不过作为一个编程中使用空格缩进的程序员，对这个键就不做更多解释了。</p><h1 id="从系统中查看键盘符号"><a href="#从系统中查看键盘符号" class="headerlink" title="从系统中查看键盘符号"></a>从系统中查看键盘符号</h1><ol><li><p>用“键盘显示程序”来查看</p><p>键盘显示程序就是键盘的对照表，分别于键盘上的按键一一对应，点击输入法菜单“显示键盘显示程序”即可看到。<br><img src="https://images.leotian.cn/blog/2019-04-29-101933.jpg" alt="7F6C5FAE-BD12-4FE4-821A-070DE4EAAB57"></p><p>一方面你可以根据对应关系，看到该按键对应的符号；另一方面，你可以按下该按键来查看它的符号，当按下一个按键时，该按键在键盘显示程序中的符号是灰色的，比如如下就表示当前按下的是command键。所以你可以通过这种方式来了解按键的含义。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101936.jpg" alt="B9343F49-F571-437E-86DC-72453542434C"></p></li><li><p>通过修饰键来查看<br>像command、option、control、shift这些按键在Mac下叫做修饰键，一般情况下他们大都用来辅助输入或者用作快捷键的修饰键。</p><p>打开“系统偏好设置”，点击“键盘→键盘→修饰键”即可看到这些修饰键，如caps lock 是⇪，control是⌃，option是⌥，command是⌘，当然，在这里你可以自定义键盘的映射，比如将command键映射为control键，将control键映射为command键。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101937.jpg" alt="B28E7978-54AB-4DCB-A508-E49688C5E032"></p></li></ol><h1 id="苹果官方版本：按键符号"><a href="#苹果官方版本：按键符号" class="headerlink" title="苹果官方版本：按键符号"></a>苹果官方版本：<a href="https://support.apple.com/kb/PH7334?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">按键符号</a></h1><p>以下这些符号出现在菜单中，代表键盘快捷键中使用的按键。这些符号中的一部分还会出现在帮助中，称为“修饰键”。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101938.jpg" alt="65AD7A81-4218-4DDE-BE46-37233D90E75A"></p><p>最后，大家有没有发现Mac的键盘没有Home、End、Page UP、Page DOWN这几个键？其实可以用Fn键来组合得到同样的功能：Home键 = Fn + 左方向，End键 = Fn + 右方向，Page UP = Fn + 上方向，Page DOWN = Fn + 下方向，向前Delete = Fn + delete键。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.zhihu.com/question/56494826" target="_blank" rel="noopener">为什么Ctrl的符号是 ⌃ ，Command的符号是⌘？</a></p><p><a href="https://support.apple.com/kb/PH7334?locale=zh_CN&amp;viewlocale=zh_CN" target="_blank" rel="noopener">Mac OS X 10.6: 按键符号</a></p><p><a href="http://newping.cn/457" target="_blank" rel="noopener">认识Mac下的那些符号!</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> mac </tag>
            
            <tag> 按键符号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx常用配置</title>
      <link href="/posts/c953/"/>
      <url>/posts/c953/</url>
      
        <content type="html"><![CDATA[<p>Nginx (engine x) 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。总结一些Nginx经常使用的配置，作为备忘录。</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> Nginx </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Skeleton Screen优化首屏加载</title>
      <link href="/posts/1d4e/"/>
      <url>/posts/1d4e/</url>
      
        <content type="html"><![CDATA[<p>最近看到诊疗圈有这个功能，一直不知道怎么称呼它，查了才知道，原来这个叫Skeleton Screen，中文叫加载占位图，或者也有叫骨架图的。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102020.jpg" alt="B8BC8F8B-A510-4096-9205-267441769C55"><a id="more"></a></p><p>Skeleton Screen（加载占位图）是近年流行的加载控件，通常表现形式是在界面上待加载区域填充灰色的占位图，与线框图的效果非常相似。Skeleton Screen本质上是界面加载过程中的过渡效果。</p><h2 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h2><p>这部分安利一个知乎专栏<a href="https://zhuanlan.zhihu.com/c_87416856" target="_blank" rel="noopener">这个控件叫什么</a>，里面专门科普一些前端控件的名称和使用事项。里面的《<a href="https://zhuanlan.zhihu.com/p/26014116" target="_blank" rel="noopener">这个控件叫：Skeleton Screen/加载占位图</a>》讲得很好，可以直接看这个。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="使用静态图片"><a href="#使用静态图片" class="headerlink" title="使用静态图片"></a>使用静态图片</h3><p>诊疗圈采用 SPA，即单页面应用模型（Single-page App）来组织整个 web 应用，所以首屏渲染是一大短板，很适合使用占位图来优化使用体验，看了下诊疗圈的实现方式，就是把界面控件框架的轮廓做成静态图片用于Launch Screen（启动屏幕），这是最简单也是最普遍的一种做法。这种做法跟具体框架无关，在react和vue中可以直接在index.hmtl中放置静态图片覆盖首屏，然后分别在componentDidMount和mounted阶段把图片隐藏掉，总之在页面内容加载前放置图片，确认加载完毕后隐藏图片即可</p><h3 id="使用-Vue-预渲染功能"><a href="#使用-Vue-预渲染功能" class="headerlink" title="使用 Vue 预渲染功能"></a>使用 Vue 预渲染功能</h3><h2 id="一切为了用户体验"><a href="#一切为了用户体验" class="headerlink" title="一切为了用户体验"></a>一切为了用户体验</h2><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://zhuanlan.zhihu.com/p/26014116" target="_blank" rel="noopener">这个控件叫：Skeleton Screen/加载占位图</a></p><p><a href="https://zhuanlan.zhihu.com/p/28465598" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28465598</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flex布局总结</title>
      <link href="/posts/7f0b/"/>
      <url>/posts/7f0b/</url>
      
        <content type="html"><![CDATA[<p>之前在一些主要在手机端浏览的<a href="http://www.jianshu.com/p/3c94ae673e2a" target="_blank" rel="noopener">webview</a>页面中使用了flex布局，现在写RN，全部都是flex布局，所以趁机总结了一下flex布局的写法和相关知识。</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> flex布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用express-session遇到的同步问题</title>
      <link href="/posts/2b83/"/>
      <url>/posts/2b83/</url>
      
        <content type="html"><![CDATA[<p>前段时间遇到一个很奇怪的问题，一个给公司运营提供的后台服务，登录是用express-session实现的简易身份验证，使用时每次重新登录第一次输入验证码总会出错，由于是公司内部的后台服务，所以一直没看，今天研究了一下，发现是一个并发请求导致的session状态被重写问题。</p><a id="more"></a><h5 id="使用express-session"><a href="#使用express-session" class="headerlink" title="使用express-session"></a>使用express-session</h5><p>首先要了解的是express-session这一中间件，当浏览器访问服务器并发送第一次请求时，服务器端会创建一个session对象，生成一个类似于key（connect sid），value（session）的键值对， 然后将key（connect sid）返回到浏览器（客户）端作为cookie保存，浏览器下次再访问时，携带key（connect sid），找到对应的value（session) 。 客户的信息都保存在session中。 session 的解析依赖 cookieParser，先是从 cookie 中读取加密的 connect sid，再通过 cookieParser 解析成一个对应的 session id，该 session id 保存在 req.sessionID 中（因此 cookieParser中间件应该放到 session 之前）。</p><p>epxress.session 用的是 connect 的 session 中间件，而 session 中间件在起作用的时候，先是通过 session 的 Store 对象来读取当前的 session 数据，所以当多个请求并发过来的时候，他们拿到的会是同一份 session 数据。每个协议调用在 res.end() 的时候这个阶段 session 的数据会被自动 save 一次（req.session.save() 可以主动保存）。其内部的代码类似这样的：</p><p><a href="https://cnodejs.org/topic/53683f214f5bf53561006824" target="_blank" rel="noopener">关于 express 的 session 必须了解的同步问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> express </tag>
            
            <tag> session </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>论如何阅读API文档</title>
      <link href="/posts/e874/"/>
      <url>/posts/e874/</url>
      
        <content type="html"><![CDATA[<p>你是否常常对文档里出现的<code>[]</code>以及各种<code>...</code>有困惑？是否有一些神秘的文件告诉人们如何阅读所有API文档？</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101916.jpg" alt="6A9787A8-EA86-46A7-9BD6-BE1EC4F50B4F"></p><a id="more"></a><p>答案是可能没有什么标准，或者RFC，或者什么神秘文件来告诉我们阅读方法，有些API文档提供者会介绍他们各自文档的阅读方法（一般是extended BNF），而有些则不会，所以这就需要我们知道一些约定俗成的共识，我在这里简单说两个，更多的看得多了也就懂了。</p><h2 id="关于"><a href="#关于" class="headerlink" title="关于[]"></a>关于[]</h2><p>参数周围的方括号（[]）表示该参数是可选的。也就意味着可以省略，省略参数的前提是函数能识别你到底想传入的是哪一个参数，所以不管哪个语言，都有类似的约定：</p><ol><li>可省略的参数后置</li><li>省略参数后不能与其它函数产生二义性 (js不存在这个问题）</li></ol><p>程序要求你按参数定义的顺序传递参数进去。如果后面有没传的，就省略了。如果要省略中间的……对不起，自己传入 null 或 undefined。</p><p>对于 javascript 来说，可以对参数类型进行简单的判断来进行识别，以达到省略中间参数的效果，比如</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = function(name, date, age) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> date === <span class="string">"number"</span>) &#123;</span><br><span class="line">    age = date;</span><br><span class="line">    date = <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是简单通过类型来识别的。更复杂一些的情况可以使用正则表达式来识别 domain， url, email 等，不过说起来就比较麻烦了，而且代码逻辑复杂，也不易写。参数较多，部分可以省略的情况，建议使用参数对象，其他语言也有命名参数之类的特性。es6中已经有一些新式的传递参数的方法，这里不展开介绍了。</p><h2 id="关于…"><a href="#关于…" class="headerlink" title="关于…"></a>关于…</h2><p><code>[arg1, arg2...]</code>表示若干可选参数，”…”表示了若干，就是可以有很多，不止一个的意思。</p><h2 id="巴科斯范式"><a href="#巴科斯范式" class="headerlink" title="巴科斯范式"></a>巴科斯范式</h2><p>如果说有什么源头的话，可能都来自于一个叫巴科斯范式的东西，很多的linux手册以及各种软件的官方文档，所有稍微复杂点儿的语法规则几乎都是它定义的！ 巴科斯范式(BNF: Backus-Naur Form 的缩写)是由 John Backus 和Peter Naur首先引入的用来描述计算机语言语法的符号集。现在，几乎每一位新编程语言书籍的作者都使用巴科斯范式来定义编程语言的语法规则。</p><p>巴科斯范式的内容：</p><blockquote><p>在双引号中的字(“word”)代表着这些字符本身。而double_quote用来代表双引号。<br>在双引号外的字（有可能有下划线）代表着语法部分。<br>尖括号( &lt; &gt; )内包含的为必选项。<br>方括号( [ ] )内包含的为可选项。<br>大括号( { } )内包含的为可重复0至无数次的项。<br>竖线( | )表示在其左右两边任选一项，相当于”OR”的意思。<br>::= 是“被定义为”的意思。</p></blockquote><p>现在在网络上大多数能搜出来的都是extended BNF ，允许使用循环，但正真的BNF只需要递归就够了。</p><h2 id="HTTP-API"><a href="#HTTP-API" class="headerlink" title="HTTP API"></a>HTTP API</h2><p>即便是文档也有很多种，有些是函数api，包括系统函数的api，库函数的api都属于这种，一些面向对象语言还涉及了类和接口的概念，至于另一大类http api，这里有几篇文章说的还挺详细的：<a href="https://segmentfault.com/bookmark/1230000002521721" target="_blank" rel="noopener">HTTP API 设计指南</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://stackoverflow.com/questions/10925478/how-to-read-api-documentation-for-newbs" target="_blank" rel="noopener">https://stackoverflow.com/questions/10925478/how-to-read-api-documentation-for-newbs</a></p><p><a href="https://www.zhihu.com/question/27051306" target="_blank" rel="noopener">https://www.zhihu.com/question/27051306</a></p><p><a href="https://yq.aliyun.com/articles/74258" target="_blank" rel="noopener">https://yq.aliyun.com/articles/74258</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 文档阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm使用总结（1）探究依赖树</title>
      <link href="/posts/aadc/"/>
      <url>/posts/aadc/</url>
      
        <content type="html"><![CDATA[<p>在项目开发中，通常会使用<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>来管理项目中的依赖，下面我们就来看看它是如何帮助我们管理这些依赖的。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102024.jpg" alt="npm"></p><a id="more"></a><p>从最初npm v1版本到npm v3，再到最新的 npm v5，<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> 对于依赖的管理模式经历过三个主版本的重大变化。这次我们先讨论一下依赖树的变化，依赖树变化主要在于 v1（v2沿用v1，纯嵌套模式）和 v3（v4、v5沿用v3，扁平+嵌套模式）版本依赖方式的不同。</p><h2 id="npm-v1"><a href="#npm-v1" class="headerlink" title="npm v1"></a>npm v1</h2><p>最初的npm版本进行依赖管理时采用的是简单的嵌套模式。设想这里有三个模块：A，B，C。A 载入了 1.0 版本的 B 模块，但是 C 载入的是 2.0 版本的 B 模块：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">    A: "1.0.0",</span><br><span class="line">    C: "1.0.0"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A@<span class="number">1.0</span>.<span class="number">0</span> -&gt; B@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">C@<span class="number">1.0</span>.<span class="number">1</span> -&gt; B@<span class="number">2.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>通过执行 <code>npm install</code> 命令，生成的 node_modules目录如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├── A@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">│   └── node_modules</span><br><span class="line">│       └── B@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">└── C@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">    └── node_modules</span><br><span class="line">        └── B@<span class="number">2.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到在每个依赖下都还有一个 node_modules 目录来存放依赖的依赖。这种依赖管理模式简单明了，但是会有很多问题，除了 node_modules 目录长度的嵌套过深之外，还会造成相同的依赖存储多份的问题，造成存储空间的浪费。</p><h2 id="npm-v3"><a href="#npm-v3" class="headerlink" title="npm v3"></a>npm v3</h2><p>npm2 和npm1 一样使用嵌套的方式来安装所有的依赖，npm3 则试图减少结构树的深度和这种嵌套方式带来的冗余。 npm3 的依赖管理做出了重大的改变，尝试将二级依赖抹平（同时也会对二级依赖的依赖尽可能的展开），就是在同样的目录中像一级依赖那样去载入它。</p><p>npm3 关键的不同之处在于：</p><ul><li><p>目录结构中的位置不再能够显示包之间的依赖关系（一级, 二级等）</p></li><li><p>依赖的解决取决于安装的顺序，或者说安装的顺序会改变 node_modules 的目录结构</p></li></ul><p>对于上述情况，使用 npm 3 执行 npm install 命令后生成的 node_modules 目录如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">node_modules</span><br><span class="line">├── A@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">├── B@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">└── C@<span class="number">1.0</span>.<span class="number">0</span></span><br><span class="line">│   └── node_modules</span><br><span class="line">│       └── B@<span class="number">2.0</span>.<span class="number">0</span></span><br><span class="line">└── D@<span class="number">1.0</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以看到，在 npm 安装的过程中，npm3 会同时在 <code>/node_modules</code> 目录下扁平化地安装模块 A 和它的依赖，B 模块。而在 npm2 版本中则是以一种嵌套的方式完成安装的。</p><p>当我们需要再引入的另一个模块C，C 依赖模块 B, 但是与 A 依赖的不是同一个版本时。由于 v1.0 版本的 B 模块已经存在于目录的最顶层，我们不可能再将 v2.0 也安装到目录的顶级。npm3 此时的处理方式与 npm2 的行为一致，将新的，不同版本的模块 B 嵌套安装在依赖它的模块中 – 也就是此例中的 C 模块中。依赖树与npm2 对比如下图：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102026.jpg" alt="B5E7A9B3-48AB-4D02-95CB-422702FF90DE"></p><h2 id="更复杂的情况"><a href="#更复杂的情况" class="headerlink" title="更复杂的情况"></a>更复杂的情况</h2><p>这部分npm<a href="http://npm.github.io/how-npm-works-docs/npm3/duplication.html" target="_blank" rel="noopener">官方文档</a>有讲过，可以参考，这里还有<a href="http://coloration.cc/npmjs-documentation/2016/03/29/npmV3Duplication.html" target="_blank" rel="noopener">中文版</a>和<a href="https://github.com/ashleygwilliams/npm-sandbox/" target="_blank" rel="noopener">demo</a>。npm v3 及 v5 版本依赖树处理方式相同，我这里总结了几点经验（说的有点晕，不明白的可以找文档查看练习题，不过感觉文档说的也有些坑）：</p><ul><li>先安装的模块会尽可能的展开并占据顶层位置，扁平化地安装模块，所以目录结构中的位置不再能够显示包之间的依赖关系</li><li>如果 parent path 上有模块安装过了，那么 child 则不会继续安装，而如果发现顶级位置被同一个包的不同版本占用，并且占用无法删除（是一个顶级包，或者又被其他包依赖），则又回到了嵌套模式，将不同版本安装在自己目录下（即如果一个二级依赖被载入了两次，但是在目录层次中它并不处于第一层，那么它就会被复制并嵌套在主依赖下）</li><li>如果使用交互界面的 npm install 命令安装就意味着该模块是最后一个安装的，如果顶级依赖已经存在则删除之，再进行安装顶级依赖，展开二级，查看位置是否被占用，占用并且无法删除则嵌套安装的逻辑（就在这时安装信息可能就跟全部安装时遵循字母顺序的情况有出入，产生不确定性）</li><li>不确定性导致了两个人的 node_nodules 目录结构可能不同，但是不影响使用<ul><li>如果实在想使目录结构保持一致，可以删除 node_nodules 统一的不带参数的使用npm i，因为这时根据 package.json 安装，<strong>顺序始终遵循着字母表</strong>，相同的安装顺序便意味着会得到相同的结构树</li><li>可以用 npm dedupe 重新计算依赖关系，和删了 node_nodules 重新安装的效果一样</li></ul></li></ul><p><img src="https://images.leotian.cn/blog/2019-04-29-102027.jpg" alt="A7540637-7C7C-43F2-9858-7E33E2E2BFED"></p><p>​                （译：你的 <code>node_modules</code> 的目录结构和你的依赖树形式取决于<strong>安装顺序</strong>）</p><h2 id="关于循环依赖"><a href="#关于循环依赖" class="headerlink" title="关于循环依赖"></a>关于循环依赖</h2><p>循环依赖不会导致特别长的路径。因为从npm v1开始，npm在install的时候，同版本模块，parent path上有模块安装过了，child不会继续安装。可以<code>npm install npm-cycle-a</code>试下。</p><p>所以循环依赖在npm安装过程不是问题，真正的问题是执行时的依赖管理，尽管实际情况允许同一模块的两个不同版本可以在嵌套的位置共存，但是大多数的模块加载器并不能将它们同时载入到内存中。Node.js 的模块加载器在设计时已经考虑到了这种情况，它可以以一种很轻松地方式同时载入两个版本，而且不使它们相互冲突。</p><p>目前，通行的 JavaScript 模块化规范可以分为三种，<a href="http://link.zhihu.com/?target=http%3A//wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="noopener">CommonJS</a> 、 <a href="http://link.zhihu.com/?target=https%3A//github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a> 和 <a href="http://link.zhihu.com/?target=http%3A//www.ecma-international.org/ecma-262/6.0/" target="_blank" rel="noopener">ES6</a>。而关于运行时模块加载器如何处理循环依赖，实际上不同的规范在处理循环依赖时的做法也是不同的，Node.js一直采用的是CommonJS规范，至于各个模块规范具体如何处理，这里不展开讨论，有兴趣的可以看这篇<a href="(https://zhuanlan.zhihu.com/p/33049803">文章</a>)，里面介绍的比较详细。</p><h2 id="关于依赖地狱"><a href="#关于依赖地狱" class="headerlink" title="关于依赖地狱"></a>关于依赖地狱</h2><p>关于Dependency Hell，官方解释：</p><blockquote><p>A package manager would need to provide a version of module B. In all other runtimes prior to Node.js, this is what a package manager would try to do. This is dependency hell：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102029.jpg" alt="64B9E6C8-F837-4567-A46C-105A60086BE8"></p></blockquote><p>我的理解就是，B模块被A模块和C模块依赖并且依赖版本不同，包管理器需要提供某个版本的 B 模块，这在其他语言中是需要包管理器处理的。而npm选择了使用嵌套依赖的方式解决，这必然会带来一些路径过长、文件过多的问题，但是因为这是一个disk cheap的年代，为了快速开发的能力（最大程度的复用现有代码），这些缺点目前看来可以接受。关于依赖地狱更广义解释可以参考这篇<a href="https://zh.wikipedia.org/wiki/%E7%9B%B8%E4%BE%9D%E6%80%A7%E5%9C%B0%E7%8B%B1" target="_blank" rel="noopener">wiki</a>。</p><h2 id="对比yarn和cnpm"><a href="#对比yarn和cnpm" class="headerlink" title="对比yarn和cnpm"></a>对比yarn和cnpm</h2><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><p>yarn 生成的 node_modules 目录结构和 npm v3、npm v5 是相同的。</p><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>cnpm是淘宝的仓库，除了代表一个同步镜像，还代表了一个命令行工具，我们现在说的是这个命令。</p><p>cnpm在安装依赖时使用的是 <a href="https://github.com/cnpm/npminstall" target="_blank" rel="noopener">npminstall</a>，简单来说，cnpm 使用链接 link 的安装方式，最大限度地提高了安装速度，生成的 node_modules 目录采用的是和 npm 不一样的布局，直观的看是完全扁平的。用 cnpm 装的包都是在 node_modules 文件夹下以 版本号 @包名 命名，然后再做软链接到只以包名命名的文件夹上。如下图：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102037.jpg" alt="2123A94C-9A16-4D86-B013-ACAC1B35C3F4"></p><p>cnpm 和 npm 以及 yarn 之间最大的区别就在于生成的 node_modules 目录结构不同，这在某些场景下可能会引发一些问题。此外也不会生成 lock 文件，这就导致在安装确定性方面会比 npm 和 yarn 稍逊一筹。但是 cnpm 使用的 link 安装方式还是很好的，既节省了磁盘空间，也保持了 node_modules 的目录结构清晰，可以说是在npm v1嵌套模式和npm v3扁平+嵌套模式之间找到了一个平衡。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.zhihu.com/question/36697792" target="_blank" rel="noopener">如何评价node_modules的设计？</a></p><p><a href="https://juejin.im/entry/5835a2c0c59e0d005772a62f" target="_blank" rel="noopener">[译]JavaScript 包管理器工作原理简介</a></p><p><a href="https://github.com/fengliner/blog/issues/4" target="_blank" rel="noopener">探索 JavaScript 中的依赖管理及循环依赖问题</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm使用总结（2）探究版本锁</title>
      <link href="/posts/12fd/"/>
      <url>/posts/12fd/</url>
      
        <content type="html"><![CDATA[<p>上次说的 <code>node_modules</code> 的目录结构和依赖树取决于安装顺序只是 npm 非确定性（Non-Determinism）的一部分，这种不确定是不会影响使用的，所以我觉得更大的坑来自于语义化版本（semantic versioning, semver）带来的包升级的不确定性。<img src="https://images.leotian.cn/blog/2019-04-29-101921.jpg" alt="34648639-2cb71c5e-f3d8-11e7-9a1c-6ad418fce6ed副本"><a id="more"></a></p><p>在我的加班生涯中有一次印象深刻的经历，那次是晚上上线出了问题，但是代码在我的电脑上工作的很好，在测试环境也测试通过，偏偏在上线后出现了严重的问题，原因就是一个包在我电脑上的版本和线上的版本不同了，这个不兼容的升级搞出了这次事故。自此后我开始使用 npm shrinkwrap 来手动锁定版本。接下来我们讨论一下这个功能的必要性和使用。</p><h2 id="首先：什么是语义化版本"><a href="#首先：什么是语义化版本" class="headerlink" title="首先：什么是语义化版本"></a>首先：什么是语义化版本</h2><blockquote><p>一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：XYZ （主版本号.次版本号.修订号）修复问题但不影响API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p><p>我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p></blockquote><p>以上是<a href="https://semver.org/lang/zh-CN/" target="_blank" rel="noopener">semver</a>的官方解释，更多的规则和使用我找了两篇文章，感觉已经足够详细，在此不展开讨论。</p><p><a href="http://www.u396.com/semver-range.html" target="_blank" rel="noopener">语义化版本（SemVer）的范围</a></p><p><a href="https://zhuanlan.zhihu.com/p/20747196" target="_blank" rel="noopener">semver：语义化版本规范在 Node.js 中的实现</a></p><h2 id="其次：版本锁的必要性和使用npm-5"><a href="#其次：版本锁的必要性和使用npm-5" class="headerlink" title="其次：版本锁的必要性和使用npm 5"></a>其次：版本锁的必要性和使用npm 5</h2><h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><p>在Node.js项目开发的时候，我们也经常需要安装和升级对应的依赖。虽然 npm 以及语意化的版本号 (semantic versioning, semver) 让开发过程中依赖的获取和升级变得非常容易， 但不严格的版本号限制，也带来了版本号的不确定性。主要的问题可能有三个：</p><ol><li>npm 建议使用 semver 的应用程序版本，但这也完全依赖第三方包遵守这一规则。如果你依赖于的包不遵循 semver ，或者依赖的包的新版本有重大更改（而你使用了 ^ 的宽泛版本安装，实际上当 npm i xx —save 时默认就是用 ^ 来定义版本范围），这潜在可能是会导致问题的。</li><li>另一个问题的出现是由于 npm 安装依赖的机制。npm 的安装包是有层次结构的，手动控制要安装的软件包的版本号可以实现，但是你只能在 package.json 使用精确的版本号控制你的直接依赖包，但那些多层以上的依赖就没办法控制了；一个第三方包不严谨的版本依赖生命可能破坏你的依赖管理。</li><li>在开发阶段执行得到的版本，和后续部署时得到的可能是不一致的，更不可控的是，你依赖的第三方包也有这样的情况会导致潜在的上线风险。</li></ol><p><img src="https://images.leotian.cn/blog/2019-04-29-101922.jpg" alt="6022D8B3-32AD-406C-A874-FD9C96C51167"></p><p>如果要控制上线的风险，我们就必需要解决这些问题，这时候就需要使用到版本锁。当然，对于是否应该使用版本锁还有一些不同的意见：<a href="https://zhuanlan.zhihu.com/p/22934066" target="_blank" rel="noopener">为什么我不使用 shrinkwrap（lock）</a>。但我觉得对于我来说还是很有必要的，至少可以少踩一些上线的坑，不是吗哈哈。</p><h3 id="使用npm-5"><a href="#使用npm-5" class="headerlink" title="使用npm 5"></a>使用npm 5</h3><p>之前一直在使用shrinkwrap控制这个问题，对于shrinkwrap这里有一篇美团的教程：<a href="https://tech.meituan.com/npm-shrinkwrap.html" target="_blank" rel="noopener">使用 npm shrinkwrap 来管理项目依赖</a>。上次说到npm依赖管理的三次重要变化，依赖树的变化属于v1—v3版本的变化，而v3—v5的变化主要是安装时默认产生 lock 文件。也就是说，npm 在 v3 版本中是没有默认的版本锁的，如果想进行锁定需要使用 shrinkwrap，而 npm v5 版本是默认带版本锁功能的。</p><p>所以现在我们可以直接使用 npm v5 来进行最保险的版本控制了，还是上次的demo，这次我们用npm 5进行安装：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101924.jpg" alt="7DF1047F-FA6C-4F72-97D4-C354867F0561"></p><p>可以看到，用 npm v5 进行安装会显示安装时间，这点和 yarn 一样，并且默认产生了 lock 文件，npm ls 显示的依赖树也不太一样，deduped（重复数据删除，也就是顶级目录已经有了）的包也做了标记。</p><p>总结npm v5 的一些变化：</p><ol><li>改写了 cache 机制，速度跟 yarn 接近了（仍然慢一点点，但缓存将由 npm 来全局维护不再需要用户操心）</li><li>简化的 logging，安装完成后会打印耗时，跟 yarn 简直一样</li><li>安装时默认产生 <code>package-lock.json</code> 文件来记录依赖树信息，进行依赖锁定（存在 lock 时所有人安装产生的目录都一样，不过记录的依赖信息还是跟安装顺序有关，如果遇到：根据 npm i 安装完后再单独 npm i xxx 安装一个包而生成的 lock 文件安装，还是可能跟删除 node_modules 后完全重装的目录结构不一样，但这除了可能会产生一些多余的磁盘空间占用外不会有什么使用问题，一样是无关紧要的）</li><li>npm 的 lock 文件中的 resolved 优先级低于配置的 registry（这点比yarn好很多，尤其是在内部项目转外部开源的时候）</li><li>发布的模块不会包含 <code>package-lock.json</code> 文件（如果想要包含可以自行添加 <code>npm-shrinkwrap.json</code> 随包发布）</li><li>使用 <code>npm install xxx</code> 命令安装模块时，不再需要 <code>--save</code> 选项，会自动将模块依赖信息保存到 <code>package.json</code> 文件，除非加上 <code>--no-save</code></li></ol><h2 id="最后：不同包管理器的版本锁比较"><a href="#最后：不同包管理器的版本锁比较" class="headerlink" title="最后：不同包管理器的版本锁比较"></a>最后：不同包管理器的版本锁比较</h2><h3 id="npm-5对比npm-3"><a href="#npm-5对比npm-3" class="headerlink" title="npm 5对比npm 3"></a>npm 5对比npm 3</h3><p>npm 5 使用新的 shrinkwrap 格式，对比npm 3 的格式如下图：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101925.jpg" alt="17C1FF1F-725A-4362-9B09-D32B6CA74FF4"></p><p>npm 5 如果使用的<code>npm shrinkwrap</code>命令仍会产生名为<code>npm-shrinkwrap.json</code>的文件，不过产生的<code>npm-shrinkwrap.json</code>和<code>package-lock.json</code>是一模一样的（指其格式也是npm 5的新shrinkwrap格式），而如果已经存在<code>package-lock.json</code>会自动将<code>package-lock.json</code>重命名为<code>npm-shrinkwrap.json</code>。</p><h3 id="对比yarn"><a href="#对比yarn" class="headerlink" title="对比yarn"></a>对比yarn</h3><p>本来 yarn 相对于 npm@4 的区别主要就是：</p><ol><li>yarn 安装速度更快</li><li>yarn 默认会用 lock file 锁住依赖版本</li></ol><p>现在 npm@5 一改多年的挤牙膏作风，在以上方面都有改进，npm 相对于 yarn 更成熟，而且 yarn 用起来也不完美：</p><ol><li>yarn.lock 里带有 registry url ，且优先级高于配置中的 registry，切换 registry 时不太方便</li><li>yarn 对 npm 参数的支持度有限，可以说大部分参数都不支持</li><li>yarn 对 npm scripts 支持不完善，而且 npm 也再不断增加新的 life cycle scripts， yarn 在这方面有滞后性</li></ol><h3 id="对比cnpm"><a href="#对比cnpm" class="headerlink" title="对比cnpm"></a>对比cnpm</h3><p>cnpm 根本没有版本锁功能，所以也没有比较这回事了</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://tech.meituan.com/npm-shrinkwrap.html" target="_blank" rel="noopener">使用 npm shrinkwrap 来管理项目依赖</a></p><p><a href="https://github.com/muwenzi/Program-Blog/issues/112" target="_blank" rel="noopener">npm@5 新特性使用指南</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> shrinkwrap </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs文字转图片</title>
      <link href="/posts/72a3/"/>
      <url>/posts/72a3/</url>
      
        <content type="html"><![CDATA[<p>新版病历夹上线时接了一个召回老用户的临时需求，具体内容就是给老用户发一张邀请函，邀请函就是一张图片，然后要求在邀请函上写一些话，大概就是”亲爱的xxx，您已经使用病历夹xxx天，感谢xxx，邀请下载新版“之类的，因为发送给哪些用户不可能固定，固定也不可能做很多图，所以这种有规律的定制图片肯定需要代码来支持，在这里复盘一下我的开发过程。</p><a id="more"></a><h2 id="直观实现"><a href="#直观实现" class="headerlink" title="直观实现"></a>直观实现</h2><p>首先，邀请函图片如下：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102014.jpg" alt="img"></p><p>可以注意到图片中已经有行，第一次实现方法很脑残，就是图片设为background-image，然后在上面写字，内容是从后端请求回来的用户信息与文字模板的拼接，后端实时生成这些都没有问题，但是放到图片上结果肯定是对不齐，而且在我的界面对齐也毫无意义，因为需要适配各种设备。这根本是一种不过脑子的方法。</p><h2 id="改进方案"><a href="#改进方案" class="headerlink" title="改进方案"></a>改进方案</h2><p>认识到往图上悬浮文字行不通后我又让设计出了个图，这次的图只有上半部分，所以下半部分就可以我来实现。我写了下半部分的样式，加上了边框，加上了阴影效果，文字加上了underline，看起来很完美。</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102015.jpg" alt="1513854198910"></p><p>但是一调试还是会有各种问题，文字不是固定样式的，导致下划线根本无法整行，因为整行的话根本无法确定一行有几个字，而且不能保证在用户端正好一屏，要进行各种奇怪的适配。这种方案肯定也是不行的。</p><h2 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h2><p>改了半天我终于发现，我这样做是不行的，最好的解决方案肯定是直接返回一张图片，图片上已经是写好的字，这就要求我必须用代码实现根据具体信息生成定制化的图片，而且这些图片不需要保存，实时生成是最好的。这时我终于从cnode查到了最科学的实现方案：<a href="https://cnodejs.org/topic/583c5d9fba57ffba06c24a89" target="_blank" rel="noopener">node文字转图片</a>。</p><p>贴一下他的解决方案：</p><h3 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h3><p>文字转svg -&gt; svg转png -&gt; 合并图片</p><h3 id="相关轮子"><a href="#相关轮子" class="headerlink" title="相关轮子"></a>相关轮子</h3><ul><li>images Node.js 轻量级跨平台图像编解码库，不需要额外安装依赖</li><li>text-to-svg 文字转svg</li><li>svg2png svg转png图片</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>代码比较长，贴个地址：</p><p><a href="https://github.com/leotian/node-image" target="_blank" rel="noopener">node-image</a></p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>text-to-svg需要中文字体的支持，不然中文会乱码</li></ul><h2 id="其他思路"><a href="#其他思路" class="headerlink" title="其他思路"></a>其他思路</h2><p>看到狼叔说也可以用gm画，不过依赖要多一些。</p><p>我觉得html2canvas应该也可以，有空试一下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Node </tag>
            
            <tag> 代码生成图片 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站的logo图片用img标签还是背景图片?</title>
      <link href="/posts/db53/"/>
      <url>/posts/db53/</url>
      
        <content type="html"><![CDATA[<p>当你准备写一个logo的时候，第一反正是Img还是div？</p><a id="more"></a><p>之前写都是在混乱用，临时想到用哪个就用哪个，但是用哪种是正确的呢？让我们先看看SO上面这个问题的讨论：<a href="https://stackoverflow.com/questions/492809/when-to-use-img-vs-css-background-image" target="_blank" rel="noopener">html - When to use IMG vs. CSS background-image?</a></p><p><img src="https://images.leotian.cn/blog/2019-04-29-102011.jpg" alt="img"></p><p>下面是支持最多的答案（带翻译）：</p><p>Proper uses of IMG     //img的合适使用</p><ol><li>Use IMG if you intend to have people print your page and you want the image to be included by default. —JayTee                                    <ul><li>使用img：如果你想让人打印你的页面时该图片是被默认包含的</li></ul></li><li>Use IMG (with alt text) when the image has an important semantic meaning, such as a warning icon. This ensures that the meaning of the image can be communicated in all user-agents, including screen readers.  <ul><li>使用img（伴随alt文本）：当图片具有重要的语义，比如作为一个警告图标，这确保了这个图像的含义可以被所有的用户代理传达，包括屏幕阅读器</li></ul></li></ol><p>Pragmatic uses of IMG    //img的实际使用</p><ol><li>Use IMG if you intend to have people print your page and you want the image to be included by default. —JayTee  <ul><li>使用img：如果你想要。。。</li></ul></li><li>Use IMG if you rely on browser scaling to render an image in proportion to text size.   <ul><li>使用img：如果你依赖浏览器缩放去成比例的渲染一个图片到文本的大小</li></ul></li><li>Use IMG for multiple overlay images in IE6.<ul><li>使用img：在IE6使用多重覆盖图片</li></ul></li><li><del>Use IMG with a z-index in order to stretch a background image to fill its entire window.</del><br>Note, this is no longer true with CSS3 background-size; see #6 below.<ul><li>看第六条</li></ul></li><li>Using img instead of background-image can dramatically improve performance of animations over a background.<ul><li>使用img代替background-image可以显著的提升背景动画的性能</li></ul></li></ol><p>When to use CSS background-image    //何时使用CSS background-image</p><ol><li>Use CSS background images if the image is not part of the content. —sanchothefat<ul><li>使用CSS背景图：如果图片不是内容的一部分</li></ul></li><li>Use CSS background images when doing image-replacement of text eg. paragraphs/headers. —sanchothefat<ul><li>使用CSS背景图：当做文本的图片替换，例如段落、头部（可能是指图片作为标题头吧）</li></ul></li><li>Use background-image if you intend to have people print your page and you do not want the image to be included by default. —JayTee<ul><li>使用背景图：如果你想要有人打印你的页面并且不想该图片被包含进去</li></ul></li><li>Use background-image if you need to improve download times, as with CSS sprites.<ul><li>使用背景图：如果你需要改善下载时间，作为CSS精灵</li></ul></li><li>Use background-image if you need for only a portion of the image to be visible, as with CSS sprites.<ul><li>使用背景图：如果你只需要图片一部分课件，作为CSS精灵</li></ul></li><li>Use background-image with background-size:cover in order to stretch a background image to fill its entire window.<ul><li>使用背景图：通过background-size:cover以便伸展一个背景图片去填充满它的整个窗口</li></ul></li></ol><blockquote><p>先抛开实际操作中的问题，准则其实很简单，如果一张图片是网页内容的一部分，就该用 img ，否则就建议用 CSS 背景图。但问题的核心在于「Logo 是否属于网页内容的一部分」。从语义正确性角度个人倾向于用 img。——顾轶灵</p></blockquote><p>还有一些说法是【A标签+CSS定义背景图】对搜索引擎好，并且看了好多网站也是这么写的（知乎的logo用的就是这种方式，这种方式比IMG好就在于是个很好的锚文本链接，而且A标签也可以添加title属性，而IMG没有锚文本，只有title属性和alt文本。目前来说，搜索引擎对文本信息的识别要比alt中的文字友好的多）</p><p>最后说一个知乎前端网红【一丝】建议的方法：同时写背景图片和 img 标签，兼顾SEO 的同时在高对比度模式下也可以正常显示图片。使用 img 还有一个好处是，用户可以很方便的右键保存 Logo 或者复制 Logo 图片的链接，<a href="http://jsbin.com/cobaratofa/edit?html,css,output" target="_blank" rel="noopener">Demo</a>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"logo"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">!–</span> 注意 <span class="attr">a</span> 标签不要加 <span class="attr">title</span>，会造成部分读屏软件重复读取 –&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">tabindex</span>=<span class="string">"2"</span> <span class="attr">accesskey</span>=<span class="string">”1″</span> <span class="attr">href</span>=<span class="string">“#”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.w3.org/2008/site/images/logo-w3c-screen-lg"</span> <span class="attr">alt</span>=<span class="string">“W3C”</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">”alt-logo”</span>&gt;</span>W3C<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.logo</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(http://www.w3.org/2008/site/images/logo-w3c-screen-lg) no-repeat <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">249px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">107px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">10px</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.logo</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.logo</span> <span class="selector-class">.alt-logo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">z-index</span>: -<span class="number">1</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">22px</span>;</span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">25px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#075F9F</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.alt-logo 的作用是当图片加载失败的时候可以显示一个替代文本，如果只用兼容 IE8 以上，可以用 ::after 伪元素代替。<br>图片加载失败时的展现（Chrome）：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-102012.jpg" alt="img"><br>好吧，我觉得最后这种方法是照顾的比较全面的，不过貌似复制图片和图片链接的需求很小，所以我觉得一般A标签+CSS定义背景图就够了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> img </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat中三个重要的端口</title>
      <link href="/posts/9295/"/>
      <url>/posts/9295/</url>
      
        <content type="html"><![CDATA[<p>同一服务器部署多个tomcat时，存在端口号冲突的问题，所以需要修改tomcat配置文件server.xml，以tomcat7为例。</p><a id="more"></a><p>首先了解下tomcat的几个主要端口：</p><p>第一个连接器（connector）用于监听浏览器发送的请求，负责建立HTTP连接。在通过浏览器访问Tomcat服务器的Web应用时，使用的就是这个连接器。</p><ul><li>protocol：http协议</li><li>connectionTimeout：连接超时时间</li><li>redirectPort：如果发送的是https请求，就将请求转发到8443端口</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">”8080″</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">”HTTP/1.1″</span> </span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">”60000″</span>  </span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">”8443″</span></span></span><br><span class="line"><span class="tag">           <span class="attr">disableUploadTimeout</span>=<span class="string">”false”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">executor</span>=<span class="string">”tomcatThreadPool”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">”UTF-8″</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br></pre></td></tr></table></figure><p>第二个连接器（connector）监听8009端口，负责和其他的HTTP服务器建立连接。在把Tomcat与其他HTTP服务器集成时，就需要用到这个连接器。apache能过AJP协议访问tomcat的8009端口。httpd等反向代理tomcat时就可以使用使用ajp协议反向代理到该端口。虽然我们经常都是使用http反向代理到8080端口，但由于ajp建立tcp连接后一般长时间保持，从而减少了http反复进行tcp连接和断开的开销，所以反向代理中ajp是比http高效的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">”8009″</span> <span class="attr">protocol</span>=<span class="string">”AJP/1.3″</span> <span class="attr">redirectPort</span>=<span class="string">”8443″</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>第三个服务（server）监听8005端口，用来关闭Tomcat服务。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">”8005″</span> <span class="attr">shutdown</span>=<span class="string">”SHUTDOWN”</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以部署多个tomcat主要修改三个端口：</p><ol><li><p>HTTP端口，默认8080，如下改为8081</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">“8081”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">protocol</span>=<span class="string">“HTTP/1.1″</span></span></span><br><span class="line"><span class="tag">           <span class="attr">connectionTimeout</span>=<span class="string">“60000”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">redirectPort</span>=<span class="string">“8443”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">disableUploadTimeout</span>=<span class="string">“false”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">executor</span>=<span class="string">“tomcatThreadPool”</span></span></span><br><span class="line"><span class="tag">           <span class="attr">URIEncoding</span>=<span class="string">“UTF-8″</span></span></span><br><span class="line"><span class="tag">           /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>关闭服务端口，默认8005，如下改为8006</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">“8006”</span> <span class="attr">shutdown</span>=<span class="string">“SHUTDOWN”</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>AJP端口，默认8009，如下改为8010</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">“8010”</span> <span class="attr">protocol</span>=<span class="string">“AJP/1.3″</span> <span class="attr">redirectPort</span>=<span class="string">“8443”</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用阿里的字体图标—iconfont</title>
      <link href="/posts/f82c/"/>
      <url>/posts/f82c/</url>
      
        <content type="html"><![CDATA[<p>最近对病历夹网站的标签功能做了一些优化，其中就使用到了阿里的字体图标——iconfont。</p><a id="more"></a><p>说到iconfont，首先可以看一下<a href="https://zhuanlan.zhihu.com/p/19564505" target="_blank" rel="noopener">介绍</a>。</p><p>图标的制作和上传可以参照官网给出的<a href="http://www.iconfont.cn/help/detail?helptype=draw" target="_blank" rel="noopener">文档</a>。</p><p>图标的下载和使用官网上说的不是很清楚，简单介绍下：</p><ol><li><p>首先在Iconfont-阿里巴巴矢量图标库上面将你需要的图标点击购物车按钮加入“暂存架”。<br><img src="https://images.leotian.cn/blog/2019-04-29-101939.jpg" alt="iconfont1"></p></li><li><p>选择完所有要用的图标后“存储为项目”，给它命名。然后在“图标管理”-“图标应用项目”中找到这个项目，获取在线链接，把里面的代码复制到CSS中。</p><p> <img src="https://images.leotian.cn/blog/2019-04-29-101946.jpg" alt="iconfont2"></p></li><li><p>在HTML中需要使用到图标时，使用iconfont类名。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"iconfont"</span>&gt;</span>&amp;#xe600;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">//注意这里用i标签其实不太符合html语法，可以使用span</span><br></pre></td></tr></table></figure><p>里面写上你想用的图标下面的Unicode：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101947.jpg" alt="iconfont3"></p></li><li><p>然后你可以通过控制iconfont类的属性改变图标的样式，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"iconfont"</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-webkit-text-stroke-width</span>: <span class="number">0.2px</span>;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">20px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就可以在页面中引用和修改了。</p><p>这些图标也可以下载到本地使用。图标都加入暂存架后选择“下载到本地”，会得到以下几个文件：</p><p><img src="https://images.leotian.cn/blog/2019-04-29-101948.jpg" alt="iconfont4"></p><p>浏览器打开demo.html可以看到每个图标的Unicode，把iconfont.css里的代码复制到css里面，把下面四个文件放到css可以引用到的文件夹里就可以了。下载使用的一个缺点是添加图标的话要重新把所有图标再下载一遍覆盖原来的文件，如果是在线链接只要重新生成一次链接就好了。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> iconfont </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用hexo搭建个人博客</title>
      <link href="/posts/a927/"/>
      <url>/posts/a927/</url>
      
        <content type="html"><![CDATA[<p>毕业后阿里云学生服务器到期，把博客从阿里云迁移到了腾讯云，用的也是同学的学生服务器，最近同学的服务器也到期了，就想从WordPress转到hexo，这要做的好处是只买个域名就行了，不需要一台专门的服务器了。</p><a id="more"></a>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> github </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
